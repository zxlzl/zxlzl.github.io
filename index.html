<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>随便写写~</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="随便写写~">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="随便写写~">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zxl">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="随便写写~" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">随便写写~</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-《Just-JavaScript》02-JavaScript宇宙" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/01/%E3%80%8AJust-JavaScript%E3%80%8B02-JavaScript%E5%AE%87%E5%AE%99/" class="article-date">
  <time datetime="2020-04-01T01:02:26.000Z" itemprop="datePublished">2020-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/01/%E3%80%8AJust-JavaScript%E3%80%8B02-JavaScript%E5%AE%87%E5%AE%99/">《Just JavaScript》02.JavaScript宇宙</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在JavaScript中，它的开始就是值。</p>
<p>什么是指？这很难解释。</p>
<p>这就好比问数学中的数字是什么，几何中的点是什么。值就是JavaScript中的类似这样的一个东西。</p>
<p>数字是值，但其他东西也是值，比如对象和函数。但是很多东西，比如if语句或变量声明都不是值。</p>
<h2 id="值和代码"><a href="#值和代码" class="headerlink" title="值和代码"></a>值和代码</h2><p>为了将我们的JavaScript程序中的所有值与其他值区别开来，我想象一下安东尼画的小王子：</p>
<p><img src="/blog_imgs/just_javascript/02/little_prince.jpg" alt=""></p>
<p>我站在一颗小行星上——这是我程序的代码。</p>
<p>从表面上看，我看到了if语句和变量声明、逗号、大括号以及可能从JavaScript代码中找到的所有其他东西。</p>
<p>我得代码包括“函数调用”或是“多次执行此操作”甚至“抛出错误”等指令。我一步一步地完成这些指令——在我的小行星上做着差事。</p>
<p>但偶尔我会抬头看看。</p>
<p>在一个晴朗的夜晚，我在JavaScript天空中到了不同的值：booleans、numbers、strings、symbols、functions、objects、null和undefined——天呐！我可以在代码中使用他们，但他们并不存在于代码中。</p>
<p>在我的JavaScript宇宙中，值飘荡在太空。</p>
<p><img src="/blog_imgs/just_javascript/02/universe.png" alt=""></p>
<p>“等等，”你可能会说，“我一直认为值存在于我的代码里！”。在这里，我请求你的认知发生飞跃性的变化。要想成功构建这样的思维模型，还需要几个模块。<a href="https://www.jianshu.com/p/9adb15be9ac2" target="_blank" rel="noopener">Give It Five Minutes</a></p>
<p>回到值上面。大体上，这有两种值。</p>
<h3 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h3><p><strong>原始值</strong>包括数字和字符串等。打开浏览器的控制台并使用 <code>console.log()</code> 打印以下原始值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure>

<p>所有的原始值都有一些共同点。<strong>我的代码中没有什么可以影响他们</strong>。这听起来有点模糊，所以我们将在下一个模块中具体探讨这是什么意思。现在，我要说的是，原始值就像星星一样——冰冷而遥远，但在我需要它们的时候总是在那里。</p>
<p>这是第一种值。</p>
<h3 id="对象和函数"><a href="#对象和函数" class="headerlink" title="对象和函数"></a>对象和函数</h3><p><strong>对象和函数</strong>也是值，但他们不是原始值。这使他们变得特别。继续在控制台打印一些这样的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log([])</span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>请注意，浏览器的控制台是如何以不同于原始值的方式显示它们的。有些浏览器可能会在他们前面显示一个箭头，或者单点击它们的时候执行一些特殊的操作。如果你安装了一些不同的浏览器（例如Chrome和Firefox），比较它们是如何可视化对象和函数的。</p>
<p>对象和函数是特殊的，因为我可以从代码中操作它们。举个例子，我可以将它们与其他值连接起来。这也是模糊的——所以我们将在后面的模块中完善这个想法。现在，我可以说，<br>如果原始值像遥远的恒星，那么对象和函数更像漂浮在代码附近的岩石。它们离得很近，我才能够操作它们。</p>
<p>这就是第二种值。</p>
<p>你可能有问题。很好。如果你问一个问题，JavaScript世界可能会回答它！当然前提是你知道怎么提问。</p>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>但也有很多问题JavaScript无法回答。如果你想知道是向你最好的朋友坦白你的真实感受，还是一直等到你俩变成骷髅，JavaScript不会有多大帮助。</p>
<p>但是JavaScript很乐意回答这样的一些问题。这些问题有一个特殊的名字——表达式。</p>
<p>如果我们“询问”表达式2+2，JavaScript将用4“回答”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> + <span class="number">2</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p><strong>表达式是JavaScript可以回答的问题。JavaScript使用它唯一知道的方式——值，回答表达式。</strong></p>
<p><img src="/blog_imgs/just_javascript/02/expression.gif" alt=""></p>
<p>如果“表达式”这个词让你感到困惑，请将其视为一段表示值的代码。你可能会听到人们说2+2“结果”或“得到”4。这些都是说同一件事的不同方式。</p>
<p>我们问JavaScript 2+2，它的答案是4。表达式总是得到一个值。现在我们对表达方式的了解已经足够危险了！</p>
<p>我之前说JavaScript有多种值：numbers、strings、objects等等。我们如何知道每次说的是哪种值呢？</p>
<p>这听起来是个问题。我们敢问吗？</p>
<h3 id="检查类型"><a href="#检查类型" class="headerlink" title="检查类型"></a>检查类型</h3><p>首先，JavaScript宇宙中的所有值可能看起来都一样——就像天空中的亮点。但是如果你仔细观察，你会发现只有不到十种不同类型的值。相同类型的值的行为方式类似。</p>
<p>如果我们想检查一个值的类型，我们可以用typeof运算符。JavaScript将用一个预先确定的字符串值来回答我们的问题，比如“number”、“string”或“object”。</p>
<p><img src="/blog_imgs/just_javascript/02/telescope.png" alt=""></p>
<p>下面是一些您可以在浏览器控制台中尝试的示例:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="number">2</span>)); <span class="comment">// "number"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="string">"hello"</span>)); <span class="comment">// "string"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="literal">undefined</span>)); <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure>

<p>这里， <code>typeof(2)</code> 是一个表达式，它得到“number”值。</p>
<p>严格的说，typeof不需要使用括号。例如， <code>typeof 2</code> 和 <code>typeof(2)</code> 的工作原理是相同的。然而，有时需要括号来避免歧义。如果我们在typeof后面省略了括号，下面的一个例子就会中断。试着猜猜是哪一个：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(&#123;&#125;)); <span class="comment">// "object"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>([])); <span class="comment">// "object"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>)); <span class="comment">// "function"</span></span><br></pre></td></tr></table></figure>

<p>你可以在浏览器控制台中验证你的猜测。</p>
<p><img src="/blog_imgs/just_javascript/02/typeof.gif" alt=""></p>
<p>现在再来看看最后三个例子——这次要密切关注它们的结果。你有没有发现这些结果令人惊讶？为什么？</p>
<h2 id="值的类型"><a href="#值的类型" class="headerlink" title="值的类型"></a>值的类型</h2><p>作为一个有抱负的天文学家，您可能想知道JavaScript宇宙中可以观察到的每一种类型的值。经过将近25年的JavaScript研究，科学家们只发现了9种类型。</p>
<h3 id="原始值-1"><a href="#原始值-1" class="headerlink" title="原始值"></a>原始值</h3><ul>
<li><strong>Undefined</strong>(undefined)，用于无意中丢失的值</li>
<li><strong>Null</strong>(null), 用于故意丢失的值</li>
<li><strong>Booleans</strong>(true or false)，用于逻辑操作</li>
<li><strong>Numbers</strong>(-100, 3.14… )，用于数学计算</li>
<li><strong>Strings</strong>(“hello”, “abracadabra”… )，用于文本</li>
<li><strong>Symbols</strong>(不常见)，用于隐藏实现的细节</li>
<li><strong>BigInts</strong>(不常见、新的)，用于计算大数</li>
</ul>
<h3 id="对象和函数-1"><a href="#对象和函数-1" class="headerlink" title="对象和函数"></a>对象和函数</h3><ul>
<li><strong>Objects</strong>({}… )，用于分组相关的数据和代码</li>
<li><strong>Functions</strong>( <code>x =&gt; x * 2</code> … )，用于引用代码</li>
</ul>
<h3 id="没有别的类型了"><a href="#没有别的类型了" class="headerlink" title="没有别的类型了"></a>没有别的类型了</h3><p>你可能会问：“那我使用的别的类型呢？比如数组？”</p>
<p><strong>在JavaScript中，除了我们刚刚列举的值类型之外，没有其他基本值类型了</strong>。剩下的都是对象！例如，甚至数组、日期和正则表达式基本上都是JavaScript中的对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>([])); <span class="comment">// "object"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="keyword">new</span> <span class="built_in">Date</span>())); <span class="comment">// "object"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="regexp">/(hello|goodbye)/</span>)); <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure>

<p>“我知道，”你可能会说，“这是因为一切都是对象！”。唉，这是一个流行的都市传说，但事实并非如此。尽管像 <code>&quot;hi&quot;.toUpperCase()</code> 这样的代码使 <code>&quot;hi&quot;</code> 看起来像一个对象，但这只是一个幻觉。JavaScript会在执行此操作时创建包装器对象，然后立即将其丢弃。</p>
<p>如果这个机制不太好明白也没事。<strong>现在，你只需要记住原始值（如数字和字符串）不是对象。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>让我们回顾一下我们目前所知道的：</p>
<ol>
<li><strong>除了值就是别的</strong>：我们可以将值视为JavaScript雨中中“飘荡”的不同事物。它们不存在于我们的代码中，但我们可以从代码中引用它们。</li>
<li><strong>有两种值</strong>：它们是原始值，然后是对象和函数。总共有九种不同类型的值，每种类型都有特定的用途，但有些很少使用。</li>
<li><strong>有些值很孤单</strong>：比如null是Null类型的唯一的值，undefined也是Undefined类型的唯一值。我们之后会学习它，这两个孤独的值在很大程度上就是麻烦制造者。</li>
<li><strong>我们可以使用表达式提问</strong>：JavaScript将会用值来回答我们。例如，表达式2+2的答案是4。</li>
</ol>
<p>5.<strong>我们可以通过typeof表达式来检测值的类型</strong>：比如， <code>typeof(4)</code> 得到字符串“number”。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>是时候学以致用了。</p>
<p>即使你已经有了相当丰富的JavaScript经验，也不要跳过练习题！就在几年前，我从其中学到了一些东西。</p>
<p><a href="https://eggheadio.typeform.com/to/PLyTKB?email=akihi95@gmail.com&ck_subscriber_id=767004595" target="_blank" rel="noopener">点击此处去做练习！</a></p>
<p>接下来我们将更详细地探讨原始值。我们看看这些不同的类型（比如数字和Null）有什么共同点，并学习相等在JavaScript中意味着什么。</p>
<p>我们还将继续完善我们的思维模型。这部分提供了一个粗略的草图——一个近似值。我们将把焦点放在图片的不同部分，并用更多的细节填充它们，如<a href="https://www.liquidweb.com/kb/what-is-a-progressive-jpeg/?ck_subscriber_id=767004595" target="_blank" rel="noopener">渐进式JPEG图像</a>。</p>
<p>这些看起来是很小的一步，但我们正在为未来的一切奠定基础。我们正在一起构建JavaScript宇宙。</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>1.<a href="https://2ality.com/2013/10/typeof-null.html" target="_blank" rel="noopener">The history of “typeof null”</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/01/%E3%80%8AJust-JavaScript%E3%80%8B02-JavaScript%E5%AE%87%E5%AE%99/" data-id="ck8gn5gmw0001hk9hh4lw0gyj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-《Just-JavaScript》01-思维模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/31/%E3%80%8AJust-JavaScript%E3%80%8B01-%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time datetime="2020-03-31T13:40:45.000Z" itemprop="datePublished">2020-03-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/31/%E3%80%8AJust-JavaScript%E3%80%8B01-%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B/">《Just JavaScript》01.思维模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>读以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">a = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>当他们运行后a和b的值是多少？在你往下阅读之前，先在你的脑子中想出答案。</p>
<p>如果你已经写了一段时间的JavaScript，你可能会想：“这比我每天写的代码简单多了，意义何在？”</p>
<p>这个练习的目标不是向你介绍变量，我们认为你已经对这些很熟悉了。相反的，它是为了让你注意并反思你的思维模型。</p>
<h2 id="什么是思维模型"><a href="#什么是思维模型" class="headerlink" title="什么是思维模型"></a>什么是思维模型</h2><p>再次阅读上面的代码，目的是真正确定结果是什么。（我们稍后看为什么这个目的很重要）</p>
<p>当你第二次读它的时候，一步步地注意你脑子里发生的事，你可能会有这样的独白：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.声明一个变量a,并给它赋值10</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 2.声明一个变量b,将a的值赋给它,a为10,所以b也为10</span></span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"><span class="comment">// 3.将0赋给a</span></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 4.所以最后的答案是a的值为0，b的值为10</span></span><br></pre></td></tr></table></figure>

<p>可能你脑中想的会有点不一样，可能你想的是给a设置值而不是赋值，或者你可能用不同的顺序读它。甚至你最后得出了不同的结果。注意一下具体哪里不同，即使是这段独白也无法真正捕捉到你脑海中发生的事情。你可能会说“把b设为a”，但是设置一个变量意味着什么呢？</p>
<p>你可能会发现，对每个熟悉的基本编程概念（比如变量）和操作（比如赋值），会有一套根深蒂固的类比与之相关。一些来自于现实的世界，其他的可能会从你最初学到的领域重新运用，比如数学中的数字。这些类比可能会部分重叠甚至矛盾，但是它们仍然帮助你理解在代码中发生了什么。</p>
<p>举个例子，很多人最初把变量当做盒子来学习，你可以往里面放东西。当你看到一个变量的时候，尽管你并没有真正地想象出一个盒子，但是在你的脑海里它们可能仍表现得像一个盒子。这些在你脑海中相似的运作方式被我们称做思维模型。思维模型对编程很久的你来说可能有难度，但是你要尝试注意和反思它们。它们可能是视觉的、空间的和机械的思维捷径的组合。</p>
<p>这些直觉（类似把变量比作盒子）在我们整个编程生涯中会影响我们如何读代码。但是有时候，我们的思维模型是错误的。可能我们早期读过的辅导课为了能简单的解释一些东西而牺牲了它的正确性。也许我们错误的从之前学过的另一种语言转移了关于特定语言特征的直觉。也许我们从某段代码推断出一种思维模型，但从未验证它是否准确。</p>
<p>识别和解决这些问题就是这本书《Just JavaScript》的全部内容。我们将逐步构建（或者，可能的话，重新构建）你关于JavaScript的思维模型，使之准确而有用。一个好的思维模型将会帮助你更快的定位和修复bug，更好的理解别人的代码，对你自己写的代码更自信。</p>
<p>（顺带一提，a的值为0，b的值为10是正确答案）。</p>
<h2 id="快慢编码"><a href="#快慢编码" class="headerlink" title="快慢编码"></a>快慢编码</h2><p>丹尼尔·卡尼曼的《思考，快与慢》是一本广受欢迎的非小说类书籍。它的中心论点是，人类在思考时使用两种不同的“系统”。</p>
<p>只要有可能，我们就依靠“快速”系统。我们与许多动物共享这个紫铜，这给我们惊人的力量，就像走路时不摔倒一样。这个“快速”系统擅长模式匹配（生存所必需！！）以及“内脏反应”。但是它并不擅长计划。</p>
<p>独特的是，由于额叶的发育，人类也有一个“慢”思维系统。这个“慢”思维系统负责复杂的逐步的推理。它让我们计划未来的事件，参与争论或遵循数学证明。</p>
<p>因为使用“慢”系统在精神上非常消耗，所以我们倾向于默认使用“快”系统，即使在处理诸如编码之类的智能任务时也是如此。</p>
<p>想象你正忙于大量的工作，并且你希望快速识别此函数的功能，快速浏览以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">duplicateSpreadsheet</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (original.hasPendingChanges) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'You need to save the file before you can duplicate it.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> copy = &#123;</span><br><span class="line">        created: <span class="built_in">Date</span>.now(),</span><br><span class="line">        author: original.author,</span><br><span class="line">        cells: original.cells,</span><br><span class="line">        metadata: original.metadata,</span><br><span class="line">    &#125;;</span><br><span class="line">    copy.metadata.title = <span class="string">'Copy of '</span> + original.metadata.title;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能会思考：</p>
<ul>
<li>这个函数复制一个电子表格</li>
<li>如果初始电子表格不存在它会抛出错误</li>
<li>它给新的电子表格标题前加了“Copy of”</li>
</ul>
<p>你可能没有注意到（如果你注意到了，那就太好了！）这个函数也意外地改变了原始电子表格的标题。</p>
<p>每个程序员每天都会遇到这样的错误。但是现在你知道bug存在了，你会换种方式读代码吗？如果你一直在使用“快”模式阅读代码，则很可能会切换到更费劲的“慢”模式来查找他。</p>
<p>在“快”模式下，我们通过名字、注释和它总体的结构猜测代码干了什么。而在“慢”模式下，我们逐步追溯代码做了什么。</p>
<p>这就是为什么正确的思维模式非常重要。在我们的脑海中模拟一台计算机已经够难了——而这种努力被错误的思维模式所浪费。</p>
<p>如果你根本找不到bug，别担心，这意味着你会从这门课中得到最大的收获！在接下来的模块中，我们将一起重塑JavaScript的思维模型，以便你一目了然地看到bug。</p>
<p>在下一个模块，我们将开始为一些最基本的JavaScript概念（值和变量）构建思维模型。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/31/%E3%80%8AJust-JavaScript%E3%80%8B01-%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B/" data-id="ck8gn5gmo0000hk9h3qj9ctnx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-内存模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/31/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time datetime="2019-07-31T06:21:08.000Z" itemprop="datePublished">2019-07-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/31/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">内存模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="计算机所有信息的存储方式"><a href="#计算机所有信息的存储方式" class="headerlink" title="计算机所有信息的存储方式"></a>计算机所有信息的存储方式</h3><p>计算机中采用二进制表示各种信息，也就是0和1，字节是基本单位。</p>
<h4 id="一、计算机中数的表示"><a href="#一、计算机中数的表示" class="headerlink" title="一、计算机中数的表示"></a>一、计算机中数的表示</h4><h5 id="1-表示范围"><a href="#1-表示范围" class="headerlink" title="1.表示范围"></a>1.表示范围</h5><p>计算机数的表示范围跟字节有关：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>表示方式</th>
</tr>
</thead>
<tbody><tr>
<td>无符号数</td>
<td>0 ~ 2^n-1</td>
</tr>
<tr>
<td>有符号数</td>
<td>-2^(n-1)-1 ~ 2^(n-1)-1</td>
</tr>
</tbody></table>
<p>小数：符号位+整数位+指数位<br>非法数字：NaN<br>正无穷大，负无穷大：±∞</p>
<h5 id="2-原码、反码、补码"><a href="#2-原码、反码、补码" class="headerlink" title="2.原码、反码、补码"></a>2.原码、反码、补码</h5><ul>
<li>原码：正数的原码是将数的符号位用0表示，负数的原码是将数的符号位用1表示。  </li>
<li>反码：反码表示为符号位不变，其余位按位取反。</li>
<li>补码：原码除符号位外每位取反加1。  </li>
</ul>
<p>对于正数，原码=反码=补码；对于负数，它的符号位是1，反码就是除符号位每位取反，补码是它的反码加一。计算机对于数字是以补码的方式存储，因为不以补码的方式存储0会有两个存储方式，正数和负数相加结果不对。</p>
<h5 id="3-位运算"><a href="#3-位运算" class="headerlink" title="3.位运算"></a>3.位运算</h5><p>或运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 | 0 &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>与运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &amp; 0 &#x3D; 0;</span><br></pre></td></tr></table></figure>
<p>异或运算（同0异1）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 ^ 0 &#x3D; 1; 1 ^ 1 &#x3D; 0; 0 ^ 0 &#x3D; 0;</span><br></pre></td></tr></table></figure>
<p>取反</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~0 &#x3D; 1; ~1 &#x3D; 0;</span><br></pre></td></tr></table></figure>


<p>位移（左：低位补0，右移：高位补0）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;&lt; 2 &#x3D; 0000 0001 &lt;&lt; 2 &#x3D; 0000 0100 &#x3D; 4</span><br></pre></td></tr></table></figure>
<p>应用：</p>
<h6 id="求数字x的第y位为0还是1"><a href="#求数字x的第y位为0还是1" class="headerlink" title="求数字x的第y位为0还是1"></a>求数字x的第y位为0还是1</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int getFlag(int x,int y) &#123;</span><br><span class="line">    return (x &gt;&gt; (32 - y)) &amp; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="将数字x的第y位设为0或1"><a href="#将数字x的第y位设为0或1" class="headerlink" title="将数字x的第y位设为0或1"></a>将数字x的第y位设为0或1</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int setFlag(int x,int y,int v) &#123;</span><br><span class="line">    if(v &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return x &amp; 1 &lt;&lt; ~(32 - y)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return x | (1 &lt;&lt; (32 - y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二、编码"><a href="#二、编码" class="headerlink" title="二、编码"></a>二、编码</h4><p>对于不同国家的语言有不同的编码方式，同样的编码在不同地方会被解释成不同的语言符号。假如我们想要打开一个文件，比如知道它的编码方式是什么，用它的编码方式打开，否则用错误的编码方式打开文件，就会遇到乱码问题。</p>
<h5 id="1-ASCII码"><a href="#1-ASCII码" class="headerlink" title="1.ASCII码"></a>1.ASCII码</h5><p>ASCII码一共定义了128个字符的编码。</p>
<h5 id="2-Unicode"><a href="#2-Unicode" class="headerlink" title="2.Unicode"></a>2.Unicode</h5><p>英语使用128个符号编码就够了，但是用来表示其他国家的语言却不够。所有就产生了这样的需求：需要一种编码，将世界各个国家所有的语言符号都包括进去。那么每一个符号都有对应的编码，那么我们可以通过这种编码查看文件就不会产生乱码的问题。这就是Unicode，它的名字即表示这是一种独一无二的编码。</p>
<h5 id="3-UTF-8"><a href="#3-UTF-8" class="headerlink" title="3.UTF-8"></a>3.UTF-8</h5><p>UTF-8是Unicode的实现方式之一。</p>
<h5 id="4-gb2312"><a href="#4-gb2312" class="headerlink" title="4.gb2312"></a>4.gb2312</h5><p>gb2312是中文简体字编码。已经包括了我们生活中最常用的所有汉字与一些符号。</p>
<h5 id="5-gbk"><a href="#5-gbk" class="headerlink" title="5.gbk"></a>5.gbk</h5><p>由于中文汉字繁多，gb2312只包括了六千多个汉字，还不能够完全表示，所以gbk在gb2312的基础上兼容扩展了更多的汉字，还包括繁体字。</p>
<h4 id="三、内存分配"><a href="#三、内存分配" class="headerlink" title="三、内存分配"></a>三、内存分配</h4><h5 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1.基本类型"></a>1.基本类型</h5><p>基本类型在内存空间直接存储它们相应的值，比如数字，字符串。</p>
<h5 id="2-引用类型"><a href="#2-引用类型" class="headerlink" title="2.引用类型"></a>2.引用类型</h5><p>引用类型在内存空间不直接存储它们的值，而是存储这个数据的引用。比如数组、函数。</p>
<h5 id="3-堆栈"><a href="#3-堆栈" class="headerlink" title="3.堆栈"></a>3.堆栈</h5><p>基本类型和引用类型分别存储在内存的栈和堆中。基本类型是存储在栈中的简单数据，如果我们对他进行修改，是可以直接修改成功的，而引用类型值是存储在堆中的对象，如果有两个相同对象指向同一个引用，我们修改其中一个会导致另一个也跟着修改。</p>
<h4 id="五、内存回收"><a href="#五、内存回收" class="headerlink" title="五、内存回收"></a>五、内存回收</h4><p>这个问题等我哪天想明白了再更新。。。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/31/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" data-id="ck8gofbct000xhk9hg2kq2xqw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-闭包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/01/%E9%97%AD%E5%8C%85/" class="article-date">
  <time datetime="2019-04-01T14:21:08.000Z" itemprop="datePublished">2019-04-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/01/%E9%97%AD%E5%8C%85/">闭包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>&emsp;&emsp;和大多数现代编程语言一样，JavaScript也采用词法作用域，也就是说，函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定的。为了实现这这种词法作用域，JavaScript函数对象的内部状态不仅包含函数的逻辑代码，还必须引用当前的<code>作用域链</code>。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性被称为<code>&quot;闭包&quot;</code>。</p>
<blockquote>
<p>&emsp;&emsp;作用域链：每一段JavaScript代码(全局代码或函数)都有一个与之关联的作用域链(scope chain)。这个作用域链是一个对象列表或者链表，这组对象定义了这段代码”作用域中”的变量。当JavaScript需要查找变量x的值的时候(这个过程称做”变量解析”)，它会从链中的第一个对象开始查找，如果这个对象有一个名为x的属性，则会直接使用这个属性的值，如果第一个对象中不存在名为x的属性，JavaScript会继续查找链上的下一个对象。如果第二个对象依然没有名为x的属性，则会继续查找下一个对象，以此类对。如果作用域链上没有任何一个对象含有属性x，那么久人为这段代码的作用域链上不存在x，并最终抛出一个引用错误异常。<br>&emsp;&emsp;在JavaScript最顶层代码中(也就是不包含在任何函数定义内的代码)，作用域链由一个全局对象组成。在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域链上至少有三个对象。当定义一个函数时，它实际上保存一个作用域链。当调用这个函数时，它穿件一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的”链”。对于嵌套函数来讲，每次调用外部函数时，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都有微妙的差别——在每次调用外部函数时，内部函数的代码都是相同的，而且关联这段代码的作用域链也不相同。</p>
</blockquote>
<p>&emsp;&emsp;所有的JavaScript函数都是闭包；他们都是对象，他们都关联到作用域链。定义大多数函数时的作用域链在调用函数时依然有效，但这并不影响闭包。当调用函数时闭包所指向的作用域链和定义函数时的作用域链不是同一个作用域链时，就会有一些微妙的变化。当一个函数潜逃了另外一个函数，外部函数将嵌套的函数对象作为返回值返回的时候往往会发生这种事情。有很多强大的编程技术都利用到了这类嵌套的函数闭包，以至于这种编程模式在JavaScript中非常常见。<br>&emsp;&emsp;理解闭包首先要了解嵌套函数的此法作用域规则:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;  <span class="comment">// 全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;  <span class="comment">// 局部变量</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope;   <span class="comment">// 在作用域中返回这个值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope()  <span class="comment">// =&gt; "local scope"</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>checkscope()</code>函数声明了一个局部变量，并定义一个函数<code>f()</code>，函数<code>f()</code>返回了这个变量的值，最后将函数<code>f()</code>的执行结果返回。对上面的代码做一点改动：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;  <span class="comment">// 全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;  <span class="comment">// 局部变量</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope;   <span class="comment">// 在作用域中返回这个值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这段代码中，函数内的一对圆括号移动到了<code>checkscope()</code>之后。<code>checkscope()</code>现在仅仅返回函数内嵌套的一个函数对象，而不是直接返回结果。在定义函数的作用域外面，调用这个嵌套的函数（包含最后一行代码的最后一对括号），最后仍会返回<code>&quot;local scope&quot;</code>。<br>&emsp;&emsp;词法作用域的基本规则：JavaScript函数的执行用到了作用域链，这个作用域链是函数定义的时候创建的。嵌套的函数<code>f()</code>定义在这个作用域链里，其中的变量scope一定是局部变量，不管在何时何地执行函数<code>f()</code>，这种绑定在执行<code>f()</code>时依然有效，因此最后一行代码返回<code>&quot;local scope&quot;</code>，而不是<code>&quot;global scope&quot;</code>。简言之，闭包这个特性很强大：它们可以捕捉到局部变量（和参数），并一直保存下来，看起来像这些变量绑定到了再其中定义它们的外部函数。<br>例如，定义一个<code>uniqueInteger</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化函数对象的计数器属性</span></span><br><span class="line"><span class="comment">// 由于函数声明被提前，因此这里可以在函数声明前给它的成员赋值</span></span><br><span class="line">uniqueInteger.counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次调用这个函数都会返回一个不同的整数</span></span><br><span class="line"><span class="comment">// 它使用一个属性来记住下一次将要返回的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueInteger</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> uniqueInteger.counter++; <span class="comment">// 先返回计数器的值，然后计数器自增1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个函数使用自身的一个属性来保存每次返回的值，以便每次调用都能跟从上次的返回值。但这种做法有一个问题，就是恶意代码可能将计数器重置或者把一个非整数赋值给它，导致<code>uniqueInteger()</code>函数不一定能产生”唯一”的“整数”。而闭包可以捕捉到单个函数调用的局部变量，并将这些局部变量用作私有状态。利用闭包重写<code>uniqueInteger()</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uniqueInteger = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 定义函数并立即调用</span></span><br><span class="line">  <span class="keyword">var</span> counter = <span class="number">0</span>;  <span class="comment">// 函数的私有状态</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> counter++; &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;第一行代码看起来像将函数赋值给一个变量<code>uniqueInteger</code>，实际上，这段代码定义了一个立即调用函数（函数的开始带有左圆括号），因此是这个函数的返回值赋值给变量<code>uniqueInteger</code>。这个函数体返回另外一个函数，这是一个嵌套的函数，我们将它赋值给变量<code>uniqueInteger</code>，嵌套的函数是可以访问作用域内的变量的，而且可以访问外部函数中定义的<code>counter</code>变量。当外部函数返回值后，其他任何代码都无法访问<code>counter</code>变量，只有内部的函数才能访问到它。<br>&emsp;&emsp;像<code>counter</code>一样的私有变量不是只能用在一个单独的闭包内，在同一个外部函数内定义的多个嵌套函数也可以访问它，这多个嵌套函数都共享一个作用域链：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> n++; &#125;,</span><br><span class="line">    reset: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; n = <span class="number">0</span>; &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = counter(), d = counter(); <span class="comment">// 创建两个计数器</span></span><br><span class="line">c.count(); <span class="comment">// =&gt; 0</span></span><br><span class="line">d.count(); <span class="comment">// =&gt; 0:他们互不干扰</span></span><br><span class="line">c.reset(); <span class="comment">// reset()和count()方法共享状态</span></span><br><span class="line">c.count(); <span class="comment">// =&gt; 0:因为重置了c</span></span><br><span class="line">d.count(); <span class="comment">// =&gt; 1:没有重置d</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>counter()</code>函数返回了一个“计数器”对象，这个对象包含两个方法：<code>count()</code>返回下一个整数，<code>reset()</code>将计数器重置为内部状态。这两个方法都可以访问私有变量n。再者，每次调用counter()都会创建一个新的作用域链和一个新的私有变量。因此，如果调用<code>counter()</code>量词，则会得到两个计数器对象，而且彼此包含不同的私有变量，调用其中一个计数器对象的<code>count()</code>或<code>reset()</code>不会影响到另外一个对象。<br>&emsp;&emsp;其实可以将这个闭包合并为属性存取器方法<code>getter</code>和<code>setter</code>。如下，利用闭包实现<code>counter()</code>的私有状态：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params">n</span>) </span>&#123; <span class="comment">// 函数参数n是一个私有变量</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 属性getter方法返回并给私有计数器var递增1</span></span><br><span class="line">    <span class="keyword">get</span> count() &#123; <span class="keyword">return</span> n++; &#125;,</span><br><span class="line">    <span class="comment">// 属性setter不允许n递减</span></span><br><span class="line">    <span class="keyword">set</span> count(m) &#123;</span><br><span class="line">      <span class="keyword">if</span> (m&gt;=n) n = m;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"count can only be set to a larger value"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = counter(<span class="number">1000</span>);</span><br><span class="line">c.count   <span class="comment">// =&gt; 1000</span></span><br><span class="line">c.count   <span class="comment">// =&gt; 1000</span></span><br><span class="line">c.count = <span class="number">2000</span></span><br><span class="line">c.count   <span class="comment">// =&gt; 2000</span></span><br><span class="line">c.count = <span class="number">2000</span>  <span class="comment">// =&gt; Error!</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个<code>counter()</code>函数并为声明局部变量，而只是使用参数n来保存私有状态，属性存取器方法可以访问n。这样调用<code>counter()</code>的函数就可以指定私有变量的初始值了。<br>&emsp;&emsp;定义一个<code>addPrivatePropetry()</code>函数，这个函数定义一个私有变量，以及两个嵌套的函数用来获取和设置这个私有变量的值，它将这些嵌套函数添加为所指定对象的方法，利用闭包实现的私有属性存取器方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数给对象o增加了属性存取器方法</span></span><br><span class="line"><span class="comment">// 方法名称为get&lt;name&gt;和set&lt;name&gt;。如果提供了一个判定函数</span></span><br><span class="line"><span class="comment">// setter方法就会用它来检测参数的合法性，然后在存储它</span></span><br><span class="line"><span class="comment">// 如果判定函数返回false，setter方法抛出一个异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数不的getter和setter函数</span></span><br><span class="line"><span class="comment">// 所操作的属性值并没有存储在对象o中</span></span><br><span class="line"><span class="comment">// 相反，这个值仅仅是保存在函数中的局部变量中</span></span><br><span class="line"><span class="comment">// getter和setter方法同样是局部函数，因此可以访问这个局部变量</span></span><br><span class="line"><span class="comment">// 也就是说，对于两个存取器的方法来说这个变量是私有的</span></span><br><span class="line"><span class="comment">// 没有办法绕过存存取器来设置或修改这个值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addPrivatePropetry</span>(<span class="params">o, name, predicate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value; <span class="comment">// 这是一个属性值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// getter方法简单地将其返回</span></span><br><span class="line">  o[<span class="string">"get"</span> + name] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> value; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setter方法首先检查值是否合法，若不合法就抛出异常</span></span><br><span class="line">  <span class="comment">// 否则就将其存储</span></span><br><span class="line">  o[<span class="string">"set"</span> + name] = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (predicate &amp;&amp; !predicate(v)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"set"</span> + name + <span class="string">": invalid value"</span> + v);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      value = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// addPrivatePropetry()方法</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;; <span class="comment">// 设置一个空对象</span></span><br><span class="line"><span class="comment">// 增加属性存取器方法getName()和setName()</span></span><br><span class="line"><span class="comment">// 确保只允许字符串值</span></span><br><span class="line">addPrivatePropetry(o, <span class="string">"Name"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">typeof</span> x == <span class="string">"string"</span>; &#125;);</span><br><span class="line"></span><br><span class="line">o.setName(<span class="string">"Frank"</span>); <span class="comment">// 设置属性值</span></span><br><span class="line"><span class="built_in">console</span>.log(o.getName()); <span class="comment">// 得到属性值</span></span><br><span class="line">o.setName(o); <span class="comment">// 设置一个错误类型的值</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在同一个作用域中定义两个闭包，这两个闭包共享同样的私有变量或变量。这是很重要的一种方式，但要小心那些不希望共享的变量旺旺不经意间共享给了其他的闭包，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数返回一个总是返回v的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constfunc</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> v &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个数组用来存储常数函数</span></span><br><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  funcs[i] = constfunc(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第五个位置的元素所表示的函数值返回5</span></span><br><span class="line">funcs[<span class="number">5</span>]() <span class="comment">// =&gt; 5</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这段代码利用循环创建了很多歌闭包，当写类似这种代码的时候往往会犯一个错误：那就是师徒将循环代码移入定义这个闭包的函数之内，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个函数组成的数组，它们的返回值是0~9</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constfunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> funcs = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> i; &#125;; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> funcs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funcs = constfunc();</span><br><span class="line">funcs[<span class="number">5</span>]() <span class="comment">// ??</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面这段代码创建了10个闭包，并将它们存储到一个数组中。这些闭包都是在同一个函数调用中定义的，因此它们可以共享变量i。当<code>constfunc()</code>返回时，变量i的值是10，所有的闭包都共享这一个值，因此，数组中的函数的返回值都是同一个值，这不是想要的结果。关联到闭包的作用域链都是“活动的”。嵌套的函数不会将作用域链内的私有成员复制一份，也不会对所绑定的变量生成静态快照。<br>&emsp;&emsp;<code>this</code>是JavaScript的关键字，而不是变量。每个函数调用都包含一个<code>this</code>值， 如果闭包在外部函数里是无法访问<code>this</code>的，除非外部函数将<code>this</code>转为一个变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> self = <span class="keyword">this</span>; <span class="comment">// 将this保存至一个变量中，以便嵌套的函数能够访问它</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;绑定<code>arguments</code>的问题与之类似。<code>arguments</code>并不是一个关键字，但是在调用每个函数时都会自动声明它，由于闭包具有自己所绑定的<code>arguments</code>，因此闭包内无法直接访问外部函数的参数数组，除非外部函数将参数数组保存到另外一个变量中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outerArguments = <span class="built_in">arguments</span>; <span class="comment">// 保存起来以便嵌套的函数能使用它</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/01/%E9%97%AD%E5%8C%85/" data-id="ck8gofbcr000whk9h5ifka84c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ECMAScript5中的数组方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/30/ECMAScript5%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/" class="article-date">
  <time datetime="2019-03-30T01:21:08.000Z" itemprop="datePublished">2019-03-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/30/ECMAScript5%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/">JavaScript数组方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&#160; &#160; &#160; &#160;ECMAScript5定义了9个心得数组方法来遍历、映射、过滤、检测、简化和搜索数组。大多数方法的第一个参数接收一个函数，并且对数组的每个元素（或一些元素）调用一次该函数。如果是稀疏数组，对不存在的元素不调用传递的函数。在大多数情况下，调用提供的函数使用三个参数：数组元素、元素的索引和数组本身。通常，只需要第一个参数值，客户忽略后两个参数。大多数ECMAScript5数组方法的第一个参数是一个函数，第二个参数是可以选的。如果有第三个参数，则调用的函数被看做是第二个参数的方法。也就是说，在调用函数时传递进去的第二个参数作为它的this关键字的值来使用。被调用的函数的返回值非常重要，但是不同的方法处理返回值的方式也不一样。ECMAScript5中的数组方法都不会修改他们调用的原是数组。当然，传递给这些方法的函数是可以修改这些数组的。</p>
<h5 id="1-forEach"><a href="#1-forEach" class="headerlink" title="1. forEach()"></a>1. forEach()</h5><p>&#160; &#160; &#160; &#160;<code>forEach()</code>方法从头至尾遍历数组，为每个元素调用指定的函数。传递的函数作为<code>forEach()</code> 的第一个参数。然后<code>forEach()</code>使用三个参数调用该函数：数组元素、元素的索引和元素本身。如果只关心数组元素的值，可以编写只有一个参数的函数——额外的参数将忽略：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; <span class="comment">// 要求和的数组</span></span><br><span class="line"><span class="comment">// 计算数组元素的和值</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>; <span class="comment">// 初始值为0</span></span><br><span class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="comment">// 将每个值累加到sum上</span></span><br><span class="line">  sum += value;</span><br><span class="line">&#125;);</span><br><span class="line">sum;  <span class="comment">// 15</span></span><br><span class="line"><span class="comment">// 每个数组元素的值自加1</span></span><br><span class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v, i, a</span>) </span>&#123;</span><br><span class="line">  a[i] = v + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line">data; <span class="comment">// =&gt; [2,3,4,5,6]</span></span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;<code>forEach()</code> 方法无法再所有元素都传递给调用的函数之前终止遍历。也就是说，没有像for循环中使用的响应的break语句。如果要提前终止，必须把<code>forEach()</code>方法放在一个try块中，并能抛出一个异常。如果<code>forEach()</code> 方法调用的函数抛出<code>forEach.break</code>异常，循环会提前终止：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foreach</span>(<span class="params">a, f, t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    a.forEach(f, t);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e === foreach.break) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foreach.break = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"StopIteration"</span>);</span><br></pre></td></tr></table></figure>

<h5 id="2-map"><a href="#2-map" class="headerlink" title="2. map()"></a>2. map()</h5><p>&#160; &#160; &#160; &#160;<code>map()</code>方法将调用的数组的每个元素传递给指定的函数，并返回一个数组，它包含该函数的返回值。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">b = a.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;); <span class="comment">//b是[1, 4, 9]</span></span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;传递给<code>map()</code>的函数的调用方式和传递给<code>forEach()</code>的函数的调用方式一样。但传递给<code>map()</code>的函数应该有返回值。注意，<code>map()</code>返回的是新数组：它不修改调用的数组。如果是稀疏数组，返回的也是相同方式的稀疏数组：它具有相同的长度，相同的缺失元素。</p>
<h5 id="3-filter"><a href="#3-filter" class="headerlink" title="3. filter()"></a>3. filter()</h5><p>&#160; &#160; &#160; &#160;<code>filter()</code>方法返回的数组元素是调用的数组的一个子集。传递的函数是用来逻辑判定的：该函数返回<code>true</code>或<code>false</code>。调用判定函数就像调用<code>forEach()</code>和<code>map()</code>一样。如果返回值为<code>true</code>或者<code>false</code>，那么传递给判定函数的就是这个子集的成员，它将被添加到一个座位返回值的数组中。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">smallvalue = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &lt; <span class="number">3</span>;</span><br><span class="line">&#125;); <span class="comment">// [2 ,1]</span></span><br><span class="line">everyoher = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;); <span class="comment">// [5, 3, 1]</span></span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;<code>filter()</code>会跳过稀疏数组中缺少的元素，它的返回数组总是稠密的。为了压缩稀疏数组的空缺，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var dense &#x3D; sparse.filter(function () &#123; return true; &#125;);</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;甚至，压缩空缺并删除<code>undefined</code>和<code>null</code>元素，可以这样使用<code>filter()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; a.filter(function (x) &#123; return x !&#x3D; undefined &amp;&amp; x !&#x3D; null; &#125;);</span><br></pre></td></tr></table></figure>

<h5 id="4-every-和some"><a href="#4-every-和some" class="headerlink" title="4. every()和some()"></a>4. every()和some()</h5><p>&#160; &#160; &#160; &#160;<code>every()</code>和<code>some()</code>方法是数组的逻辑判定：它们对数组元素应用指定的函数进行判定，返回<code>true</code>或<code>false</code>。<br><code>every()</code>方法就像数学中的”针对所有”的量词∀：当且仅当数组中的所有元素调用判定函数都返回true，它才返回true：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">a.every(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x &lt; <span class="number">10</span>; &#125;); <span class="comment">// =&gt; true:所有的值&lt;10</span></span><br><span class="line">a.every(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span>; &#125;); <span class="comment">// =&gt; false: 不是所有的值都是偶数</span></span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;<code>some()</code>方法就像数学的”存在”量词∃：当数组中至少有一个元素调用判定函数返回true，它就返回true；并且当且仅当数值中的所有元素调用判定函数都返回false，它才返回false：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">a.some(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x %<span class="number">2</span> === <span class="number">0</span>; &#125;); <span class="comment">// =&gt; true:a包含有偶数</span></span><br><span class="line">a.some(<span class="built_in">isNaN</span>); <span class="comment">// =&gt; false: a不包含非数值元素</span></span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;一旦<code>every()</code>和<code>some()</code>确认该返回什么值他们就会停止遍历数组元素。<code>some()</code>在判定函数第一次返回true后就返回true，但如果判定函数一直返回false，它将会遍历整个数组。<code>every()</code>切好相反：他在判定函数第一次返回false就返回false，但如果判定函数一直返回true，它将会便利整个数组。注意，根据数学上的惯例，在空数组上调用时，<code>every()</code>返回true，<code>some()</code>返回false。</p>
<h5 id="5-reduce-和reduceRight"><a href="#5-reduce-和reduceRight" class="headerlink" title="5. reduce()和reduceRight()"></a>5. reduce()和reduceRight()</h5><p>&#160; &#160; &#160; &#160;<code>reduce()</code>和<code>reduceRight()</code>方法使用指定的函数将数组元素进行组合，生成单个值。这在函数式编程中是常见的操作们也可以称为”注入”和”折叠”：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = a.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>) </span>&#123; <span class="keyword">return</span> x+y &#125;, <span class="number">0</span>); <span class="comment">// =&gt; 数组求和</span></span><br><span class="line"><span class="keyword">var</span> product = a.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>) </span>&#123; <span class="keyword">return</span> x*y &#125;, <span class="number">1</span>); <span class="comment">// =&gt; 数组求积</span></span><br><span class="line"><span class="keyword">var</span> max = a.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>) </span>&#123; <span class="keyword">return</span> (x&gt;y)?x:y; &#125;); <span class="comment">// =&gt; 求最大值</span></span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;<code>reduce()</code>需要两个参数。第一个是执行化简操作的函数。化简函数的任务就是用某种方法把两个值组合或花间为一个值，并返回化简后的值。在上述例子中，函数通过加法、乘法或取最大值的方法组合两个值。第二个（可选）的参数是一个传递给函数的初始值。<br>&#160; &#160; &#160; &#160;<code>reduce()</code>使用的函数与<code>forEach()</code>和<code>map()</code>使用的函数不同。比较熟悉的是，数组元素、元素的索引和数组本身将作为第2~4个参数传递给函数。第一个参数是到目前为止的化简操作累积的结果。第一次调用函数式，第一个参数是一个初始值，它就是传递给<code>reduce()</code>的第二个参数。在接下来的调用中，这个值就是上一次化简函数的返回值。在示例的第一个例子中，第一次调用化简函数时的参数是0和1。将两者相加并返回1。再次调用时的参数是1和2，它返回3。然后它计算3+3=6、6+4=10，最后计算10+5=15。最后的值是15，<code>reduce()</code>返回这个值。<br>&#160; &#160; &#160; &#160;上面第三次调用<code>reduce()</code>时只有一个参数：没有指定初始值。当不指定初始值调用<code>reduce()</code>时，它将使用数组的第一个元素作为其初始值。这意味着第一次调用化简函数就使用了第一个和第二个数组元素作为其第一个和第二个参数。在上面求和和求积的例子里面，可以省略初始值参数。<br>在空数组上，不带初始值参数调用<code>reduce()</code>将导致类型错误异常。如果调用它的时候只有一个值——数组只有一个元素并且没有指定初始值，或者有一个空数组并指定一个初始值——<code>reduce()</code>只是简单地返回那个值而不会调用化简函数。<br>&#160; &#160; &#160; &#160;<code>reduceRight()</code>的工作原理和<code>reduce()</code>一样，不用的是它按照数组索引从高倒地（从右到左）处理数组，而不是从低到高。如果化简操作的优先顺序是从右到左，我们可以把它用在这些地方：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 计算2^(3^4)。乘方操作的优先顺序是从右到左</span></span><br><span class="line"><span class="keyword">var</span> big = a.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">accmulator, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.pow(value, accmulator);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;<code>reduce()</code>和<code>reduceRight()</code>都能接收一个可选参数，它指定了化简函数调用时的<code>this关键字</code>的值。可选的初始值参数仍然需要占一个位置。如果想让化简函数作为一个特殊对象的方法调用，可以想到<code>Function.bind()</code>方法.<br>&#160; &#160; &#160; &#160;上面说的<code>every()</code>和<code>some()</code>方法是一种类型的数组化操作。但是不同的是，它们会尽早终止遍历而不总是访问每一个数组元素。<br>&#160; &#160; &#160; &#160;数学计算不是<code>reduce()</code>和<code>reduceRight()</code>的唯一用途。比如，我们可以用它写一个<code>union()</code>函数：它计算两个对象的”并集”，并返回另一个新对象，新对象具有二者的属性。该函数期待两个对象并返回另一个对象，所以它的工作原理和一个化简函数一样，并且可以使用<code>reduce()</code>来把它一般化，计算任意数目的对象的”并集”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objects = [&#123; <span class="attr">x</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">y</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">z</span>: <span class="number">3</span> &#125;];</span><br><span class="line"><span class="keyword">var</span> merged = objects.reduce(union); <span class="comment">// =&gt; &#123;x:1,y:2,z:3&#125;</span></span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;当两个对象拥有同名的属性时，<code>union()</code>函数使用第一个参数的属性值。这样，<code>reduce()</code>和<code>reduceRight()</code>在使用<code>union()</code>时会给出不同的结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objects = [&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">z</span>: <span class="number">3</span>, <span class="attr">a</span>: <span class="number">3</span> &#125;];</span><br><span class="line"><span class="keyword">var</span> leftunion = objects.reduce(union); <span class="comment">// =&gt; &#123;x:1, y:2, z:3, a:1&#125;</span></span><br><span class="line"><span class="keyword">var</span> rightunion = objects.reduceRight(union); <span class="comment">// =&gt; &#123;x:1, y:2, z:3, a:3&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="6-indexOf-和lastIndexOf"><a href="#6-indexOf-和lastIndexOf" class="headerlink" title="6.indexOf()和lastIndexOf()"></a>6.indexOf()和lastIndexOf()</h5><p>&#160; &#160; &#160; &#160;<code>indexOf()</code>和<code>lastIndexOf()</code>搜索整个数组中具有给定值的元素，返回找到的第一个元素的索引或者如果没有找到就返回-1。<code>indexOf()</code>从头至尾搜索，而<code>lastIndexOf()</code>则反向搜索。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">0</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>];</span><br><span class="line">a.indexOf(<span class="number">1</span>); <span class="comment">// =&gt; 1:a[1]是1</span></span><br><span class="line">a.lastIndexOf(<span class="number">1</span>); <span class="comment">// =&gt; 3:a[3]是1</span></span><br><span class="line">a.indexOf(<span class="number">3</span>); <span class="comment">// =&gt; -1:没有值为3的元素</span></span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;不同于其他方法，<code>indexOf()</code>和<code>lastIndexOf()</code>方法不接受一个函数作为其参数。第一个参数是需要搜索的值，第二个参数是可选的：它指定数组中的一个索引，从那里开始搜索，如果省略该参数，<code>indexOf()</code>从头开始搜索，而<code>lastIndexOf()</code>从末尾开始搜索。第二个参数也可以是负数，它代表对数组末尾的偏移量，对于<code>splice()</code>方法：例如，-1指定数组的最后一个元素。<br>如下函数在一个数组中搜索指定的值并返回包含所有匹配的数组索引的一个数组。它展示了如何运用<code>indexOf()</code>的第二个参数来查找除了第一个意外匹配的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在数组中查找所有出现的x，并返回一个包含匹配索引的数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findall</span>(<span class="params">a, x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> results = [], <span class="comment">// 将会返回的数组</span></span><br><span class="line">    len = a.length, <span class="comment">// 待搜索数组的长度</span></span><br><span class="line">    pos = <span class="number">0</span>; <span class="comment">// 开始搜索的位置</span></span><br><span class="line">  <span class="keyword">while</span> (pos &lt; len) &#123;</span><br><span class="line">    <span class="comment">// 循环搜索多个元素...</span></span><br><span class="line">    pos = a.indexOf(x, pos); <span class="comment">// 搜索</span></span><br><span class="line">    <span class="keyword">if</span> (pos === <span class="number">-1</span>) &#123; <span class="comment">// 未找到，就完成搜索</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    results.push(pos); <span class="comment">// 否则，在数组中存储索引</span></span><br><span class="line">    pos = pos + <span class="number">1</span>; <span class="comment">// 并从下一个位置开始搜索</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results; <span class="comment">// 返回包含索引的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;字符串也有<code>indexOf()</code>和<code>lastIndexOf()</code>方法，它们和数组方法的功能类似。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/30/ECMAScript5%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/" data-id="ck8gofbc30004hk9h5vn50f93" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript数组方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/23/JavaScript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/" class="article-date">
  <time datetime="2019-03-23T01:21:08.000Z" itemprop="datePublished">2019-03-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/23/JavaScript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/">JavaScript数组方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><p>&#160; &#160; &#160; &#160;ECMAScript在Array.prototype中定义了一些很有用的操作数组的函数，这意味着这些函数作为任何数组的方法都是可用的。</p>
<h5 id="1-join"><a href="#1-join" class="headerlink" title="1. join()"></a>1. join()</h5><p><code>Array.join()</code>方法将数组中所有元素都专户为字符串并连接在一起，返回最后生成的字符串。可以指定一个可选的字符串在生在的字符串中来分隔数组的各个元素。如果不指定分隔符，默认使用逗号。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1, 2, 3];     &#x2F;&#x2F; 创建一个包含三个元素的数组</span><br><span class="line">a.join();              &#x2F;&#x2F; &#x3D;&gt; &quot;1,2,3&quot;</span><br><span class="line">a.join(&quot; &quot;);           &#x2F;&#x2F; &#x3D;&gt; &quot;1 2 3&quot;</span><br><span class="line">a.join(&quot;&quot;);            &#x2F;&#x2F; &#x3D;&gt; &quot;123&quot;</span><br></pre></td></tr></table></figure>
<p><code>Array.join()</code> 方法是String.split()方法的逆向操作，后者是将字符串分割成若干块来创建一个数组。</p>
<h5 id="2-reverse"><a href="#2-reverse" class="headerlink" title="2. reverse()"></a>2. reverse()</h5><p><code>Array.reverse()</code>方法将数组中的元素颠倒顺序，返回逆向的数组。它采取了替换；换句话说，它不通过重新排列的元素创建新的数组，而是在原先的数组中重新排列他们。例如，下面的代码使用<code>reverse()</code>和<code>join()</code>方法生成字符串“3，2，1”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1,2,3];</span><br><span class="line">a.reverse().join();   &#x2F;&#x2F; &#x3D;&gt; &quot;3,2,1&quot;,并且现在的a是[3,2,1]</span><br></pre></td></tr></table></figure>

<h5 id="3-sort"><a href="#3-sort" class="headerlink" title="3. sort()"></a>3. sort()</h5><p><code>Array.sort()</code>方法将数组中的元素排序并返回排序后的数组。当不带参数调用<code>sort()</code>时，数组元素以字母表顺序排列（如有必要将临时转化为字符串进行比较）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; new Array(&quot;banana&quot;, &quot;cherry&quot;, &quot;apple&quot;);</span><br><span class="line">a.sort();</span><br><span class="line">var s &#x3D; a.join(&quot;， ”)；  &#x2F;&#x2F;  s &#x3D; &quot;apple, banana, cherry&quot;</span><br></pre></td></tr></table></figure>
<p>如果参数包含undefined元素，它们会被排到数组的尾部。<br>为了按照其他方式而非字母表顺序进行排序，必须给<code>sort()</code>方法传递一个比较函数。该函数决定了它的两个参数在排好序的数组中的先后顺序。假设第一个参数应该在前，比较函数应该返回一个小鱼0的数值。反之，假设第一个参数应该在后，函数应该返回一个大于0的数值。并且，假设两个值相等（也就是说，他们的顺序无关紧要），函数应该返回0。因此，例如，用数值大小而非字母表顺序进行数组排序，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [33, 4, 1111, 222];</span><br><span class="line">a.sort();                &#x2F;&#x2F; 字母表顺序: 1111, 222, 33, 4</span><br><span class="line">a.sort(function (a, b) &#123; &#x2F;&#x2F; 数值顺序: 4, 33, 222, 1111</span><br><span class="line">  return a - b;          &#x2F;&#x2F; 根据顺序，返回负数、0、正数</span><br><span class="line">&#125;)</span><br><span class="line">a.sort(function (a, b) &#123; &#x2F;&#x2F; 数值大小相反顺序</span><br><span class="line">  return b - a;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>另外一个数组元素排序的例子，也许需要对一个字符串数组执行不区分大小写的字母表排序，比较函数首先将参数都转化为小写字符串（使用<code>toLowerCase()</code>方法），再开始比较：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; [&#39;ant&#39;, &#39;Bug&#39;, &#39;cat&#39;, &#39;Dog&#39;]</span><br><span class="line">a.sort();                &#x2F;&#x2F; 区分大小写的排序: [&#39;Bug&#39;,&#39;Dog&#39;,&#39;ant&#39;,&#39;cat&#39;]</span><br><span class="line">a.sort(function (s, t) &#123; &#x2F;&#x2F; 不区分大小写的排序</span><br><span class="line">  var a &#x3D; s.toLowerCase();</span><br><span class="line">  var b &#x3D; t.toLowerCase();</span><br><span class="line">  if (a &lt; b) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  if (a &gt; b) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;);                     &#x2F;&#x2F; &#x3D;&gt; [&#39;ant&#39;,&#39;Bug&#39;,&#39;cat&#39;,&#39;Dog&#39;]</span><br></pre></td></tr></table></figure>

<h5 id="4-concat"><a href="#4-concat" class="headerlink" title="4. concat()"></a>4. concat()</h5><p><code>Array.concat()</code>方法创建并返回一个新数组，它的元素包括调用<code>concat()</code>的元时数组的元素和<code>concat()</code>的每个参数。如果这些参数中的任何一个自身是数组，则连接的是数组的元素，而非数组本身。但要注意，<code>concat()</code>不会递归扁平化数组的数组。<code>concat()</code>也不会修改调用的数组。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1, 2, 3];</span><br><span class="line">a.concat(4, 5);        &#x2F;&#x2F; 返回[1, 2, 3, 4, 5]</span><br><span class="line">a.concat([4, 5]);       &#x2F;&#x2F; 返回[1, 2, 3, 4, 5]</span><br><span class="line">a.concat([4, 5], [6, 7]); &#x2F;&#x2F; 返回[1, 2, 3, 4, 5, 6, 7]</span><br><span class="line">a.concat(4, [5, [6, 7]]); &#x2F;&#x2F; 返回[1, 2, 3, 4, 5, [6, 7]]</span><br></pre></td></tr></table></figure>

<h5 id="5-slice"><a href="#5-slice" class="headerlink" title="5. slice()"></a>5. slice()</h5><p><code>Array.slice()</code>方法返回指定数组的一个片段或子数组。它的两个参数分别指定了片段的开始和结束的位置。返回的数组包含第一个参数指定的位置和所有到但不包含第二参数指定的位置的所有数组元素。如果只指定一个参数，返回的数组将包含从开始位置到数组结尾的所有元素。如果参数中出现了负数，它表示相对数组中最后一个元素的位置。例如，参数-1指定了最后一个元素，而-3指定了倒数第三个元素。但是<code>slice()</code>不会修改调用的数组。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">a.slice(0, 3);   &#x2F;&#x2F; 返回[1, 2, 3]</span><br><span class="line">a.slice(3);      &#x2F;&#x2F; 返回[4, 5]</span><br><span class="line">a.slice(1, -1);  &#x2F;&#x2F; 返回[2, 3, 4]</span><br><span class="line">a.slice(-3, -2); &#x2F;&#x2F; 返回[3]</span><br></pre></td></tr></table></figure>

<h5 id="6-splice"><a href="#6-splice" class="headerlink" title="6.splice()"></a>6.splice()</h5><p><code>Array.splice()</code>方法是在数组中插入或删除元素的通用方法。不同于<code>slice()</code>和<code>concat()</code>，<code>splice()</code>会修改调用的数组。但是，<code>splice()</code>和<code>slice()</code>拥有非常相似的名字，但它们的功能却有本质的区别。<br><code>splice()</code>能够从数组中删除元素、插入元素到数组中或者同时完成这两种操作。在插入或删除点之后的数组元素会根据需要增加或减小它们的索引值，因此数组的其他部分仍然保持连续的。<code>splice()</code>的第一个参数指定了插入和（或）删除的起始位置。第二个参数指定了应该从数组中删除的元素个数。如果省略第二个参数，从起始点开始到数组结尾的所有元素都将被删除。<code>splice()</code>返回一个由删除元素组成的数组，或者如果没有删除元素就返回一个空数组。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1, 2, 3, 4, 5, 6, 7, 8];</span><br><span class="line">a.splice(4);    &#x2F;&#x2F; 返回[5, 6, 7, 8];a是[1,2,3,4]</span><br><span class="line">a.splice(1, 2); &#x2F;&#x2F; 返回[2, 3];a是[1,4]</span><br><span class="line">a.splice(1, 1); &#x2F;&#x2F; 返回[4];a是[1]</span><br></pre></td></tr></table></figure>
<p><code>splice()</code>的前两个参数指定了需要删除的数组元素。紧随其后的任意个数的参数指定了需要插入到数组中的元素，从第一个参数指定的位置开始插入。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">a.splice(2, 0, &#39;a&#39;, &#39;b&#39;);  &#x2F;&#x2F; 返回[],a是[1, 2, &quot;a&quot;, &quot;b&quot;, 3, 4, 5]</span><br><span class="line">a.splice(2, 2, [1, 2], 3); &#x2F;&#x2F; 返回[&quot;a&quot;, &quot;b&quot;],a是[1, 2, [1, 2], 3, 3, 4, 5]</span><br></pre></td></tr></table></figure>
<p>区别于<code>concat()</code>，<code>splice()</code>会插入数组本身而非数组的元素。</p>
<h5 id="7-push-和pop"><a href="#7-push-和pop" class="headerlink" title="7. push()和pop()"></a>7. push()和pop()</h5><p><code>push()</code>和<code>pop()</code>方法允许将数组当做栈来调用。<code>push()</code> 方法在数组的尾部添加一个或多个元素，并返回数组新的长度。<code>pop()</code> 方法则相反：它删除数组的最后一个元素，减小数组长度并返回它删除的值。两个方法都修改并替换原始数组而非生成一个修改版的新数组。组合使用<code>push()</code> 和<code>pop()</code> 能够用JavaScript数组实现现金后出的栈。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var stack &#x3D; [];     &#x2F;&#x2F; stack: []</span><br><span class="line">stack.push(1, 2);   &#x2F;&#x2F; stack: [1, 2]</span><br><span class="line">stack.pop();        &#x2F;&#x2F; stack: [1]</span><br><span class="line">stack.push(3);      &#x2F;&#x2F; stack: [1, 3]</span><br><span class="line">stack.pop();        &#x2F;&#x2F; stack: [1]</span><br><span class="line">stack.push([4, 5]); &#x2F;&#x2F; stack: [1, [4, 5]]</span><br><span class="line">stack.pop();        &#x2F;&#x2F; stack: [1]</span><br><span class="line">stack.pop();        &#x2F;&#x2F; stack: []</span><br></pre></td></tr></table></figure>

<h5 id="8-unshift-和shift"><a href="#8-unshift-和shift" class="headerlink" title="8. unshift()和shift()"></a>8. unshift()和shift()</h5><p><code>unshift()</code>和<code>shift()</code>方法的行为非常类似于<code>push()</code> 和<code>pop()</code>，不一样的是前者是在数组的头部而非尾部进行元素的插入和删除操作。 <code>unshift()</code> 在数组的头部添加一个或多个元素，并将已存在的元素移动到更高索引的位置来获得足够的空间，最后返回数组新的长度。<code>shift()</code>删除数组的第一个元素并将其返回，然后把所有随后的元素下移一个位置来填补数组头部的空缺。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [];            &#x2F;&#x2F; a:[]</span><br><span class="line">a.unshift(1);          &#x2F;&#x2F; a:[1] 返回:1</span><br><span class="line">a.unshift(22);         &#x2F;&#x2F; a:[22, 1] 返回:2</span><br><span class="line">a.shift();             &#x2F;&#x2F; a:[1] 返回:22</span><br><span class="line">a.unshift(3, [4, 5]);  &#x2F;&#x2F; a:[3, [4, 5], 1] 返回:3</span><br><span class="line">a.shift();             &#x2F;&#x2F; a:[[4, 5], 1] 返回:3</span><br><span class="line">a.shift();             &#x2F;&#x2F; a:[1] 返回:[4, 5]</span><br><span class="line">a.shift();             &#x2F;&#x2F; a:[] 返回:1</span><br></pre></td></tr></table></figure>
<p>当使用多个参数调用 <code>unshift()</code>时它的行为很奇怪。参数是一次性插入的（就像<code>splice()</code>方法）而非一次一个地插入。这意味着最终的数组中插入的元素的顺序和它们在参数列表中的顺序一致。而假如元素是一次一个地插入，它们的顺序应该是反过来的。</p>
<h5 id="8-toString-和toLocaleString"><a href="#8-toString-和toLocaleString" class="headerlink" title="8. toString()和toLocaleString()"></a>8. toString()和toLocaleString()</h5><p>数组和其他JavaScript对象一样拥有<code>toString()</code>方法。针对数组，该方法将其每个元素转化为字符串（如有必要将调用元素的<code>toString()</code>方法）并且输出用逗号分隔的字符串列表。但是要注意输出不包括方括号或其他任何形式的包裹数组值的分隔符。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].toString();       &#x2F;&#x2F; 生成&quot;1,2,3&quot;</span><br><span class="line">[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].toString(); &#x2F;&#x2F; 生成&quot;a,b,c&quot;</span><br><span class="line">[1, [2, &#39;c&#39;]].toString();   &#x2F;&#x2F; 生成&quot;1,2,c&quot;</span><br></pre></td></tr></table></figure>
<p>这里于不适用任何参调用<code>join()</code>方法返回的字符串是一样的。<br><code>toLocaleString()</code>是<code>toString()</code>方法的本地化版本。它调用元素的<code>toLocaleString()</code>方法将每个数组元素转化为字符串，并且使用本地化（和自定义实现的）分隔符将这些字符串连接起来生成最终的字符串。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/23/JavaScript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/" data-id="ck8gofbcd0007hk9hdt6f25w5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS中的严格模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/18/JS%E4%B8%AD%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2019-03-18T06:21:08.000Z" itemprop="datePublished">2019-03-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/18/JS%E4%B8%AD%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/">JS中的严格模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="“use-strict”"><a href="#“use-strict”" class="headerlink" title="“use strict”"></a>“use strict”</h2><p>&#160; &#160; &#160; &#160;<code>&quot;use strict&quot;</code>是<code>ECMAScript</code>引入的一条指令。指令不是语句（但非常接近于语句）。</p>
<h5 id="1-与普通语句的区别"><a href="#1-与普通语句的区别" class="headerlink" title="1. 与普通语句的区别"></a>1. 与普通语句的区别</h5><p>&#160; &#160; &#160; &#160;<code>&quot;use strict&quot;</code>指令和普通的语句之间有两个重要的<code>区别</code>：</p>
<ul>
<li>它不包含任何语言的<code>关键字</code>，指令仅仅是一个包含一个特殊字符串直接量的表达式（可以是使用单引号也可以使用双引号），对于那些没有实现<code>ECMAScript5</code>的JavaScript的解释器来说，它只是一条没有副作用的表达式语句，它什么也没做。将来的ECMAScript标准希望将use用做关键字，这样就可以省略引号了。</li>
<li>它只能出现在脚本代码的开始或者函数体的开始，任何实体语句之前。但它不必一定出现在脚本的首行或函数体内的首行，因为<code>&quot;use strict&quot;</code>指令之后或之前都可以能有其它字符串直接量表达式语句，并且JavaScript的具体实现可能将它们解析为解释器自有的指令。在脚本或者函数体内第一条常规语句之后字符串直接量表达式语句只当做普通的表达式语句对待；它们不会当做指令解析，它们也没有任何副作用。</li>
</ul>
<h5 id="2-指令的目的"><a href="#2-指令的目的" class="headerlink" title="2. 指令的目的"></a>2. 指令的目的</h5><p>&#160; &#160; &#160; &#160;使用<code>&quot;use strict&quot;</code>指令的目的是说明（脚本或函数中）后续的代码将会解析为严格代码<code>(strict code)</code>.如果顶层（不在任何函数内的）代码使用了<code>&quot;use strict&quot;</code>指令，那么它们就是严格代码。如果函数体内定义所处的代码是严格代码或者函数体使用了<code>&quot;use strict&quot;</code>指令，那么函数体的代码也是严格代码。如果<code>eval()</code>调用时所处的代码是严格代码或者<code>eval()</code>要执行的字符串中使用了<code>&quot;use strict&quot;</code>指令，则<code>eval()</code>内的代码是严格代码。</p>
<h5 id="3-与非严格模式的区别"><a href="#3-与非严格模式的区别" class="headerlink" title="3. 与非严格模式的区别"></a>3. 与非严格模式的区别</h5><p>&#160; &#160; &#160; &#160;严格代码以严格模式执行。<code>ECMAScript5</code>中的严格模式是该语言的一个受限制的子集，它修正了语言的重要缺陷，并提供健壮的查错功能和增强的安全机制。严格模式和非严格模式之间的区别如下（前三条十分重要）。</p>
<ul>
<li>在严格模式中禁止使用<code>with</code>语句。</li>
<li>在严格模式中，<code>所有的变量</code>都要首先声明，如果给一个未声明的变量、函数、函数参数、catch从句参数或全局对象的属性赋值，将会抛出一个引用错误异常（在非严格模式中，这种隐式声明的全局变量的方法是给全局对象新添加一个新属性）。</li>
<li>在严格模式中，调用的函数（不是方法）中的一个<code>this</code>值是<code>undefined</code>。（在非严格模式中，调用的函数中的this值总是全局对象）。可以利用这种特殊来判断JavaScript实现是否支持严格模式。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var hasStrictMode &#x3D; (function()&#123; &quot;use strict&quot;; return this&#x3D;&#x3D;&#x3D;undefined&#125;());</span><br></pre></td></tr></table></figure></li>
<li>同样，在严格模式中，当通过<code>call()</code>或者<code>apply()</code>来调用函数时，其中的this值就是通过<code>call()</code>或者<code>apply()</code>传入的第一个参数（在非严格模式中，null和undefined值被全局对象和转换为对象的非对象值所代替）。</li>
<li>在严格模式中，给只读属性赋值和给不可扩展的对象穿件新成员都将抛出一个类型错误异常（在非严格模式中，这些操作知识简单地操作失败，不会报错）。</li>
<li>在严格模式中，传入<code>eval()</code>的代码不能再调用程序所在的上下文中声明变量或定义函数，而在费严格模式中是可以这样做得。相反，变量和函数的定义都是在<code>eval()</code>创建的新作用域中，这个作用域在<code>eval()</code>返回时就弃用了。</li>
<li>在严格模式中，函数里的<code>arguments</code>对象拥有传入函数值的静态副本。在非严格模式中，<code>arguments</code>对象具有<code>“魔术般”</code>的行为，<code>arguments</code>里的数组元素和函数参数都是指向同一个值的引用。</li>
<li>在严格模式中，当<code>delete</code>运算符后跟随非法的标识符（比如变量、函数、函数参数）时，将会抛出一个语法错误异常（在非严格模式中，这种<code>delete</code>表达式什么也没做，并返回false）。</li>
<li>在严格模式中，试图删除一个不可配置的属性将会抛出一个类型错误异常（在非严格模式中，<code>delete</code>表达式操作失败，并返回false）。</li>
<li>在严格模式中，在一个对象直接量中定义两个或多个同名属性将产生一个语法错误（在非严格模式中不会报错）。</li>
<li>在严格模式中，函数声明中个存在两个或多个同名的参数将产生一个语法错误（在非严格模式中不会报错）。</li>
<li>在严格模式中是不允许使用八进制整数直接量（以0为前缀，而不是以0x为前缀）的（在非严格模式中某些实现是允许八进制整数直接量的）。</li>
<li>在严格模式中，标识符<code>eval</code>和<code>arguments</code>当做关键字，他们的值是不能更改的。不能给这些标识符赋值，也不能把它们声明为变量、用做函数名、用做函数参数或用做<code>catch</code>块的标识符。</li>
<li>在严格模式中限制了对调用栈的检测能力，在严格模式的函数中，<code>arguments</code>、<code>caller</code>和<code>argument.callee</code>都会抛出一个类型错误异常。严格模式的函数同样据用<code>caller</code>和<code>arguments</code>属性，当访问这两个属性时将抛出类型错误异常（有一些JavaScript的实现在非严格模式里定义了这些非标准的属性）。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/18/JS%E4%B8%AD%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/" data-id="ck8gofbcg000bhk9he82ahob5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Gulp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/06/Gulp/" class="article-date">
  <time datetime="2018-09-06T12:39:08.000Z" itemprop="datePublished">2018-09-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/gulp/">gulp</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/06/Gulp/">gulp</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="gulp-转码项目中的ES6-ES5并压缩js"><a href="#gulp-转码项目中的ES6-ES5并压缩js" class="headerlink" title="gulp-转码项目中的ES6-ES5并压缩js"></a>gulp-转码项目中的ES6-ES5并压缩js</h4><p>在这之前，请确保你的 <code>node</code> 和 <code>npm</code> 已经安装无误，可以用<code>node -v</code> 和 <code>npm -v</code>查看 <code>node</code> 和 <code>npm</code> 的版本。</p>
<p>好了，接下来，gulp-babel，转码压缩，七步到位，走你！</p>
<h5 id="1-全局安装-gulp"><a href="#1-全局安装-gulp" class="headerlink" title="1. 全局安装 gulp"></a>1. 全局安装 gulp</h5><p>终端执行 <code>cnpm install gulp -g</code>。(这里默认大家已经安装了<a href="http://npm.taobao.org/" target="_blank" rel="noopener">淘宝镜像</a>，没有安装也可以使用 <code>npm</code>)。</p>
<p>安装完毕后可以使用 <code>gulp -v</code>检测版本。</p>
<h5 id="2-在项目中安装-babel"><a href="#2-在项目中安装-babel" class="headerlink" title="2. 在项目中安装 babel"></a>2. 在项目中安装 babel</h5><p>在项目根目录执行 <code>cnpm install babel-cli</code>，等待安装好项目所依赖的<code>babel</code>。</p>
<p>安装完毕后可以使用 <code>.\node_modules\.bin\babel --version</code> 检测版本。这时候你可以在你的项目中看到一个node_modules文件夹。</p>
<h5 id="3-在项目中安装-gulp"><a href="#3-在项目中安装-gulp" class="headerlink" title="3. 在项目中安装 gulp"></a>3. 在项目中安装 gulp</h5><p>在项目根目录执行 <code>cnpm install gulp</code>，安装项目中的 <code>gulp</code>。</p>
<h5 id="4-在项目中安装-gulp-babel"><a href="#4-在项目中安装-gulp-babel" class="headerlink" title="4. 在项目中安装 gulp-babel"></a>4. 在项目中安装 gulp-babel</h5><p>在项目根目录执行 <code>cnpm install --save-dev gulp-babel babel-preset-env</code>。</p>
<p>安装完毕后，你可以看到你的项目出现了 <code>package.json</code>(如果你没有预先 <code>npm init</code> 或者安装依赖的话一般是不会出现这个文件的)，你可以检测文件里会出现了以下依赖：</p>
<pre><code>{
  &quot;devDependencies&quot;: {
    &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;,
    &quot;gulp-babel&quot;: &quot;^7.0.0&quot;
  }
}</code></pre><h5 id="5-在项目中安装-gulp-uglify"><a href="#5-在项目中安装-gulp-uglify" class="headerlink" title="5. 在项目中安装 gulp-uglify"></a>5. 在项目中安装 gulp-uglify</h5><p>在项目根目录执行 <code>cnpm install gulp-uglify --save-dev</code>, 于是 <code>package.json</code> 变成了这样：</p>
<pre><code>{
  &quot;devDependencies&quot;: {
    &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;,
    &quot;gulp-babel&quot;: &quot;^7.0.0&quot;,
    &quot;gulp-uglify&quot;: &quot;^3.0.0&quot;
  }
}</code></pre><h5 id="6-根目录创建-gulpfile-js"><a href="#6-根目录创建-gulpfile-js" class="headerlink" title="6.根目录创建 gulpfile.js"></a>6.根目录创建 gulpfile.js</h5><p>在项目根目录创建 <code>gulpfile.js</code>，里面的代码是这样的：</p>
<pre><code>const gulp = require(&apos;gulp&apos;); // 引入gulp
const babel = require(&apos;gulp-babel&apos;); // 引入gulp-babel
const uglify = require(&apos;gulp-uglify&apos;); // 引入gulp-uglify

// ES6代码转码为ES5
gulp.task(&apos;toes5&apos;, () =&gt;
    gulp.src(&apos;src/*.js&apos;) // 需要转码的es6文件，这里代表src文件夹下的所有js文件
        /*
        最新的presets: [&apos;env&apos;]，是通用版，可以转码es2015、react、es2017, 
        这里只用于转码es2015，你可以下载相关转码依赖
        */
        .pipe(babel({
            presets: [&apos;env&apos;]
        }))
        .pipe(gulp.dest(&apos;dist&apos;)) // 转码后的文件输出位置
);

// JS代码压缩
gulp.task(&apos;jsmin&apos;, () =&gt;
    gulp.src(&apos;dist/*.js&apos;) // 需要压缩的js文件
        .pipe(uglify())
        .pipe(gulp.dest(&apos;min&apos;)) // 压缩的js文件输出位置
);

// 使用监听，但是需要预先使用命令 gulp auto，文件如果修改了，就一步到位
gulp.task(&apos;auto&apos;, () =&gt; {
gulp.watch(&apos;src/*.js&apos;, [&apos;toes5&apos;]) // 需要转码的js文件位置 + 口令
gulp.watch(&apos;dist/*.js&apos;, [&apos;jsmin&apos;]) // 需要压缩的js文件位置 + 口令</code></pre><p>});</p>
<h5 id="7-流水线的骚操作"><a href="#7-流水线的骚操作" class="headerlink" title="7. 流水线的骚操作"></a>7. 流水线的骚操作</h5><p>在项目根目录终端运行 <code>gulp toes5</code>，就将 <code>es6</code> 文件转为 <code>es5</code> 文件了。运行 <code>gulp jsmin</code>，就将 <code>js</code> 文件稳稳当当地压缩了。</p>
<p>如果我们需要一步到位，而且不用随时去执行这繁琐的命令，我们还可以使用监听。在项目根目录终端使用 <code>gulp auto</code>，然后每次修改开发文件( <code>src</code> 下的 <code>js</code> )，就会自动同步转码和压缩。【==监听还可以监听更多的 gulp task，这点非常重要==】</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h5 id="8-gulp-htmlmin-压缩html"><a href="#8-gulp-htmlmin-压缩html" class="headerlink" title="8. gulp-htmlmin 压缩html"></a>8. gulp-htmlmin 压缩html</h5><p><code>cnpm install gulp-htmlmin --save-dev</code></p>
<pre><code>const htmlmin = require(&apos;gulp-htmlmin&apos;);

// 压缩html和html页面内的css/js
gulp.task(&apos;htmlmin&apos;, function () {
    var options = {
        removeComments: true,//清除HTML注释
        collapseWhitespace: true,//压缩HTML
        collapseBooleanAttributes: true,//省略布尔属性的值 &lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input /&gt;
        removeEmptyAttributes: true,//删除所有空格作属性值 &lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt;
        removeScriptTypeAttributes: true,//删除&lt;script&gt;的type=&quot;text/javascript&quot;
        removeStyleLinkTypeAttributes: true,//删除&lt;style&gt;和&lt;link&gt;的type=&quot;text/css&quot;
        minifyJS: true,//压缩页面JS
        minifyCSS: true//压缩页面CSS
    };
    gulp.src(&apos;src/*.html&apos;)
        .pipe(htmlmin(options))
        .pipe(gulp.dest(&apos;min&apos;));
});</code></pre><h5 id="9-gulp-clean-css-压缩css"><a href="#9-gulp-clean-css-压缩css" class="headerlink" title="9. gulp-clean-css 压缩css"></a>9. gulp-clean-css 压缩css</h5><p><code>cnpm install gulp-clean-css --save-dev</code></p>
<pre><code>const cleanCSS = require(&apos;gulp-clean-css&apos;);

// 压缩css文件, 如果有外部引用，为了保持项目结构，需要使用插件 gulp-sourcemaps
gulp.task(&apos;cssmin&apos;, () =&gt; {
    gulp.src(&apos;src/*.css&apos;)
        .pipe(cleanCSS({compatibility: &apos;ie8&apos;})) // 兼容IE8及以下浏览器
        .pipe(gulp.dest(&apos;min&apos;));
});</code></pre><h5 id="10-gulp-concat-合并-js-文件"><a href="#10-gulp-concat-合并-js-文件" class="headerlink" title="10. gulp-concat 合并 js 文件"></a>10. gulp-concat 合并 js 文件</h5><p><code>cnpm install gulp-concat --save-dev</code></p>
<pre><code>const concat = require(&apos;gulp-concat&apos;);

// 合并 js 文件, 但不会转码和压缩
gulp.task(&apos;jsconcat&apos;, function () {
    gulp.src(&apos;src/*.js&apos;)
        .pipe(concat(&apos;index.js&apos;))//合并后的文件名
        .pipe(gulp.dest(&apos;dist&apos;));
});</code></pre><h5 id="11-gulp-less-将less文件编译成css"><a href="#11-gulp-less-将less文件编译成css" class="headerlink" title="11. gulp-less 将less文件编译成css"></a>11. gulp-less 将less文件编译成css</h5><p><code>cnpm install gulp-less --save-dev</code></p>
<pre><code>const less = require(&apos;gulp-less&apos;);

// 编译less文件，如果有外部引用，为了保持项目结构，需要使用插件 gulp-sourcemaps
gulp.task(&apos;lesstocss&apos;, function () {
    //编译src目录下的所有less文件
    //除了reset.less和test.less（**匹配src/less的0个或多个子文件夹）
    gulp.src([&apos;src/*.less&apos;, &apos;!src/less/**/{reset,test}.less&apos;]) 
        .pipe(less())
        // 编译后压缩css文件输出到min
        .pipe(cleanCSS({compatibility: &apos;ie8&apos;})) // 兼容IE8及以下浏览器
        .pipe(gulp.dest(&apos;min&apos;));
});</code></pre><h5 id="12-gulp-autoprefixer-给-css-项处理浏览器前缀"><a href="#12-gulp-autoprefixer-给-css-项处理浏览器前缀" class="headerlink" title="12. gulp-autoprefixer 给 css 项处理浏览器前缀"></a>12. gulp-autoprefixer 给 css 项处理浏览器前缀</h5><p><code>cnpm install --save-dev gulp-autoprefixer</code></p>
<pre><code>const autoprefixer = require(&apos;gulp-autoprefixer&apos;);

// 自动补齐css前缀
gulp.task(&apos;autoprefixer&apos;, () =&gt; {
    gulp.src(&apos;src/index.css&apos;)
        .pipe(autoprefixer({
            browsers: [&apos;last 2 versions&apos;], // 主流浏览器的最新两个版本
            cascade: true, // 是否美化属性值 默认：true
            remove:true // 是否去掉不必要的前缀 默认：true 
        }))
        .pipe(gulp.dest(&apos;dist&apos;))
});



// 需要适配的页面
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    @@include(&apos;include/header.html&apos;)

    &lt;p&gt; 这是 layout 的内容 &lt;/p&gt;

    @@include(&apos;include/footer.html&apos;)
&lt;/body&gt;
&lt;/html&gt;</code></pre><h5 id="13-gulp-file-include-头尾共用、文件合并"><a href="#13-gulp-file-include-头尾共用、文件合并" class="headerlink" title="13. gulp-file-include 头尾共用、文件合并"></a>13. gulp-file-include 头尾共用、文件合并</h5><p><code>cnpm install gulp-file-include --save-dev</code></p>
<pre><code>const fileinclude  = require(&apos;gulp-file-include&apos;);

// 头尾共用
gulp.task(&apos;fileinclude&apos;, () =&gt; {
    // 适配page中所有文件夹下的所有html，排除page下的include文件夹中html
        gulp.src([&apos;src/*.html&apos;,&apos;!src/include/**.html&apos;])
        .pipe(fileinclude({
          prefix: &apos;@@&apos;,
          basepath: &apos;@file&apos;
        }))
    .pipe(gulp.dest(&apos;dist&apos;))
});</code></pre><h5 id="14-gulp-livereload-监听文件变化局部刷新"><a href="#14-gulp-livereload-监听文件变化局部刷新" class="headerlink" title="14. gulp-livereload 监听文件变化局部刷新"></a>14. gulp-livereload 监听文件变化局部刷新</h5><h5 id="15-gulp-imagemin-压缩图片"><a href="#15-gulp-imagemin-压缩图片" class="headerlink" title="15. gulp-imagemin 压缩图片"></a>15. gulp-imagemin 压缩图片</h5><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>const gulp = require(&apos;gulp&apos;);
const babel = require(&apos;gulp-babel&apos;);
const uglify = require(&apos;gulp-uglify&apos;);
const htmlmin = require(&apos;gulp-htmlmin&apos;);
const cleanCSS = require(&apos;gulp-clean-css&apos;);
const concat = require(&apos;gulp-concat&apos;);
const less = require(&apos;gulp-less&apos;);
const autoprefixer = require(&apos;gulp-autoprefixer&apos;);
const fileinclude  = require(&apos;gulp-file-include&apos;);

// 头尾共用
gulp.task(&apos;fileinclude&apos;, () =&gt; {
    // 适配page中所有文件夹下的所有html，排除page下的include文件夹中html
        gulp.src([&apos;src/*.html&apos;,&apos;!src/include/**.html&apos;])
        .pipe(fileinclude({
          prefix: &apos;@@&apos;,
          basepath: &apos;@file&apos;
        }))
    .pipe(gulp.dest(&apos;dist&apos;))
});

// 压缩html和html页面内的css/js
gulp.task(&apos;htmlmin&apos;, function () {
    var options = {
        removeComments: true,//清除HTML注释
        collapseWhitespace: true,//压缩HTML
        collapseBooleanAttributes: true,//省略布尔属性的值 &lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input /&gt;
        removeEmptyAttributes: true,//删除所有空格作属性值 &lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt;
        removeScriptTypeAttributes: true,//删除&lt;script&gt;的type=&quot;text/javascript&quot;
        removeStyleLinkTypeAttributes: true,//删除&lt;style&gt;和&lt;link&gt;的type=&quot;text/css&quot;
        minifyJS: true,//压缩页面JS
        minifyCSS: true//压缩页面CSS
    };
    gulp.src(&apos;dist/*.html&apos;)
        .pipe(htmlmin(options))
        .pipe(gulp.dest(&apos;min&apos;));
});

// 编译less文件，如果有外部引用，为了保持项目结构，需要使用插件 gulp-sourcemaps
gulp.task(&apos;lesstocss&apos;, function () {
    //编译src目录下的所有less文件
    //除了reset.less和test.less（**匹配src的0个或多个子文件夹）
    gulp.src([&apos;src/*.less&apos;, &apos;!src/**/{reset,test}.less&apos;]) 
        .pipe(less())
        // 编译后自动补齐css前缀
        .pipe(autoprefixer({
            browsers: [&apos;last 2 versions&apos;], // 主流浏览器的最新两个版本
            cascade: true, // 是否美化属性值 默认：true
            remove:true // 是否去掉不必要的前缀 默认：true 
        }))
        // 然后压缩css文件输出到min
        .pipe(cleanCSS({compatibility: &apos;ie8&apos;})) // 兼容IE8及以下浏览器
        .pipe(gulp.dest(&apos;min&apos;));
});

// ES6代码转码为ES5
gulp.task(&apos;toes5&apos;, () =&gt;
    gulp.src(&apos;src/*.js&apos;) // 需要转码的es6文件，这里代表src文件夹下的所有js文件
        /*
        最新的presets: [&apos;env&apos;]，是通用版，可以转码es2015、react、es2017, 
        这里只用于转码es2015，你可以下载相关转码依赖
        */
        .pipe(babel({
            presets: [&apos;env&apos;]
        }))
        .pipe(gulp.dest(&apos;dist&apos;)) // 转码后的文件输出位置
);

// 合并 js 文件, 但不会转码和压缩
gulp.task(&apos;jsconcat&apos;, () =&gt; {
    gulp.src(&apos;src/*.js&apos;)
        .pipe(concat(&apos;index.js&apos;)) // 合并后的文件名
        .pipe(gulp.dest(&apos;dist&apos;))
});

// JS代码压缩
gulp.task(&apos;jsmin&apos;, () =&gt;
    gulp.src(&apos;dist/*.js&apos;) // 需要压缩的js文件
        .pipe(uglify())
        .pipe(gulp.dest(&apos;min&apos;)) // 压缩的js文件输出位置
);



// // 使用监听，但是需要预先使用命令 gulp auto，文件如果修改了，就一步到位
// gulp.task(&apos;auto&apos;, () =&gt; {
//     gulp.watch(&apos;src/*.js&apos;, [&apos;toes5&apos;]) // 需要转码的js文件位置 + 口令
//     gulp.watch(&apos;dist/*.js&apos;, [&apos;jsmin&apos;]) // 需要压缩的js文件位置 + 口令
//     // gulp.watch...
// });</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/06/Gulp/" data-id="ck8gofbce0008hk9heyqf3ajw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-webpack3(三)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/12/webpack3(%E4%B8%89)/" class="article-date">
  <time datetime="2018-07-12T02:45:08.000Z" itemprop="datePublished">2018-07-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/webpack/">webpack</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/12/webpack3(%E4%B8%89)/">webpack(三)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>目录</p>
<blockquote>
<p>5.3 JS打包</p>
<blockquote>
<p>5.3.1 JS压缩/hash命名</p>
<p>5.3.2 babel转码ES6/ES7/JSX</p>
</blockquote>
<p>5.4 图片打包与路径坑</p>
<blockquote>
<p>5.4.1 图片在CSS中</p>
<p>5.4.2 图片路径问题(包括分离后的CSS路径问题)</p>
<p>5.4.3 关于HTML中的图片</p>
</blockquote>
</blockquote>
<ol start="6">
<li>打包后的调试</li>
</ol>
</blockquote>
<h3 id="5-3-JS打包"><a href="#5-3-JS打包" class="headerlink" title="5.3 JS打包"></a>5.3 JS打包</h3><h4 id="5-3-1-JS压缩-hash命名"><a href="#5-3-1-JS压缩-hash命名" class="headerlink" title="5.3.1 JS压缩/hash命名"></a>5.3.1 JS压缩/hash命名</h4><p><code>uglifyjs-webpack-plugin</code>压缩插件是<code>webpack</code>版本里默认已经集成，不需再次安装。在<code>webpack.config.js</code>中引入即可：</p>
<pre><code>const uglify = require(&apos;uglifyjs-webpack-plugin&apos;);</code></pre><p>引入后，在<code>plugins</code>配置一下就可以了：</p>
<pre><code>plugins:[
    // 压缩js
    new uglify()
],</code></pre><p>然后使用<code>npm run start</code>打包即可。</p>
<p><strong>js文件的hash命名</strong></p>
<p>如果需要给js文件一个<code>hash</code>命名，可以在<code>output</code>中的<code>filename</code>进行配置:</p>
<pre><code>filename: &apos;[hash].js&apos;
// filename: &apos;[chunkhash].js&apos;</code></pre><p><a href="http://blog.csdn.net/Scarlett_Dream/article/details/78856240" target="_blank" rel="noopener">关于hash和chunkhash的区别</a></p>
<p><strong>清除重复不同hash名的js</strong></p>
<p>使用<code>clean-webpack-plugin</code>，不过也可以通过直接删除<code>dist</code>文件夹，然后再次打包的方式来更新，此处请查阅官方文档。</p>
<h4 id="5-3-2-babel转码ES6-ES7-JSX"><a href="#5-3-2-babel转码ES6-ES7-JSX" class="headerlink" title="5.3.2 babel转码ES6/ES7/JSX"></a>5.3.2 babel转码ES6/ES7/JSX</h4><p><code>Babel</code>是一个编译<code>JavaScript</code>的平台，它可以帮你使用<code>ES6/ES7/JSX</code>等js扩展语言。我们需要下载<code>babel-core</code>、<code>babel-loader</code>，扩展<code>es6/7/8</code>，下载<code>babel-preset-env</code>，扩展<code>JSX</code>(使用<code>react</code>的话)下载<code>babel-preset-react</code>。</p>
<pre><code>cnpm install --save-dev babel-core babel-loader babel-preset-react babel-preset-env</code></pre><p>下载后在项目根目录新建<code>.babelrc</code>文件，并把配置写到文件里。</p>
<pre><code>{
    &quot;presets&quot;:[&quot;react&quot;,&quot;env&quot;]
}</code></pre><p>在<code>webpack.config.js</code>中<code>module</code>进行配置：</p>
<pre><code>{
    test:/\.(jsx|js)$/,
    use:{
        loader:&apos;babel-loader&apos;,
    },
    exclude:/node_modules/
}</code></pre><p><strong>继续前面的例子</strong></p>
<p>配置完毕，我们可以在<code>entry.js</code>添加代码：</p>
<pre><code>let xushao = &quot;shuai&quot;;</code></pre><p>然后打包试试看，是不是成功了，哈哈。</p>
<h3 id="5-4-图片打包与路径坑"><a href="#5-4-图片打包与路径坑" class="headerlink" title="5.4 图片打包与路径坑"></a>5.4 图片打包与路径坑</h3><h4 id="5-4-1-图片在CSS中"><a href="#5-4-1-图片在CSS中" class="headerlink" title="5.4.1 图片在CSS中"></a>5.4.1 图片在CSS中</h4><p><strong>例如：</strong><br>在<code>src</code>下创建<code>images</code>文件夹，放入图片<code>1.png</code>,编辑<code>HTML文件</code>和<code>css文件</code>：</p>
<pre><code>html中添加：
&lt;div id=&quot;tupian&quot;&gt;&lt;/div&gt;

css中添加：
#tupian{
   background-image: url(../images/1.png);
   width:466px;
   height:453px;
}</code></pre><p>我们需要安装<code>file-loader</code>和<code>url-loader</code>两个<code>loader</code>(其实<code>url-loader</code>内置了<code>file-loader</code>，但是为了保险起见和解决一些路径问题，所以建议同时单独安装<code>file-loader</code>):</p>
<pre><code>cnpm install --save-dev file-loader url-loader</code></pre><p><code>file-loader</code>: 解决引用路径的问题,可以解析项目中的url引入（图片和ccss文件等）。</p>
<p><code>url-loader</code>: 将引入的图片编码。为了避免图片较大导致编码消耗性能，可以通过<code>limit</code>参数限制，小于<code>limit</code>的文件被转化为<code>DataURL</code>。</p>
<p><strong>在<code>module</code>中配置url-loader：</strong></p>
<pre><code>{
    // test:/\.(png|jpg|gif)/是匹配图片文件后缀名称
    test:/\.(png|jpg|gif)/ ,
    // use：是指定使用的loader和loader的配置参数
    use:[{
            loader:&apos;url-loader&apos;,
            options:{
                // 是把小于8192的文件转换成成Base64的格式
                limit: 8192,
                // 打包输出到images文件夹下
                outputPath:&apos;images/&apos;
            }
        }]
}</code></pre><p>配置完毕后可以开始打包试试了。</p>
<h4 id="5-4-2-图片路径问题-包括分离后的CSS路径问题"><a href="#5-4-2-图片路径问题-包括分离后的CSS路径问题" class="headerlink" title="5.4.2 图片路径问题(包括分离后的CSS路径问题)"></a>5.4.2 图片路径问题(包括分离后的CSS路径问题)</h4><p>如果你的<code>css</code>分离后或者你的图片引入发现路径有问题，可以使用<code>publicPath</code>解决，它主要在<code>webpack</code>配置文件的<code>output</code>选项中处理静态文件路径。</p>
<p>我们可以声明一个对象：</p>
<pre><code>var website ={
    // 这里的IP和端口，是你本机的ip或者是你devServer配置的IP和端口。
    publicPath:&quot;http://113.250.159.94:1010&quot;
}</code></pre><p>然后在output选项中引用这个对象的publicPath属性：</p>
<pre><code>//出口文件的配置项
output:{
    //输出的路径，用了Node语法
    path:path.resolve(__dirname,&apos;dist&apos;),
    //输出的文件名称
    filename:&apos;[name].js&apos;,
    publicPath:website.publicPath
},</code></pre><p>配置后进行打包，相对路径改为了绝对路径，速度稍微也变快了些。</p>
<h4 id="5-4-3-关于HTML中的图片"><a href="#5-4-3-关于HTML中的图片" class="headerlink" title="5.4.3 关于HTML中的图片"></a>5.4.3 关于HTML中的图片</h4><p>标签<code>&lt;img&gt;</code>引入的图片怎么办呢？你可以使用一个不是很火但是很实用的<code>loader</code>——<code>html-withimg-loader</code>:</p>
<pre><code>cnpm install html-withimg-loader --save-dev</code></pre><p>再配置一下<code>module</code>:</p>
<pre><code>{
    test: /\.(htm|html)$/i,
    use:[ &apos;html-withimg-loader&apos;] 
}</code></pre><p>然后就可以开始打包了。</p>
<h2 id="6-打包后的调试"><a href="#6-打包后的调试" class="headerlink" title="6. 打包后的调试"></a>6. 打包后的调试</h2><p>我们可以通过配置<code>devtool</code>进行开发调试，但要记得上线前修改这些调试。</p>
<pre><code>devtool: &apos;eval-source-map&apos;,</code></pre><p>常用四种选项：</p>
<p><code>source-map</code>:在一个单独文件中产生一个完整且功能完全的文件。打包速度比较慢。</p>
<p><code>cheap-module-source-map</code>:在一个单独的文件中产生一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号）,会对调试造成不便。</p>
<p> <code>eval-source-map</code>:使用<code>eval</code>打包源文件模块，在同一个文件中生产干净的完整版的<code>sourcemap</code>，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定要不开启这个选项。</p>
<p> <code>cheap-module-eval-source-map</code>:这是在打包文件时最快的生产<code>source map</code>的方法，生产的 <code>Source map</code> 会和打包后的<code>JavaScript</code>文件同行显示，没有影射列，和<code>eval-source-map</code>选项具有相似的缺点。</p>
<p>【建议：大型项目可以使用source-map；中小型项目使用eval-source-map就完全可以应对。这些调试只适用于开发阶段，上线前记得修改这些调试设置】</p>
<p><img src="https://thumbnail0.baidupcs.com/thumbnail/9c0f8419c448613afe5e9ce4e03c42dd?fid=1737706044-250528-418203039170764&time=1517058000&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Qkr71fUc1rIISl3r2mSINMehzCM%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=624108863495940664&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video" alt="分割线"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/12/webpack3(%E4%B8%89)/" data-id="ck8gofbcm000lhk9h50el3do1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-webpack3(二)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/01/webpack3(%E4%BA%8C)/" class="article-date">
  <time datetime="2018-04-01T10:43:08.000Z" itemprop="datePublished">2018-04-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/webpack/">webpack</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/01/webpack3(%E4%BA%8C)/">webpack(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>目录</p>
<ol start="5">
<li>模块与插件配置</li>
</ol>
<blockquote>
<p>5.1 发布HTML</p>
<p>5.2  CSS打包</p>
<blockquote>
<p>5.2.1  分离CSS</p>
<p>5.2.2 压缩(丑化)css代码</p>
<p>5.2.3 自动处理CSS3属性前缀</p>
<p>5.2.4 消除未使用的CSS</p>
<p>5.2.5 less打包</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="5-模块与插件配置"><a href="#5-模块与插件配置" class="headerlink" title="5. 模块与插件配置"></a>5. 模块与插件配置</h2><p>什么是<code>Loaders</code>? <code>loader</code> 用于对模块的源代码进行转换。是<code>webpack</code>最重要的功能，它有如下配置项：</p>
<pre><code>test: 用于匹配处理文件的扩展名的正则表达式，必须配置

use: loader名称(就是你要使用的模块的名称)，必须配置

include/exclude: 手动添加的&apos;必须处理的文件(文件夹)/屏蔽不需要处理的文件(文件夹)&apos;，可选配置

query: 为loaders提供额外的设置选项（可选）</code></pre><h3 id="5-1-发布HTML"><a href="#5-1-发布HTML" class="headerlink" title="5.1 发布HTML"></a>5.1 发布HTML</h3><p>我们在src下创建一个<code>index.html</code>文件：</p>
<pre><code>- webpack
    + dist // 文件输出目录
    + node_modules // node包依赖
    - src // 源码文件目录
        entry.js // webpack的入口文件
        index.html 
    package.json
    webpack.config.js // webpack配置文件</code></pre><p><code>index.html</code>:</p>
<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;!-- 手机页面中加入这句话，可以让页面适应设备的宽度。initial-scale - 初始的缩放比例 --&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;!-- Edge 模式通知 Windows Internet Explorer 以最高级别的可用模式显示内容 --&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt;
    &lt;title&gt;XQF webpack test&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;gogo&quot;&gt;&lt;/div&gt;
    &lt;div id=&quot;title&quot;&gt;&lt;/div&gt;
    &lt;p&gt;我是小段落123&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><p>▲ 这份<code>index.html</code>文件没有js引入，<code>webpack</code>会为我们自动引入<code>js</code>。它还能够通过入口js文件帮我们自动引入<code>css</code>文件。</p>
<p>我们先安装<code>html-webpack-plugin</code>，它简化了HTML文件的创建，以便为你的webpack包提供服务：</p>
<pre><code>cnpm install --save-dev html-webpack-plugin</code></pre><p>然后在<code>webpack.config.js</code>中引入插件：</p>
<pre><code>// 头部require
const htmlPlugin = require(&apos;html-webpack-plugin&apos;);

// 在plugins中插入
new htmlPlugin({
    // minify：是对html文件进行压缩，removeAttrubuteQuotes是却掉属性的双引号。
    minify:{
        removeAttributeQuotes:true
    },
    // hash：为了开发中js有缓存效果，所以加入hash，这样可以有效避免缓存JS。
    hash:true,
    // template：是要打包的html模版路径和文件名称。
    template:&apos;./src/index.html&apos;
})</code></pre><h3 id="5-2-CSS打包"><a href="#5-2-CSS打包" class="headerlink" title="5.2 CSS打包"></a>5.2 CSS打包</h3><p>在<code>src</code>创建文件夹<code>css</code>，在<code>css</code>里创建<code>index.css</code>:</p>
<pre><code>- src
    - css
        index.css</code></pre><p><code>index.css</code>:</p>
<pre><code>body {
    background-color: #D5B740;
    color: black;
}
#gogo {
    width: 466px;
    height: 453px;
    transform: rotate(45deg);
    box-shadow: 1px 1px 0 rgba(0,0,0,.25);
}
#meiyong {
    width: 100%;
}
#meiyong2 {
    width: 50%;
}</code></pre><p>css打包需要<code>style-loader</code>、<code>css-loader</code>两个<code>loader</code>。 ==一般这两个<code>loader</code>结合使用，顺序是<code>style-loader</code>在前== ：</p>
<pre><code>// 使用npm下载两个`loader`:
cnpm install --save-dev style-loader css-loader</code></pre><p><code>style-loader</code>: 让js解析css。</p>
<p><code>css-loader</code>: <code>css-loader</code> 解释(<code>interpret</code>) <code>@import</code> 和 <code>url()</code> ，会 <code>import/require()</code> 后再解析<code>(resolve)</code>它们。</p>
<p>在入口文件<code>entry.js</code>里引入<code>css</code>：</p>
<pre><code>import css from &apos;./css/index.css&apos;;</code></pre><p>在<code>webpack.config.js</code>的配置:</p>
<pre><code>module: {
    rules: [
        {
            test: /\.css$/,
            use: [ &apos;style-loader&apos;, &apos;css-loader&apos; ]
            // use可以换作loader
            // loader: [ &apos;style-loader&apos;, &apos;css-loader&apos; ]
        }
    ]
},</code></pre><p>执行<code>npm start</code>打包一下，我们发现打包成功了。我们可以执行<code>npm run server</code>在服务端查看一下。</p>
<h4 id="5-2-1-分离CSS"><a href="#5-2-1-分离CSS" class="headerlink" title="5.2.1 分离CSS"></a>5.2.1 分离CSS</h4><p>但是我们发现<code>css</code>是打包在<code>js</code>里的，因为<code>webpack</code>官方认为CSS就应该打包到<code>JavasScript</code>当中以减少<code>http</code>的请求数，但现实需求有时候需要分离<code>css</code>。那么我们需要一个插件<code>extract-text-webpack-plugin</code>：</p>
<pre><code>cnpm install --save-dev extract-text-webpack-plugin</code></pre><p>安装完成后在<code>webpack.config.js</code>中引用</p>
<pre><code>// 顶部require引入
const extractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);

// 在module中进行配置
{
    test: /\.css$/,
    use: extractTextPlugin.extract({
        fallback: &quot;style-loader&quot;,
        use: &apos;css-loader&apos;
    })                
},

// 在plugins中进行配置
plugins:[
    new extractTextPlugin(&quot;./css/index.css&quot;)
],</code></pre><h4 id="5-2-2-压缩-丑化-css代码"><a href="#5-2-2-压缩-丑化-css代码" class="headerlink" title="5.2.2 压缩(丑化)css代码"></a>5.2.2 压缩(丑化)css代码</h4><p>设置 <code>minimize:true</code> ,就可以压缩<code>css</code>了。</p>
<pre><code>module: {
    rules: [
        {
            test: /\.css$/,
            use: extractTextPlugin.extract({
                fallback: &quot;style-loader&quot;,
                use: [
                    { loader: &apos;css-loader&apos;, options: { minimize: true } }
                ]
            })
        }
    ]
},</code></pre><h4 id="5-2-3-自动处理CSS3属性前缀"><a href="#5-2-3-自动处理CSS3属性前缀" class="headerlink" title="5.2.3 自动处理CSS3属性前缀"></a>5.2.3 自动处理CSS3属性前缀</h4><p>下载 <code>postcss-loader</code> 和<code>autoprefixer</code>（自动添加前缀的插件）。</p>
<pre><code>cnpm install --save-dev postcss-loader autoprefixer</code></pre><p>在<code>src</code>下建立<code>postcss.config.js</code>:</p>
<pre><code>- webpack
    + dist // 文件输出目录
    + node_modules // node包依赖
    - src // 源码文件目录
        - css
            index.css
        entry.js // webpack的入口文件
        index.html 
    package.json
    postcss.config.js // postcss配置文件
    webpack.config.js // webpack配置文件</code></pre><p><code>postcss.config.js</code>:</p>
<pre><code>module.exports = {
    plugins: [
        require(&apos;autoprefixer&apos;)
    ]
}</code></pre><p>没有配置外部css导出，在<code>module</code>这样配置<code>postcss</code>:</p>
<pre><code>{
      test: /\.css$/,
      use: [
            {
              loader: &quot;style-loader&quot;
            }, {
              loader: &quot;css-loader&quot;,
              options: {
                 modules: true
              }
            }, {
              loader: &quot;postcss-loader&quot;
            }
      ]
}</code></pre><p>配置了<code>extractTextPlugin</code>，在<code>module</code>这样配置<code>postcss</code>:</p>
<pre><code>{
    test: /\.css$/,
    use: extractTextPlugin.extract({
        fallback: &apos;style-loader&apos;,
        use: [
            { loader: &apos;css-loader&apos;, options: { importLoaders: 1 } },
            &apos;postcss-loader&apos;
        ]
    })

}</code></pre><p>执行打包处理，自动加上css前缀。</p>
<h4 id="5-2-4-消除未使用的CSS"><a href="#5-2-4-消除未使用的CSS" class="headerlink" title="5.2.4 消除未使用的CSS"></a>5.2.4 消除未使用的CSS</h4><p>对于框架(比如<code>bootstrap</code>)或者自己修改后没有使用的css，可以使用<code>PurifyCSS-webpack</code>：</p>
<pre><code>// -D代表的是–save-dev ,只是一个简写
//  需要安装purifyCSS-webpack、purify-css这两个包
cnpm i -D purifycss-webpack purify-css</code></pre><p>因为我们需要同步检查html模板，所以我们需要引入node的glob对象使用。同时，引入purifycss-webpack。</p>
<pre><code>const glob = require(&apos;glob&apos;);
const PurifyCSSPlugin = require(&quot;purifycss-webpack&quot;);</code></pre><p>我们在<code>plugins</code>中配置:</p>
<pre><code>// PurifyCSSPlugin 要在 extractTextPlugin 之前，不然 extractTextPlugin 里的压缩和自动前缀可能被影响
new PurifyCSSPlugin({
    // 配置了一个paths，主要是需找html模板，purifycss根据这个配置会遍历你的文件，查找哪些css被使用了
    paths: glob.sync(path.join(__dirname, &apos;src/*.html&apos;)),
}),</code></pre><h4 id="5-2-5-less打包"><a href="#5-2-5-less打包" class="headerlink" title="5.2.5 less打包"></a>5.2.5 less打包</h4><p>确定你的生产环境中配了<code>less</code>服务：</p>
<pre><code>cnpm install --save-dev less</code></pre><p>然后安装<code>less-loader</code>:</p>
<pre><code>cnpm install --save-dev less-loader</code></pre><p>在<code>src/css</code>下创建 <code>myless.less</code>：</p>
<pre><code>@base :#000;
#gogo{
    width:300px;
    height:300px;
    background-color:@base;
}</code></pre><p>配置了<code>extractTextPlugin</code>，在<code>module</code>里这样配置<code>less-loader</code>:</p>
<pre><code>{
    test: /\.less$/,
    use: extractTextPlugin.extract({
        use: [{
            loader: &quot;css-loader&quot;,
            options: { minimize: true }
        }, {
            loader: &quot;less-loader&quot;
        },{
            loader: &apos;postcss-loader&apos;
        }],
        fallback: &quot;style-loader&quot;
    })
}</code></pre><p>在<code>entry.js</code>中配置：</p>
<pre><code>import less from &apos;./css/black.less&apos;;</code></pre><p>【sass亦同 : 需要在项目目录下用npm安装两个包。node-sass和sass-loader】</p>
<p><img src="https://thumbnail0.baidupcs.com/thumbnail/9c0f8419c448613afe5e9ce4e03c42dd?fid=1737706044-250528-418203039170764&time=1517058000&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Qkr71fUc1rIISl3r2mSINMehzCM%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=624108863495940664&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video" alt="分割线"></p>
<p>当前的<code>webpack.config.js</code></p>
<pre><code>const path = require(&apos;path&apos;);
const htmlPlugin= require(&apos;html-webpack-plugin&apos;);
const extractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);
const glob = require(&apos;glob&apos;);
const PurifyCSSPlugin = require(&quot;purifycss-webpack&quot;);

module.exports={

    // 入口文件的配置项
    entry:{
        // 这里的entry可以随意命名，使用相对路径引入相应js
        entry: &apos;./src/entry.js&apos;
        // 如果需要引入多个js
        // entry: [&apos;./src/entry.js&apos;, &apos;./src/myjs.js&apos;]
    },

    // 出口文件的配置项
    output:{
        // 打包的路径输出位置，resolve(解析),这里指定一个本机绝对路径
        path: path.resolve(__dirname, &apos;dist&apos;),
        // 打包的文件输出名称
        filename: &apos;output.js&apos;
    },

    // 模块, 比如解读打包js/CSS, 转换压缩图片
    module: {
        rules: [
            {
                test: /\.css$/,
                use: extractTextPlugin.extract({
                    fallback: &quot;style-loader&quot;,
                    use: [
                        { loader: &apos;css-loader&apos;, options: { minimize: true } },
                        &apos;postcss-loader&apos;
                    ]
                })
            },{
                test: /\.less$/,
                use: extractTextPlugin.extract({
                    use: [{
                        loader: &quot;css-loader&quot;,
                        options: { minimize: true }
                    }, {
                        loader: &quot;less-loader&quot;
                    },{
                        loader: &apos;postcss-loader&apos;
                    }],
                    fallback: &quot;style-loader&quot;
                })
            }
        ]
    },

    //插件
    plugins:[
        new htmlPlugin({
            // minify：是对html文件进行压缩，removeAttrubuteQuotes是却掉属性的双引号。
            minify:{
                removeAttributeQuotes:true
            },
            // hash：为了开发中js有缓存效果，所以加入hash，这样可以有效避免缓存JS。
            hash:true,
            // template：是要打包的html模版路径和文件名称。
            template:&apos;./src/index.html&apos;
        }),

        // PurifyCSSPlugin 要在 extractTextPlugin 之前，不然 extractTextPlugin 里的压缩和自动前缀可能被影响
        new PurifyCSSPlugin({
            // 配置了一个paths，主要是需找html模板，purifycss根据这个配置会遍历你的文件，查找哪些css被使用了
            paths: glob.sync(path.join(__dirname, &apos;src/*.html&apos;)),
        }),

        new extractTextPlugin(&quot;/css/index.css&quot;),
    ],

    // 开发调试工具
    devtool:&apos;&apos;,

    //配置webpack开发服务
    devServer:{
        // 设置关联的基本运行路径，这里因为例子是dist，所以我们写的dist
        contentBase:path.resolve(__dirname,&apos;dist&apos;),
        // 服务器的IP地址，可以使用IP也可以使用localhost。可以使用ipconfig获取本机ipv4地址在这里使用。
        host:&apos;localhost&apos;,
        // 服务端压缩是否开启，一般为开启
        compress:true,
        //配置服务端口号，这里使用1010
        port:1010
    }
}</code></pre><p>当前的<code>entry.js</code>:</p>
<pre><code>import css from &apos;./css/index.css&apos;;
import less from &apos;./css/myless.less&apos;;

console.log(&quot;123&quot;);
var xuqingfeng = &quot;asd2333&quot;;</code></pre><p><img src="https://thumbnail0.baidupcs.com/thumbnail/9c0f8419c448613afe5e9ce4e03c42dd?fid=1737706044-250528-418203039170764&time=1517058000&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Qkr71fUc1rIISl3r2mSINMehzCM%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=624108863495940664&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video" alt="分割线"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/01/webpack3(%E4%BA%8C)/" data-id="ck8gofbcp000phk9h9ehaa93y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ajax/">ajax</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/fetch/">fetch</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/gulp/">gulp</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/node/">node</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/">webpack</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/01/%E3%80%8AJust-JavaScript%E3%80%8B02-JavaScript%E5%AE%87%E5%AE%99/">《Just JavaScript》02.JavaScript宇宙</a>
          </li>
        
          <li>
            <a href="/2020/03/31/%E3%80%8AJust-JavaScript%E3%80%8B01-%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B/">《Just JavaScript》01.思维模型</a>
          </li>
        
          <li>
            <a href="/2019/07/31/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">内存模型</a>
          </li>
        
          <li>
            <a href="/2019/04/01/%E9%97%AD%E5%8C%85/">闭包</a>
          </li>
        
          <li>
            <a href="/2019/03/30/ECMAScript5%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/">JavaScript数组方法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 zxl<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>