{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/iLiKE/source/js/iLiKE.js","path":"js/iLiKE.js","modified":0,"renderable":1},{"_id":"themes/iLiKE/source/css/archives.styl","path":"css/archives.styl","modified":0,"renderable":1},{"_id":"themes/iLiKE/source/css/article.styl","path":"css/article.styl","modified":0,"renderable":1},{"_id":"themes/iLiKE/source/css/footer.styl","path":"css/footer.styl","modified":0,"renderable":1},{"_id":"themes/iLiKE/source/css/header.styl","path":"css/header.styl","modified":0,"renderable":1},{"_id":"themes/iLiKE/source/css/heighlight.styl","path":"css/heighlight.styl","modified":0,"renderable":1},{"_id":"themes/iLiKE/source/css/iLiKE.styl","path":"css/iLiKE.styl","modified":0,"renderable":1},{"_id":"themes/iLiKE/source/css/list.styl","path":"css/list.styl","modified":0,"renderable":1},{"_id":"themes/iLiKE/source/css/pagenator.styl","path":"css/pagenator.styl","modified":0,"renderable":1},{"_id":"themes/iLiKE/source/css/social.styl","path":"css/social.styl","modified":0,"renderable":1},{"_id":"themes/iLiKE/source/image/douban.png","path":"image/douban.png","modified":0,"renderable":1},{"_id":"themes/iLiKE/source/image/email.png","path":"image/email.png","modified":0,"renderable":1},{"_id":"themes/iLiKE/source/image/facebook.png","path":"image/facebook.png","modified":0,"renderable":1},{"_id":"themes/iLiKE/source/image/google.png","path":"image/google.png","modified":0,"renderable":1},{"_id":"themes/iLiKE/source/image/github.png","path":"image/github.png","modified":0,"renderable":1},{"_id":"themes/iLiKE/source/image/instagram.png","path":"image/instagram.png","modified":0,"renderable":1},{"_id":"themes/iLiKE/source/image/jianshu.png","path":"image/jianshu.png","modified":0,"renderable":1},{"_id":"themes/iLiKE/source/image/linkedin.png","path":"image/linkedin.png","modified":0,"renderable":1},{"_id":"themes/iLiKE/source/image/pocket.png","path":"image/pocket.png","modified":0,"renderable":1},{"_id":"themes/iLiKE/source/image/stack-overflow.png","path":"image/stack-overflow.png","modified":0,"renderable":1},{"_id":"themes/iLiKE/source/image/tumblr.png","path":"image/tumblr.png","modified":0,"renderable":1},{"_id":"themes/iLiKE/source/image/twitter.png","path":"image/twitter.png","modified":0,"renderable":1},{"_id":"themes/iLiKE/source/image/weibo.png","path":"image/weibo.png","modified":0,"renderable":1},{"_id":"themes/iLiKE/source/image/zhihu.png","path":"image/zhihu.png","modified":0,"renderable":1},{"_id":"themes/iLiKE/source/image/Hexo.png","path":"image/Hexo.png","modified":0,"renderable":1},{"_id":"themes/iLiKE/source/favicon.svg","path":"favicon.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1585643637001},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1585643637001},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1585643637002},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1585643637001},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1585643637002},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1585643637008},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1585643480934},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1585643637002},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1585643637003},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1585643637002},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1585643637003},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1585643637003},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1585643637003},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1585643637004},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1585643637007},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1585643637007},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1585643637002},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1585643637003},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1585643637003},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1585643637007},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1585643637007},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1585643637008},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1585643637007},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1585643637007},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1585643637002},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1585643637003},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1585643637007},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1585643637006},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1585643637006},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1585643637007},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1585643637007},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1585643637007},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1585643637004},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1585643637004},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1585643637004},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1585643637004},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1585643637005},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1585643637005},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1585643637004},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1585643637005},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1585643637005},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1585643637005},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1585643637006},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1585643637016},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1585643637016},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1585643637016},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1585643637016},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1585643637016},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1585643637017},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1585643637018},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1585643637018},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1585643637018},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1585643637008},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1585643637010},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1585643637015},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1585643637016},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1585643637005},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1585643637006},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1585643637006},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1585643637006},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1585643637006},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1585643637006},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1585643637017},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1585643637017},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1585643637017},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1585643637017},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1585643637017},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1585643637016},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1585643637008},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1585643637008},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1585643637008},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1585643637009},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1585643637009},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1585643637009},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1585643637009},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1585643637009},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1585643637009},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1585643637009},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1585643637009},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1585643637010},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1585643637011},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1585643637011},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1585643637013},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1585643637013},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1585643637012},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1585643637015},{"_id":"public/2020/03/31/hello-world/index.html","hash":"a27e967b689163d826f2467fa82cef960ee86cb0","modified":1585647601548},{"_id":"public/archives/index.html","hash":"2124b93d90ae058338c359599ee975f75b506889","modified":1591175214462},{"_id":"public/archives/2020/index.html","hash":"6cb6add6f1900e70f87d32c661fffc3d2fd9acae","modified":1591175214462},{"_id":"public/archives/2020/03/index.html","hash":"e0f1921df1386f9a929d288dcca9a78f1f330699","modified":1591175214462},{"_id":"public/index.html","hash":"3a66cb1a4c632f44fc433b059fa1ae47ddfd873f","modified":1591170896226},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1585643748176},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1585643748176},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1585643748176},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1585643748176},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1585643748176},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1585643748176},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1585643748176},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1585643748176},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1585643748176},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1585643748176},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1585643748176},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1585643748176},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1585643748176},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1585643748176},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1585643748176},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1585643748176},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1585643748176},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1585643748176},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1585643748176},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1585643748176},{"_id":"public/css/style.css","hash":"5f8dadd37d0052c557061018fe6f568f64fced9b","modified":1585643748176},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1585643748176},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1585643748176},{"_id":"source/.DS_Store","hash":"390b77bc52206aed635550d964d083c837d9c1e5","modified":1591173840421},{"_id":"source/_posts/article-title.md","hash":"6a8d16f2a232c72442732d27137da204bd289323","modified":1585647426572},{"_id":"public/2020/03/31/article-title/index.html","hash":"6b6433c93e468532fd00e26d2b5fc16cacd5633a","modified":1585647601548},{"_id":"source/_posts/.DS_Store","hash":"3f970901340becc538597cf05c38757378e05dd7","modified":1591173840423},{"_id":"source/_posts/img/test.png","hash":"672f591ba48e390c647ce3e400c46710ee853c1d","modified":1583390723000},{"_id":"source/_posts/img/.DS_Store","hash":"1f188607706e1055ff339fdc317f2b8406e73fe8","modified":1585646651771},{"_id":"source/_posts/article-title/test.png","hash":"672f591ba48e390c647ce3e400c46710ee853c1d","modified":1585647011923},{"_id":"source/_posts/article-title/.DS_Store","hash":"1f188607706e1055ff339fdc317f2b8406e73fe8","modified":1585646651771},{"_id":"public/2020/03/31/article-title/test.png","hash":"672f591ba48e390c647ce3e400c46710ee853c1d","modified":1585647445027},{"_id":"source/_posts/xxxx.md","hash":"be9121c93d8193a626ce3f92a63e5757e65654f1","modified":1585647886212},{"_id":"source/_posts/xxxx/test.png","hash":"672f591ba48e390c647ce3e400c46710ee853c1d","modified":1585647575547},{"_id":"public/2020/03/31/xxxx/index.html","hash":"b7e0ed7caff86ddc81871dffa43ca224faae378e","modified":1585647890854},{"_id":"public/2020/03/31/xxxx/test.png","hash":"672f591ba48e390c647ce3e400c46710ee853c1d","modified":1585647601548},{"_id":"source/_posts/Ajax学习知识点.md","hash":"d5e8801afeccf24524300e5389971a10275a8006","modified":1519912352000},{"_id":"source/_posts/ECMAScript5中的数组方法.md","hash":"8aa878acd62807fde2cbd10402d94290d915b5b1","modified":1591175208630},{"_id":"source/_posts/JS中的严格模式.md","hash":"d9b309fbbe4a81e47c8a8567d545856d211c23d4","modified":1553260022000},{"_id":"source/_posts/Fetch学习笔记.md","hash":"40aaa2b99211b9807d65f8c1fc2ec878eac9e60d","modified":1518248910000},{"_id":"source/_posts/webpack3(一).md","hash":"21683d5a2b7b6df851e31f11dddcdd9b85a144fd","modified":1519890594000},{"_id":"source/_posts/NodeJs学习笔记1.md","hash":"71b2cbfe5adf32e48302eee0e9f29230edb470cc","modified":1591169004912},{"_id":"source/_posts/Gulp.md","hash":"be1a814254e8fcd44d02b218525349658d0713fa","modified":1585706221880},{"_id":"source/_posts/JavaScript数组方法.md","hash":"3a3047df6aa7748d22f1f72387bbcfa1b9a81de9","modified":1553350398000},{"_id":"source/_posts/webpack3(三).md","hash":"a1c51f19f14ac1da68ae8f258db861db86bf6513","modified":1585706149170},{"_id":"source/_posts/《Just-JavaScript》01-思维模型.md","hash":"be631fd49cb5feb994b6864d09438f8a01d4ed33","modified":1591169182824},{"_id":"source/_posts/webpack3(二).md","hash":"304874f90752c492db4b36e04003386ac81e931a","modified":1585706136903},{"_id":"source/_posts/《Just-JavaScript》02-JavaScript宇宙.md","hash":"3fa068833f89c77e31933bc04845e39ef386a9c3","modified":1591169314826},{"_id":"source/_posts/内存模型.md","hash":"13936a605c9b30e219715401b01c9477e72a4278","modified":1564556227958},{"_id":"source/_posts/闭包.md","hash":"a3e386e9d12101899292f0254feb8a95176d7d4e","modified":1554818592000},{"_id":"public/tags/JavaScript/index.html","hash":"9050401deb56074ecdff2878746b302878d04a48","modified":1591170602612},{"_id":"public/2020/03/31/《Just-JavaScript》01-思维模型/index.html","hash":"609a981bd7c5037a7ba0ffd53961092e3fd66fab","modified":1591167853540},{"_id":"public/2019/03/18/JS中的严格模式/index.html","hash":"6be05ce6206a00dc750dae2fea22395913696a36","modified":1591170602612},{"_id":"public/2018/03/01/Ajax学习知识点/index.html","hash":"e13e8145d350e9484952e915247887fab382db7b","modified":1591170602612},{"_id":"public/archives/page/2/index.html","hash":"2124b93d90ae058338c359599ee975f75b506889","modified":1591175214462},{"_id":"public/archives/2017/index.html","hash":"be41f561bb4cb22ababa4e6a47f2f1c062f3b140","modified":1591175214462},{"_id":"public/archives/2017/12/index.html","hash":"1257091a64dd8f1175ccc7768e08f35388cdee37","modified":1591175214462},{"_id":"public/archives/2018/index.html","hash":"f2640f38c9c0ff852c7dd933b6a3c35f7ba74aa4","modified":1591175214462},{"_id":"public/archives/2018/02/index.html","hash":"2483d3d13a1f5b7b6c1861c42e23e36be84ef02a","modified":1591175214462},{"_id":"public/archives/2018/03/index.html","hash":"9e8a14eda4ee4bca9b56f0a485fbff86ca5cfcbb","modified":1591175214462},{"_id":"public/archives/2018/04/index.html","hash":"0d12063661bd65ef0cd500046a7f9c000a2d5645","modified":1591175214462},{"_id":"public/archives/2018/07/index.html","hash":"c74f6a43f69e44c256690a3f14fa03456dc7464b","modified":1591175214462},{"_id":"public/archives/2018/09/index.html","hash":"8fb50ba1261faf3b6e95724dd17956fbcb240798","modified":1591175214462},{"_id":"public/archives/2019/03/index.html","hash":"6bc08a93f590e35a044202e882dbfbafe7f76f13","modified":1591175214462},{"_id":"public/archives/2019/index.html","hash":"01ffd7e814dc6a3045964d96933c642dff312bbc","modified":1591175214462},{"_id":"public/archives/2019/04/index.html","hash":"92af8cf2df8dd52b9506d2fe41d67a437cc96d24","modified":1591175214462},{"_id":"public/archives/2019/07/index.html","hash":"975f027ec49ab0a7855526fab6ae9116a29f5aeb","modified":1591175214462},{"_id":"public/archives/2020/04/index.html","hash":"ca7615f04764553415efc0ffd6622547b511650b","modified":1591175214462},{"_id":"public/categories/JavaScript/index.html","hash":"c078491538bc03f7c4d5c95e251c3ca884171f89","modified":1591175214462},{"_id":"public/categories/fetch/index.html","hash":"c911c0672f25162e72277aa162ae10d019e53813","modified":1591170602612},{"_id":"public/categories/gulp/index.html","hash":"927002d0c478627bf03777ac4ac451e9e887b256","modified":1591170602612},{"_id":"public/categories/node/index.html","hash":"d486b707be9fc6d18c74d9e0d977074c3178f3b1","modified":1591170602612},{"_id":"public/categories/webpack/index.html","hash":"eb2d8b5c93830012621ec7f6ba3cd8e76651bbc0","modified":1591170602612},{"_id":"public/categories/ajax/index.html","hash":"5d6f6a2d5fd1c043a7ce3835b841567b61526c9b","modified":1591170602612},{"_id":"public/categories/计算机基础/index.html","hash":"e108c6c5d223394c5cfa9c635fe21ca26f1cd203","modified":1591170602612},{"_id":"public/2020/04/01/《Just-JavaScript》02-JavaScript宇宙/index.html","hash":"be3f743c406ac92e3d5d94d3c9e3a303d76d86c0","modified":1591169266970},{"_id":"public/2019/07/31/内存模型/index.html","hash":"6c319922f1617653a72fdc2123b2dbb9e5853f40","modified":1591170602612},{"_id":"public/2019/04/01/闭包/index.html","hash":"98356a82a2ee57b81a5e1e2c78e7b53f6e53e04a","modified":1591170602612},{"_id":"public/2019/03/30/ECMAScript5中的数组方法/index.html","hash":"8a2e19f0713881de15449624af799170cee6f096","modified":1591175214462},{"_id":"public/2019/03/23/JavaScript数组方法/index.html","hash":"e732f8bca8be2bf7fe8d7134401cd68593135c26","modified":1591170602612},{"_id":"public/2018/09/06/Gulp/index.html","hash":"7d998efc65f3c3af7f31d7b3610caead88959da9","modified":1591170602612},{"_id":"public/2018/04/01/webpack3(二)/index.html","hash":"9691120d032d9b39a1c58a1c63d4771b2f030da6","modified":1591170602612},{"_id":"public/2018/03/01/webpack3(一)/index.html","hash":"2c147abf90024121ede6434c5ba5b7d2616af98c","modified":1591170602612},{"_id":"public/2018/02/10/Fetch学习笔记/index.html","hash":"c81915761f31255d195e1279266146d3dafa8ccc","modified":1591170602612},{"_id":"public/2017/12/03/NodeJs学习笔记1/index.html","hash":"be3b24a38a10a6aa2d28af4eff0297272c249b5e","modified":1591170602612},{"_id":"public/2018/07/12/webpack3(三)/index.html","hash":"7e665b3c43cae158776bbdf17801aee3d45c9054","modified":1591170602612},{"_id":"public/page/2/index.html","hash":"1be8755128ec79498b5e56db801e3b6ff837955f","modified":1591175214462},{"_id":"source/_posts/《Just-JavaScript》03-值和变量.md","hash":"8ed7402f160a265c07332ac4bff1c141d9875759","modified":1591169316833},{"_id":"public/2020/04/19/《Just-JavaScript》03-值和变量/index.html","hash":"0b894cc1ff16333b5643b8aa7942a15309e16375","modified":1587293412760},{"_id":"source/_posts/《Just-JavaScript》04-计算数值.md","hash":"ca1e8f3a3f515f7a26133d062286ed13436399a8","modified":1591168489973},{"_id":"source/_posts/《Just-JavaScript》05.-计算数值2.md","hash":"99c263c29c32343cf4c91882aa44f0ce76fffcd7","modified":1591170847796},{"_id":"public/archives/2020/05/index.html","hash":"19ff9fbd24974427cdd74f4d8b318e52de093889","modified":1591175214462},{"_id":"public/2020/05/18/《Just-JavaScript》05.-计算数值2/index.html","hash":"52d714fe95e757dc6f2f9d00b057a6b85fb43e60","modified":1591170859394},{"_id":"public/2020/04/15/《Just-JavaScript》04-计算数值/index.html","hash":"fe2624fa797e00dddee78208e468bf4709a2bbde","modified":1591170896226},{"_id":"public/2020/03/31/《Just-JavaScript》03-值和变量/index.html","hash":"e3aa16291ebd4478ba9e9b12205756910d6decd0","modified":1591169266970},{"_id":"themes/brewski/.gitignore","hash":"cf4e2dcaa760ff6f7520fd032ce44574e2970e54","modified":1591165041296},{"_id":"themes/brewski/LICENSE","hash":"2ee70a776a9601838491fe10a923bdae780bf0c5","modified":1591165041296},{"_id":"themes/brewski/README.md","hash":"b9580a3462769a3599ac565e80988874af47ce1f","modified":1591165041297},{"_id":"themes/brewski/_config.yml","hash":"4607dc3c03585f4ebd07e1e988c8b3cc9fcc7495","modified":1591165041297},{"_id":"themes/brewski/package.json","hash":"72193f3b92facc47a782c97df33be560e0356ebe","modified":1591165041299},{"_id":"themes/brewski/renovate.json","hash":"cb29cc16e61b0b8a6dac34657d76822ae29ad5aa","modified":1591165041299},{"_id":"themes/brewski/languages/en.yml","hash":"a051627490d38b064790d20be59dceb9a4cb2752","modified":1591165041297},{"_id":"themes/brewski/layout/index.pug","hash":"52fd4433e7b170c0ed9813173714d55e7d5fa016","modified":1591165041297},{"_id":"themes/brewski/layout/archive.pug","hash":"86aa3e23c4fb1ae2633c315bf6901fd2ed95be8f","modified":1591165041297},{"_id":"themes/brewski/layout/page.pug","hash":"392f539c05d09725e5aa4bb0e4a784a1ffe217b0","modified":1591165041298},{"_id":"themes/brewski/layout/post.pug","hash":"2db8305d6f3b1f07c4fc92be47e179779c12ec49","modified":1591165041298},{"_id":"themes/brewski/source/logo.svg","hash":"cfdd3811fddcf6a48508d9c79bbbc806baa5bff8","modified":1591165041299},{"_id":"themes/brewski/source/favicon.svg","hash":"fc8c6c0cc8ac99438b421d906ba406a965be85d8","modified":1591165041299},{"_id":"themes/brewski/layout/partial/comment.pug","hash":"fb44642e6f16fac62c05c79eeea50284bfa293f6","modified":1591165041298},{"_id":"themes/brewski/layout/mixins/paginator.pug","hash":"4bf911d0e391ed1ef35673fc87b1293f7d07e850","modified":1591165041297},{"_id":"themes/brewski/layout/mixins/post.pug","hash":"1f148ad4e8ab19a5132d60fa5b359e7c731ee9b3","modified":1591165041297},{"_id":"themes/brewski/layout/partial/layout.pug","hash":"0a7e0e1ce355d0f2bef68a001bf0c3bd5bf618ac","modified":1591165041298},{"_id":"themes/brewski/layout/partial/head.pug","hash":"ee926061803c2c0c49ab452fab1105e6ffe49740","modified":1591165041298},{"_id":"themes/brewski/layout/partial/copyright.pug","hash":"ff23c319e11c016f5dbf67c9ab5e7fea7d6e131c","modified":1591165041298},{"_id":"themes/brewski/layout/partial/nav.pug","hash":"b7bce3961077f656de8388121d66e63eb837280b","modified":1591165041298},{"_id":"themes/brewski/layout/partial/scripts.pug","hash":"b2ac6a612d498cb2019f056f1e7874bf405d03cf","modified":1591165041298},{"_id":"themes/brewski/source/css/theme.css","hash":"cd506f41ad2ec16935da932712871c3290d6e0d1","modified":1591165041299},{"_id":"public/favicon.svg","hash":"fc8c6c0cc8ac99438b421d906ba406a965be85d8","modified":1591169478050},{"_id":"public/logo.svg","hash":"cfdd3811fddcf6a48508d9c79bbbc806baa5bff8","modified":1591167351072},{"_id":"public/css/theme.css","hash":"cd506f41ad2ec16935da932712871c3290d6e0d1","modified":1591167351072},{"_id":"public/atom.xml","hash":"8ea19793b745e06d7bb0899403780736e2cdadfd","modified":1591175214462},{"_id":"public/sitemap.xml","hash":"e2a29e633f9a4be7e77e3f7e5c8924100874f9c7","modified":1591175214462},{"_id":"themes/iLiKE/LICENSE","hash":"574dd9612d1ac8f8eb021b38bedc378745054f9b","modified":1591166479053},{"_id":"themes/iLiKE/README.md","hash":"77d8087410063f7a9898094686d3be658c7ee0d6","modified":1591166479053},{"_id":"themes/iLiKE/_config.yml","hash":"d86c85a03bb184d026867ac153a04ec0d95bb2ca","modified":1591169468106},{"_id":"themes/iLiKE/languages/en.yml","hash":"fb16c093569171bc1c812d1db2c5ab5279e32b07","modified":1591166479053},{"_id":"themes/iLiKE/languages/ja.yml","hash":"fb13c0da2a155f32a352b097157c9571beb5b976","modified":1591166479053},{"_id":"themes/iLiKE/languages/ko.yml","hash":"6585f0e32d028545cebf7112b57e743023dbabf6","modified":1591166479054},{"_id":"themes/iLiKE/languages/ru.yml","hash":"c3ad4fa0e45e0a957aa5849416561740bb14fc26","modified":1591166479054},{"_id":"themes/iLiKE/languages/zh-TW.yml","hash":"a83a73a8156605f353a30e3e597408aeeb170383","modified":1591166479054},{"_id":"themes/iLiKE/layout/archive.ejs","hash":"4de60672fbac428f5a076a57e669cebc57c853ba","modified":1591166479054},{"_id":"themes/iLiKE/languages/zh-CN.yml","hash":"29f8ac66123266f73d10710872497f2907691372","modified":1591166479054},{"_id":"themes/iLiKE/layout/category.ejs","hash":"5a86afae1b2e7598f953248d6892ad6c8f4d860a","modified":1591166479054},{"_id":"themes/iLiKE/layout/index.ejs","hash":"33292a0593e9bff8a253ee01dfb433a4f934c6c5","modified":1591166479054},{"_id":"themes/iLiKE/layout/page.ejs","hash":"7a87354d9375c50c72f25b7cfc5bf0345c19265e","modified":1591166479055},{"_id":"themes/iLiKE/layout/layout.ejs","hash":"b4bb22cfc8ef397c68c5bcce857ae946de9fd62a","modified":1591166479055},{"_id":"themes/iLiKE/layout/post.ejs","hash":"91cd8f310e9c125785fac63947fe64d941ac45fe","modified":1591166479056},{"_id":"themes/iLiKE/layout/tag.ejs","hash":"529edd9b41c37f42ea01321bfb38a7efe6e1b75f","modified":1591166479056},{"_id":"themes/iLiKE/source/favicon.ico","hash":"96b9a549337c2bec483c2879eeafa4d1f8748fed","modified":1591166479058},{"_id":"themes/iLiKE/source/js/iLiKE.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1591166479064},{"_id":"themes/iLiKE/layout/partials/article.ejs","hash":"925941f255d5173332bdaed71a8afdc7b2c95f22","modified":1591166479055},{"_id":"themes/iLiKE/layout/partials/footer.ejs","hash":"4e7363084eab0c6309f0697a35fd2985d9cfd665","modified":1591170199447},{"_id":"themes/iLiKE/layout/partials/counter.ejs","hash":"240622143d1971ce9387c8f2389abf059d2e2ea3","modified":1591166479055},{"_id":"themes/iLiKE/layout/partials/head.ejs","hash":"82b40762955f2918e517f06427f51fd0674a9971","modified":1591170406076},{"_id":"themes/iLiKE/layout/partials/header.ejs","hash":"2aece428b4d2f0e91c8e6914ecdfe93855c5dc73","modified":1591166479055},{"_id":"themes/iLiKE/layout/partials/paginator.ejs","hash":"9ca74e2fe81aa14a9362dec9ab6e32811eeda9b9","modified":1591166479056},{"_id":"themes/iLiKE/layout/partials/recent-posts.ejs","hash":"f7889c43f4830fc0c91eb7fd47269980218a6ba3","modified":1591166479056},{"_id":"themes/iLiKE/layout/partials/social.ejs","hash":"d5507bb8e6306998ec48e1599f55808cbce3f21e","modified":1591170598947},{"_id":"themes/iLiKE/source/css/archives.styl","hash":"a9c16f9a85a17ad47f5cd05c63a99c194a9aac1e","modified":1591166479057},{"_id":"themes/iLiKE/source/css/article.styl","hash":"f8146f30615dc781d8be4640a60c4fd825460ea2","modified":1591166479057},{"_id":"themes/iLiKE/source/css/footer.styl","hash":"43e84c14327419af11fbbb9c95a0f1335242bae0","modified":1591170292527},{"_id":"themes/iLiKE/source/css/header.styl","hash":"9ab993db59221a639cec72f65ab4978300f6ba41","modified":1591166479057},{"_id":"themes/iLiKE/source/css/heighlight.styl","hash":"fb4a84080d82f70095fcda8bfcbdd807d8694105","modified":1591166479057},{"_id":"themes/iLiKE/source/css/iLiKE.styl","hash":"6c8c7070c89d426803a82d290965393a738fb30f","modified":1591166479057},{"_id":"themes/iLiKE/source/css/list.styl","hash":"a6dbca36c83d001cebba6ed5f213b921fa19b82b","modified":1591166479057},{"_id":"themes/iLiKE/source/css/pagenator.styl","hash":"a198bd69e63ddcf380c5860780d377b08b69dae4","modified":1591166479057},{"_id":"themes/iLiKE/source/css/social.styl","hash":"0d2d3fd1b77a9d06655c26d3a08adf347bdd2c98","modified":1591166479058},{"_id":"themes/iLiKE/source/image/douban.png","hash":"2e35ecf810a67b87cbdd6b07ca201aca0431a1de","modified":1591166479060},{"_id":"themes/iLiKE/source/image/email.png","hash":"bc3e6cbf5e02d893c361ada7ca150f46adc29427","modified":1591166479060},{"_id":"themes/iLiKE/source/image/facebook.png","hash":"fc9b47c085a0934c4ce736373dc4c345795ced87","modified":1591166479060},{"_id":"themes/iLiKE/source/image/github.png","hash":"8f790f109041d18eeca60c143fed690ceb144798","modified":1591166479061},{"_id":"themes/iLiKE/source/image/google.png","hash":"bd7393e39e99f52acb6573338a347f31426554a6","modified":1591166479061},{"_id":"themes/iLiKE/source/image/instagram.png","hash":"a45c7e8b27e3d8d15dcbf7a02f0b8250e34628ab","modified":1591166479061},{"_id":"themes/iLiKE/source/image/jianshu.png","hash":"f41fce0ef0abc9f6c9073c7cb6260d706ae64859","modified":1591166479061},{"_id":"themes/iLiKE/source/image/linkedin.png","hash":"84d7e0deb82a1a49fba3343c32127a17024538f1","modified":1591166479061},{"_id":"themes/iLiKE/source/image/pocket.png","hash":"7d24ef0dd4c94ed29317cf5c8f9dd7ca300ad991","modified":1591166479062},{"_id":"themes/iLiKE/source/image/stack-overflow.png","hash":"b4f0371659ec6b005eb5938401b35122e32b2509","modified":1591166479063},{"_id":"themes/iLiKE/source/image/tumblr.png","hash":"d35b6c2646ca1393ba8c572c47aa68c5b3923544","modified":1591166479063},{"_id":"themes/iLiKE/source/image/twitter.png","hash":"4595f3aead466b685987d56f4bb7dbf224a57c56","modified":1591166479063},{"_id":"themes/iLiKE/source/image/weibo.png","hash":"f9e49f7337c42dd1a611994b917e67f9325e68cb","modified":1591166479064},{"_id":"themes/iLiKE/source/image/zhihu.png","hash":"4e6e90aab703f9f70bbc6404c69768afe434b186","modified":1591166479064},{"_id":"themes/iLiKE/source/image/Hexo.png","hash":"ed62c12c927dd82a141ebd318db98210ab008ad5","modified":1591166479060},{"_id":"public/favicon.ico","hash":"96b9a549337c2bec483c2879eeafa4d1f8748fed","modified":1591167853540},{"_id":"public/image/douban.png","hash":"2e35ecf810a67b87cbdd6b07ca201aca0431a1de","modified":1591167853540},{"_id":"public/image/email.png","hash":"bc3e6cbf5e02d893c361ada7ca150f46adc29427","modified":1591167853540},{"_id":"public/image/facebook.png","hash":"fc9b47c085a0934c4ce736373dc4c345795ced87","modified":1591167853540},{"_id":"public/image/github.png","hash":"8f790f109041d18eeca60c143fed690ceb144798","modified":1591167853540},{"_id":"public/image/google.png","hash":"bd7393e39e99f52acb6573338a347f31426554a6","modified":1591167853540},{"_id":"public/image/instagram.png","hash":"a45c7e8b27e3d8d15dcbf7a02f0b8250e34628ab","modified":1591167853540},{"_id":"public/image/jianshu.png","hash":"f41fce0ef0abc9f6c9073c7cb6260d706ae64859","modified":1591167853540},{"_id":"public/image/linkedin.png","hash":"84d7e0deb82a1a49fba3343c32127a17024538f1","modified":1591167853540},{"_id":"public/image/pocket.png","hash":"7d24ef0dd4c94ed29317cf5c8f9dd7ca300ad991","modified":1591167853540},{"_id":"public/image/stack-overflow.png","hash":"b4f0371659ec6b005eb5938401b35122e32b2509","modified":1591167853540},{"_id":"public/image/tumblr.png","hash":"d35b6c2646ca1393ba8c572c47aa68c5b3923544","modified":1591167853540},{"_id":"public/image/twitter.png","hash":"4595f3aead466b685987d56f4bb7dbf224a57c56","modified":1591167853540},{"_id":"public/image/weibo.png","hash":"f9e49f7337c42dd1a611994b917e67f9325e68cb","modified":1591167853540},{"_id":"public/image/zhihu.png","hash":"4e6e90aab703f9f70bbc6404c69768afe434b186","modified":1591167853540},{"_id":"public/js/iLiKE.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1591167853540},{"_id":"public/css/archives.css","hash":"ab85e90b222bce53bc21869d4b48877bdd1ae06f","modified":1591167853540},{"_id":"public/css/article.css","hash":"5ed049f184ddb716a2a8a35a211b1bf2c8fc354b","modified":1591167853540},{"_id":"public/css/header.css","hash":"40434e246822f32b671d9deef99d3dc14c72adad","modified":1591167853540},{"_id":"public/css/footer.css","hash":"8a81ba6b46b46b64dad22cf6ba73d615d878ab84","modified":1591170296111},{"_id":"public/css/heighlight.css","hash":"83ee34699bc03c7cb5b561a3a9283d439c151bf2","modified":1591167853540},{"_id":"public/css/iLiKE.css","hash":"e78d042d1046686b51ef184643978d4b4805a011","modified":1591167853540},{"_id":"public/css/pagenator.css","hash":"325764f0769b28fe3c2b268ace68479ec609d06c","modified":1591167853540},{"_id":"public/css/list.css","hash":"83b1026bbdcc0da85cd87d765abe3e0463b390f2","modified":1591167853540},{"_id":"public/css/social.css","hash":"0f09780c9ad2a78deb871b6598c0b30c8092ae00","modified":1591167853540},{"_id":"public/image/Hexo.png","hash":"ed62c12c927dd82a141ebd318db98210ab008ad5","modified":1591167853540},{"_id":"public/page/3/index.html","hash":"30e64c5b49372069cb14dc83217f0fa93c75894d","modified":1591170602612},{"_id":"public/page/4/index.html","hash":"2b37a0e86ea846b85d74270cb543844cfa4bbbf3","modified":1591170602612},{"_id":"themes/iLiKE/.DS_Store","hash":"9457f542cf2c3f2a50b9ecd64858fc6f50b0d0c4","modified":1591167402489},{"_id":"themes/iLiKE/source/favicon.svg","hash":"fc8c6c0cc8ac99438b421d906ba406a965be85d8","modified":1591167352421},{"_id":"themes/iLiKE/source/.DS_Store","hash":"83aa45c7764fd31b138dd0a55f9ae22a142de430","modified":1591167413135},{"_id":"public/2020/03/28/《Just-JavaScript》01-思维模型/index.html","hash":"4f76d476bc181716518c7d05747a1ce423db170c","modified":1591170602612},{"_id":"public/2020/03/31/《Just-JavaScript》02-JavaScript宇宙/index.html","hash":"ce9ed047baf31a09db11046b4ef5f476ff0bb62a","modified":1591170602612},{"_id":"public/2020/04/01/《Just-JavaScript》03-值和变量/index.html","hash":"8dc3ff326afd10af48258ba4b62efcc6158af34d","modified":1591170602612},{"_id":"source/_posts/《Just-JavaScript》05-计算数值2.md","hash":"115f533ef23bfff0b63c06a62ca411835ecc271d","modified":1591174736533},{"_id":"public/2020/05/18/《Just-JavaScript》05-计算数值2/index.html","hash":"42531f3fe8a6f27a314f3fd92d87d2bb6e6a591c","modified":1591174741361}],"Category":[{"name":"JavaScript","_id":"ck8gofbcc0006hk9h9zrp5fmm"},{"name":"fetch","_id":"ck8gofbcg000ahk9hgfijf3kt"},{"name":"gulp","_id":"ck8gofbck000fhk9h6uig4i6v"},{"name":"node","_id":"ck8gofbck000ihk9hbp2l2j7a"},{"name":"webpack","_id":"ck8gofbco000nhk9h1zi81res"},{"name":"ajax","_id":"ck8gofbcq000shk9hh2m87u26"},{"name":"计算机基础","_id":"ck8gofbcu000yhk9h59v5bvzz"}],"Data":[],"Page":[],"Post":[{"title":"Fetch学习笔记","date":"2018-02-10T07:21:08.000Z","_content":"\n# 什么是Fetch\n\n&emsp;  Fetch 是浏览器提供的原生AJAX接口。由于原来的XMLHttpRequest不符合关注分离原则，且基于事件的模型在处理异步上已经没有现代的Promise等那么有优势。因此Fetch出现来解决这种问题。\n\n&emsp;  [Fetch API ](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)提供了能够用于操作一部分 HTTP 的 JavaScript 接口，比如 requests 和 responses。它同时也提供了一个全局的 fetch() 方法——能够简单的异步的获取资源。 \n\n## 1. 简单示例\n``` Fetch\nfetch(\"/data.json\").then(function(res) {\n  // res instanceof Response == true.\n  if (res.ok) {\n    res.json().then(function(data) {\n      console.log(data.entries);\n    });\n  } else {\n    console.log(\"Looks like the response wasn't perfect, got status\", res.status);\n  }\n}, function(e) {\n  console.log(\"Fetch failed!\", e);\n});\n```\n如果是提交一个POST请求，代码如下：\n``` post请求\nfetch(\"http://www.example.org/submit.php\", {\n  method: \"POST\",\n  headers: {\n    \"Content-Type\": \"application/x-www-form-urlencoded\"\n  },\n  body: \"firstName=Nikhil&favColor=blue&password=easytoguess\"\n}).then(function(res) {\n  if (res.ok) {\n    alert(\"Perfect! Your settings are saved.\");\n  } else if (res.status == 401) {\n    alert(\"Oops! You are not authorized.\");\n  }\n}, function(e) {\n  alert(\"Error submitting form!\");\n});\n```\n`fetch()` 方法的参数和 `Request()` 构造函数的参数完全一致，所以我们可以传任意复杂的参数来实现更强大的 `fetch()`。\n\n## 2. Headers\nFetch 引入了 3 个接口，分别是 `Headers`，`Request` 和 `Response`。他们直接对应于的 HTTP 中相应的概念，但是基于隐私和安全考虑，也有些区别，例如支持 CORS 规则以及保证 cookies 不能被第三方获取。\n\n`Headers` 接口是一个简单的键值对：\n``` Headers 接口\nvar content = \"Hello World\";\nvar reqHeaders = new Headers();\nreqHeaders.append(\"Content-Type\", \"text/plain\");\nreqHeaders.append(\"Content-Length\", content.length.toString());\nreqHeaders.append(\"X-Custom-Header\", \"ProcessThisImmediately\");\n```\n也可以给构造函数传一个多维数组或 JS 字面量对象：\n```\nreqHeaders = new Headers({\n  \"Content-Type\": \"text/plain\",\n  \"Content-Length\": content.length.toString(),\n  \"X-Custom-Header\": \"ProcessThisImmediately\",\n});\n```\nHeaders 的内容可被检索：\n```\nconsole.log(reqHeaders.has(\"Content-Type\")); // true\nconsole.log(reqHeaders.has(\"Set-Cookie\")); // false\nreqHeaders.set(\"Content-Type\", \"text/html\");\nreqHeaders.append(\"X-Custom-Header\", \"AnotherValue\");\n \nconsole.log(reqHeaders.get(\"Content-Length\")); // 11\nconsole.log(reqHeaders.getAll(\"X-Custom-Header\")); // [\"ProcessThisImmediately\", \"AnotherValue\"]\n \nreqHeaders.delete(\"X-Custom-Header\");\nconsole.log(reqHeaders.getAll(\"X-Custom-Header\")); // []\n```\n一些操作只在 ServiceWorkers 中可用，但这些 API 使得操作 header 更为方便。\n\n由于 header 可以在发送请求时被发送或在收到响应时被接收，并规定了那些参数可写，所以在 `Headers` 对象中有个一 `guard` 属性，来指定哪些参数可以被改变。\n\n可能的值如下：\n\n - `\"none\"`：默认值\n - `\"request\"`：`Request.headers` 对象只读\n - `\"request-no-cors\"`：在 `no-cors` 模式下，`Request.headers` 对象只读\n - `\"response\"`：`Response.headers` 对象只读\n - `\"immutable\"`：通常在 ServiceWorkers 中使用，所有 Header 对象都为只读\n\n在规范中对每个 `guard` 属性值有更详细的描述。例如，当 `guard` 为 `request` 时，你将不能添加或修改`header 的 Content-Length` 属性。\n\n如果使用了一个不合法的 HTTP Header 名，那么 Headers 的方法通常都抛出 TypeError 异常。如果不小心写入了一个只读属性，也会抛出一个 TypeError 异常。除此以外，失败了将不抛出任何异常。例如：\n```\nvar res = Response.error();\ntry {\n  res.headers.set(\"Origin\", \"http://mybank.com\");\n} catch(e) {\n  console.log(\"Cannot pretend to be a bank!\");\n}\n```\n\n## 3. Request\n通过构造一个 `Request` 对象来获取网络资源，构造函数需要 `URL`、`method` 和 `headers` 参数，同时也可以提供请求体（body）、请求模式（mode）、`credentials` 和 `cache hints` 等参数。\n\n最简单的形式如下：\n```\nvar req = new Request(\"/index.html\");\nconsole.log(req.method); // \"GET\"\nconsole.log(req.url); // \"http://example.com/index.html\"\n```\n也可以将一个 `Request` 对象传给构造函数，这将返回该对象的一个副本（这与 `clone()` 方法不同，后面将介绍）。\n```\nvar copy = new Request(req);\nconsole.log(copy.method); // \"GET\"\nconsole.log(copy.url); // \"http://example.com/index.html\"\n```\n同时，这种形式通常只在 ServiceWorkers 中使用。\n\n除 `URL` 之外的参数只能通过第二个参数传递，该参数是一个键值对：\n```\nvar uploadReq = new Request(\"/uploadImage\", {\n  method: \"POST\",\n  headers: {\n    \"Content-Type\": \"image/png\",\n  },\n  body: \"image data\"\n});\n```\n`mode` 参数用来决定是否允许跨域请求，以及哪些 `response` 属性可读。可选的 `mode` 值为 `\"same-origin\"`、`\"no-cors\"`（默认）以及 `\"cors\"`。\n\n## 4. same-origin\n该模式很简单，如果一个请求是跨域的，那么将返回一个 `error`，这样确保所有的请求遵守同源策略。\n```\nvar arbitraryUrl = document.getElementById(\"url-input\").value;\nfetch(arbitraryUrl, { mode: \"same-origin\" }).then(function(res) {\n  console.log(\"Response succeeded?\", res.ok);\n}, function(e) {\n  console.log(\"Please enter a same-origin URL!\");\n});\n```\n\n## 5. no-cors\n该模式允许来自 CDN 的脚本、其他域的图片和其他一些跨域资源，但是首先有个前提条件，就是请求的 method 只能是`HEAD`、`GET` 或 `POST`。此外，如果 ServiceWorkers 拦截了这些请求，它不能随意添加或者修改除这些之外 Header 属性。第三，JS 不能访问 Response 对象中的任何属性，这确保了跨域时 ServiceWorkers 的安全和隐私信息泄漏问题。\n    \n## 6.cors\n该模式通常用于跨域请求，用来从第三方提供的 API 获取数据。该模式遵守 [CORS 协议](http://www.ruanyifeng.com/blog/2016/04/cors.html)，并只有有限的一些 Header 被暴露给 Response 对象，但是 body 是可读的。例如，获取一个 Flickr 最感兴趣的照片的清单：\n```\nvar u = new URLSearchParams();\nu.append('method', 'flickr.interestingness.getList');\nu.append('api_key', '<insert api key here>');\nu.append('format', 'json');\nu.append('nojsoncallback', '1');\n \nvar apiCall = fetch('https://api.flickr.com/services/rest?' + u);\n \napiCall.then(function(response) {\n  return response.json().then(function(json) {\n    // photo is a list of photos.\n    return json.photos.photo;\n  });\n}).then(function(photos) {\n  photos.forEach(function(photo) {\n    console.log(photo.title);\n  });\n});\n```\n我们无法从 Headers 中读取 Date 属性，因为 Flickr 在 Access-Control-Expose-Headers 中设置了不允许读取它。\n```\nresponse.headers.get(\"Date\"); // null\n```\n\n另外，`credentials` 属性决定了是否可以跨域访问 cookie 。该属性与 XHR 的\n`withCredentials` 标志相同，但是只有三个值，分别是 `omit`（默认）、`same-origin` 和 `include`。\n\n`Request` 对象也提供了客户端缓存机制（caching hints）。这个属性还在安全复审阶段。Firefox 提供了这个属性，但目前还不起作用。\n\nRequest 对象还有两个与 ServiceWorks 拦截有关的只读属性。其中一个是`referrer`，表示该 Request 的来源，可能为空。另外一个是 `context`，是一个非常大的枚举集合，定义了获得的资源的种类，它可能是 image 当请求来自于 img 标签时，可能是 worker 如果是一个 Worker 脚本，等等。如果使用 fetch() 函数，这个值是 fetch。\n\n## 7. Response\nResponse 对象通常在 `fetch()` 的回调中获得，也可以通过 JS 构造，不过这通常只在 ServiceWorkers 中使用。\n\nResponse 对象中最常见的属性是 `status`（整数，默认值是 `200`）和`statusText`（默认值是 `\"OK\"`）。还有一个 ok 属性，这是 `status` 值为 `200~299` 时的语法糖。\n\n另外，还有一个 `type` 属性，它的值可能是 `\"basic\"`、`\"cors\"`、`\"default\"`、`\"error\"` 或 `\"opaque\"`。\n\n - `\"basic\"`：同域的响应，除 `Set-Cookie` 和 `Set-Cookie` 之外的所有 Header 可用\n - `\"cors\"`：Response 从一个合法的跨域请求获得，某些 Header 和 body 可读\n - `\"error\"`：网络错误。Response 对象的 status 属性为 0，headers 属性为空并且不可写。当 `Response`对象从 `Response.error()` 中得到时，就是这种类型\n - `\"opaque\"`：在 `\"no-cors\"` 模式下请求了跨域资源。依靠服务端来做限制\n\n当 `type` 属性值为 `\"error\"` 时会导致 fetch() 方法的 `Promise` 被 `reject`，reject 回调的参数为 TypeError 对象。\n\n还有一些属性只在 ServerWorker 下有效。在 ServerWorker 下返回一个 Response 的正确方式为：\n```\naddEventListener('fetch', function(event) {\n  event.respondWith(new Response(\"Response body\", {\n    headers: { \"Content-Type\" : \"text/plain\" }\n  });\n});\n```\n正如我们所见，Response 构造函数接收两个参数：返回的 body 和一个键值对对象，通过该对象来设置 `status`、`statusText` 和 `headers` 属性。\n\n静态方法 `Response.error()` 将返回一个错误响应，`Response.redirect(url, status)` 将返回一个跳转响应。\n\n\n\n","source":"_posts/Fetch学习笔记.md","raw":"---\ntitle: Fetch学习笔记  \ndate: 2018-02-10 15:21:08  \ncategories: fetch  \ntags:\n---\n\n# 什么是Fetch\n\n&emsp;  Fetch 是浏览器提供的原生AJAX接口。由于原来的XMLHttpRequest不符合关注分离原则，且基于事件的模型在处理异步上已经没有现代的Promise等那么有优势。因此Fetch出现来解决这种问题。\n\n&emsp;  [Fetch API ](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)提供了能够用于操作一部分 HTTP 的 JavaScript 接口，比如 requests 和 responses。它同时也提供了一个全局的 fetch() 方法——能够简单的异步的获取资源。 \n\n## 1. 简单示例\n``` Fetch\nfetch(\"/data.json\").then(function(res) {\n  // res instanceof Response == true.\n  if (res.ok) {\n    res.json().then(function(data) {\n      console.log(data.entries);\n    });\n  } else {\n    console.log(\"Looks like the response wasn't perfect, got status\", res.status);\n  }\n}, function(e) {\n  console.log(\"Fetch failed!\", e);\n});\n```\n如果是提交一个POST请求，代码如下：\n``` post请求\nfetch(\"http://www.example.org/submit.php\", {\n  method: \"POST\",\n  headers: {\n    \"Content-Type\": \"application/x-www-form-urlencoded\"\n  },\n  body: \"firstName=Nikhil&favColor=blue&password=easytoguess\"\n}).then(function(res) {\n  if (res.ok) {\n    alert(\"Perfect! Your settings are saved.\");\n  } else if (res.status == 401) {\n    alert(\"Oops! You are not authorized.\");\n  }\n}, function(e) {\n  alert(\"Error submitting form!\");\n});\n```\n`fetch()` 方法的参数和 `Request()` 构造函数的参数完全一致，所以我们可以传任意复杂的参数来实现更强大的 `fetch()`。\n\n## 2. Headers\nFetch 引入了 3 个接口，分别是 `Headers`，`Request` 和 `Response`。他们直接对应于的 HTTP 中相应的概念，但是基于隐私和安全考虑，也有些区别，例如支持 CORS 规则以及保证 cookies 不能被第三方获取。\n\n`Headers` 接口是一个简单的键值对：\n``` Headers 接口\nvar content = \"Hello World\";\nvar reqHeaders = new Headers();\nreqHeaders.append(\"Content-Type\", \"text/plain\");\nreqHeaders.append(\"Content-Length\", content.length.toString());\nreqHeaders.append(\"X-Custom-Header\", \"ProcessThisImmediately\");\n```\n也可以给构造函数传一个多维数组或 JS 字面量对象：\n```\nreqHeaders = new Headers({\n  \"Content-Type\": \"text/plain\",\n  \"Content-Length\": content.length.toString(),\n  \"X-Custom-Header\": \"ProcessThisImmediately\",\n});\n```\nHeaders 的内容可被检索：\n```\nconsole.log(reqHeaders.has(\"Content-Type\")); // true\nconsole.log(reqHeaders.has(\"Set-Cookie\")); // false\nreqHeaders.set(\"Content-Type\", \"text/html\");\nreqHeaders.append(\"X-Custom-Header\", \"AnotherValue\");\n \nconsole.log(reqHeaders.get(\"Content-Length\")); // 11\nconsole.log(reqHeaders.getAll(\"X-Custom-Header\")); // [\"ProcessThisImmediately\", \"AnotherValue\"]\n \nreqHeaders.delete(\"X-Custom-Header\");\nconsole.log(reqHeaders.getAll(\"X-Custom-Header\")); // []\n```\n一些操作只在 ServiceWorkers 中可用，但这些 API 使得操作 header 更为方便。\n\n由于 header 可以在发送请求时被发送或在收到响应时被接收，并规定了那些参数可写，所以在 `Headers` 对象中有个一 `guard` 属性，来指定哪些参数可以被改变。\n\n可能的值如下：\n\n - `\"none\"`：默认值\n - `\"request\"`：`Request.headers` 对象只读\n - `\"request-no-cors\"`：在 `no-cors` 模式下，`Request.headers` 对象只读\n - `\"response\"`：`Response.headers` 对象只读\n - `\"immutable\"`：通常在 ServiceWorkers 中使用，所有 Header 对象都为只读\n\n在规范中对每个 `guard` 属性值有更详细的描述。例如，当 `guard` 为 `request` 时，你将不能添加或修改`header 的 Content-Length` 属性。\n\n如果使用了一个不合法的 HTTP Header 名，那么 Headers 的方法通常都抛出 TypeError 异常。如果不小心写入了一个只读属性，也会抛出一个 TypeError 异常。除此以外，失败了将不抛出任何异常。例如：\n```\nvar res = Response.error();\ntry {\n  res.headers.set(\"Origin\", \"http://mybank.com\");\n} catch(e) {\n  console.log(\"Cannot pretend to be a bank!\");\n}\n```\n\n## 3. Request\n通过构造一个 `Request` 对象来获取网络资源，构造函数需要 `URL`、`method` 和 `headers` 参数，同时也可以提供请求体（body）、请求模式（mode）、`credentials` 和 `cache hints` 等参数。\n\n最简单的形式如下：\n```\nvar req = new Request(\"/index.html\");\nconsole.log(req.method); // \"GET\"\nconsole.log(req.url); // \"http://example.com/index.html\"\n```\n也可以将一个 `Request` 对象传给构造函数，这将返回该对象的一个副本（这与 `clone()` 方法不同，后面将介绍）。\n```\nvar copy = new Request(req);\nconsole.log(copy.method); // \"GET\"\nconsole.log(copy.url); // \"http://example.com/index.html\"\n```\n同时，这种形式通常只在 ServiceWorkers 中使用。\n\n除 `URL` 之外的参数只能通过第二个参数传递，该参数是一个键值对：\n```\nvar uploadReq = new Request(\"/uploadImage\", {\n  method: \"POST\",\n  headers: {\n    \"Content-Type\": \"image/png\",\n  },\n  body: \"image data\"\n});\n```\n`mode` 参数用来决定是否允许跨域请求，以及哪些 `response` 属性可读。可选的 `mode` 值为 `\"same-origin\"`、`\"no-cors\"`（默认）以及 `\"cors\"`。\n\n## 4. same-origin\n该模式很简单，如果一个请求是跨域的，那么将返回一个 `error`，这样确保所有的请求遵守同源策略。\n```\nvar arbitraryUrl = document.getElementById(\"url-input\").value;\nfetch(arbitraryUrl, { mode: \"same-origin\" }).then(function(res) {\n  console.log(\"Response succeeded?\", res.ok);\n}, function(e) {\n  console.log(\"Please enter a same-origin URL!\");\n});\n```\n\n## 5. no-cors\n该模式允许来自 CDN 的脚本、其他域的图片和其他一些跨域资源，但是首先有个前提条件，就是请求的 method 只能是`HEAD`、`GET` 或 `POST`。此外，如果 ServiceWorkers 拦截了这些请求，它不能随意添加或者修改除这些之外 Header 属性。第三，JS 不能访问 Response 对象中的任何属性，这确保了跨域时 ServiceWorkers 的安全和隐私信息泄漏问题。\n    \n## 6.cors\n该模式通常用于跨域请求，用来从第三方提供的 API 获取数据。该模式遵守 [CORS 协议](http://www.ruanyifeng.com/blog/2016/04/cors.html)，并只有有限的一些 Header 被暴露给 Response 对象，但是 body 是可读的。例如，获取一个 Flickr 最感兴趣的照片的清单：\n```\nvar u = new URLSearchParams();\nu.append('method', 'flickr.interestingness.getList');\nu.append('api_key', '<insert api key here>');\nu.append('format', 'json');\nu.append('nojsoncallback', '1');\n \nvar apiCall = fetch('https://api.flickr.com/services/rest?' + u);\n \napiCall.then(function(response) {\n  return response.json().then(function(json) {\n    // photo is a list of photos.\n    return json.photos.photo;\n  });\n}).then(function(photos) {\n  photos.forEach(function(photo) {\n    console.log(photo.title);\n  });\n});\n```\n我们无法从 Headers 中读取 Date 属性，因为 Flickr 在 Access-Control-Expose-Headers 中设置了不允许读取它。\n```\nresponse.headers.get(\"Date\"); // null\n```\n\n另外，`credentials` 属性决定了是否可以跨域访问 cookie 。该属性与 XHR 的\n`withCredentials` 标志相同，但是只有三个值，分别是 `omit`（默认）、`same-origin` 和 `include`。\n\n`Request` 对象也提供了客户端缓存机制（caching hints）。这个属性还在安全复审阶段。Firefox 提供了这个属性，但目前还不起作用。\n\nRequest 对象还有两个与 ServiceWorks 拦截有关的只读属性。其中一个是`referrer`，表示该 Request 的来源，可能为空。另外一个是 `context`，是一个非常大的枚举集合，定义了获得的资源的种类，它可能是 image 当请求来自于 img 标签时，可能是 worker 如果是一个 Worker 脚本，等等。如果使用 fetch() 函数，这个值是 fetch。\n\n## 7. Response\nResponse 对象通常在 `fetch()` 的回调中获得，也可以通过 JS 构造，不过这通常只在 ServiceWorkers 中使用。\n\nResponse 对象中最常见的属性是 `status`（整数，默认值是 `200`）和`statusText`（默认值是 `\"OK\"`）。还有一个 ok 属性，这是 `status` 值为 `200~299` 时的语法糖。\n\n另外，还有一个 `type` 属性，它的值可能是 `\"basic\"`、`\"cors\"`、`\"default\"`、`\"error\"` 或 `\"opaque\"`。\n\n - `\"basic\"`：同域的响应，除 `Set-Cookie` 和 `Set-Cookie` 之外的所有 Header 可用\n - `\"cors\"`：Response 从一个合法的跨域请求获得，某些 Header 和 body 可读\n - `\"error\"`：网络错误。Response 对象的 status 属性为 0，headers 属性为空并且不可写。当 `Response`对象从 `Response.error()` 中得到时，就是这种类型\n - `\"opaque\"`：在 `\"no-cors\"` 模式下请求了跨域资源。依靠服务端来做限制\n\n当 `type` 属性值为 `\"error\"` 时会导致 fetch() 方法的 `Promise` 被 `reject`，reject 回调的参数为 TypeError 对象。\n\n还有一些属性只在 ServerWorker 下有效。在 ServerWorker 下返回一个 Response 的正确方式为：\n```\naddEventListener('fetch', function(event) {\n  event.respondWith(new Response(\"Response body\", {\n    headers: { \"Content-Type\" : \"text/plain\" }\n  });\n});\n```\n正如我们所见，Response 构造函数接收两个参数：返回的 body 和一个键值对对象，通过该对象来设置 `status`、`statusText` 和 `headers` 属性。\n\n静态方法 `Response.error()` 将返回一个错误响应，`Response.redirect(url, status)` 将返回一个跳转响应。\n\n\n\n","slug":"Fetch学习笔记","published":1,"updated":"2020-04-01T02:15:52.390Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8gp7rxg0000kb9h6rln9esb","content":"<h1 id=\"什么是Fetch\"><a href=\"#什么是Fetch\" class=\"headerlink\" title=\"什么是Fetch\"></a>什么是Fetch</h1><p>&emsp;  Fetch 是浏览器提供的原生AJAX接口。由于原来的XMLHttpRequest不符合关注分离原则，且基于事件的模型在处理异步上已经没有现代的Promise等那么有优势。因此Fetch出现来解决这种问题。</p>\n<p>&emsp;  <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\" target=\"_blank\" rel=\"noopener\">Fetch API </a>提供了能够用于操作一部分 HTTP 的 JavaScript 接口，比如 requests 和 responses。它同时也提供了一个全局的 fetch() 方法——能够简单的异步的获取资源。 </p>\n<h2 id=\"1-简单示例\"><a href=\"#1-简单示例\" class=\"headerlink\" title=\"1. 简单示例\"></a>1. 简单示例</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(&quot;&#x2F;data.json&quot;).then(function(res) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; res instanceof Response &#x3D;&#x3D; true.</span><br><span class=\"line\">  if (res.ok) &#123;</span><br><span class=\"line\">    res.json().then(function(data) &#123;</span><br><span class=\"line\">      console.log(data.entries);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    console.log(&quot;Looks like the response wasn&#39;t perfect, got status&quot;, res.status);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, function(e) &#123;</span><br><span class=\"line\">  console.log(&quot;Fetch failed!&quot;, e);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>如果是提交一个POST请求，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(&quot;http:&#x2F;&#x2F;www.example.org&#x2F;submit.php&quot;, &#123;</span><br><span class=\"line\">  method: &quot;POST&quot;,</span><br><span class=\"line\">  headers: &#123;</span><br><span class=\"line\">    &quot;Content-Type&quot;: &quot;application&#x2F;x-www-form-urlencoded&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  body: &quot;firstName&#x3D;Nikhil&amp;favColor&#x3D;blue&amp;password&#x3D;easytoguess&quot;</span><br><span class=\"line\">&#125;).then(function(res) &#123;</span><br><span class=\"line\">  if (res.ok) &#123;</span><br><span class=\"line\">    alert(&quot;Perfect! Your settings are saved.&quot;);</span><br><span class=\"line\">  &#125; else if (res.status &#x3D;&#x3D; 401) &#123;</span><br><span class=\"line\">    alert(&quot;Oops! You are not authorized.&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, function(e) &#123;</span><br><span class=\"line\">  alert(&quot;Error submitting form!&quot;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>fetch()</code> 方法的参数和 <code>Request()</code> 构造函数的参数完全一致，所以我们可以传任意复杂的参数来实现更强大的 <code>fetch()</code>。</p>\n<h2 id=\"2-Headers\"><a href=\"#2-Headers\" class=\"headerlink\" title=\"2. Headers\"></a>2. Headers</h2><p>Fetch 引入了 3 个接口，分别是 <code>Headers</code>，<code>Request</code> 和 <code>Response</code>。他们直接对应于的 HTTP 中相应的概念，但是基于隐私和安全考虑，也有些区别，例如支持 CORS 规则以及保证 cookies 不能被第三方获取。</p>\n<p><code>Headers</code> 接口是一个简单的键值对：</p>\n<figure class=\"highlight plain\"><figcaption><span>接口</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var content &#x3D; &quot;Hello World&quot;;</span><br><span class=\"line\">var reqHeaders &#x3D; new Headers();</span><br><span class=\"line\">reqHeaders.append(&quot;Content-Type&quot;, &quot;text&#x2F;plain&quot;);</span><br><span class=\"line\">reqHeaders.append(&quot;Content-Length&quot;, content.length.toString());</span><br><span class=\"line\">reqHeaders.append(&quot;X-Custom-Header&quot;, &quot;ProcessThisImmediately&quot;);</span><br></pre></td></tr></table></figure>\n<p>也可以给构造函数传一个多维数组或 JS 字面量对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reqHeaders &#x3D; new Headers(&#123;</span><br><span class=\"line\">  &quot;Content-Type&quot;: &quot;text&#x2F;plain&quot;,</span><br><span class=\"line\">  &quot;Content-Length&quot;: content.length.toString(),</span><br><span class=\"line\">  &quot;X-Custom-Header&quot;: &quot;ProcessThisImmediately&quot;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Headers 的内容可被检索：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(reqHeaders.has(&quot;Content-Type&quot;)); &#x2F;&#x2F; true</span><br><span class=\"line\">console.log(reqHeaders.has(&quot;Set-Cookie&quot;)); &#x2F;&#x2F; false</span><br><span class=\"line\">reqHeaders.set(&quot;Content-Type&quot;, &quot;text&#x2F;html&quot;);</span><br><span class=\"line\">reqHeaders.append(&quot;X-Custom-Header&quot;, &quot;AnotherValue&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(reqHeaders.get(&quot;Content-Length&quot;)); &#x2F;&#x2F; 11</span><br><span class=\"line\">console.log(reqHeaders.getAll(&quot;X-Custom-Header&quot;)); &#x2F;&#x2F; [&quot;ProcessThisImmediately&quot;, &quot;AnotherValue&quot;]</span><br><span class=\"line\"> </span><br><span class=\"line\">reqHeaders.delete(&quot;X-Custom-Header&quot;);</span><br><span class=\"line\">console.log(reqHeaders.getAll(&quot;X-Custom-Header&quot;)); &#x2F;&#x2F; []</span><br></pre></td></tr></table></figure>\n<p>一些操作只在 ServiceWorkers 中可用，但这些 API 使得操作 header 更为方便。</p>\n<p>由于 header 可以在发送请求时被发送或在收到响应时被接收，并规定了那些参数可写，所以在 <code>Headers</code> 对象中有个一 <code>guard</code> 属性，来指定哪些参数可以被改变。</p>\n<p>可能的值如下：</p>\n<ul>\n<li><code>&quot;none&quot;</code>：默认值</li>\n<li><code>&quot;request&quot;</code>：<code>Request.headers</code> 对象只读</li>\n<li><code>&quot;request-no-cors&quot;</code>：在 <code>no-cors</code> 模式下，<code>Request.headers</code> 对象只读</li>\n<li><code>&quot;response&quot;</code>：<code>Response.headers</code> 对象只读</li>\n<li><code>&quot;immutable&quot;</code>：通常在 ServiceWorkers 中使用，所有 Header 对象都为只读</li>\n</ul>\n<p>在规范中对每个 <code>guard</code> 属性值有更详细的描述。例如，当 <code>guard</code> 为 <code>request</code> 时，你将不能添加或修改<code>header 的 Content-Length</code> 属性。</p>\n<p>如果使用了一个不合法的 HTTP Header 名，那么 Headers 的方法通常都抛出 TypeError 异常。如果不小心写入了一个只读属性，也会抛出一个 TypeError 异常。除此以外，失败了将不抛出任何异常。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var res &#x3D; Response.error();</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">  res.headers.set(&quot;Origin&quot;, &quot;http:&#x2F;&#x2F;mybank.com&quot;);</span><br><span class=\"line\">&#125; catch(e) &#123;</span><br><span class=\"line\">  console.log(&quot;Cannot pretend to be a bank!&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-Request\"><a href=\"#3-Request\" class=\"headerlink\" title=\"3. Request\"></a>3. Request</h2><p>通过构造一个 <code>Request</code> 对象来获取网络资源，构造函数需要 <code>URL</code>、<code>method</code> 和 <code>headers</code> 参数，同时也可以提供请求体（body）、请求模式（mode）、<code>credentials</code> 和 <code>cache hints</code> 等参数。</p>\n<p>最简单的形式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var req &#x3D; new Request(&quot;&#x2F;index.html&quot;);</span><br><span class=\"line\">console.log(req.method); &#x2F;&#x2F; &quot;GET&quot;</span><br><span class=\"line\">console.log(req.url); &#x2F;&#x2F; &quot;http:&#x2F;&#x2F;example.com&#x2F;index.html&quot;</span><br></pre></td></tr></table></figure>\n<p>也可以将一个 <code>Request</code> 对象传给构造函数，这将返回该对象的一个副本（这与 <code>clone()</code> 方法不同，后面将介绍）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var copy &#x3D; new Request(req);</span><br><span class=\"line\">console.log(copy.method); &#x2F;&#x2F; &quot;GET&quot;</span><br><span class=\"line\">console.log(copy.url); &#x2F;&#x2F; &quot;http:&#x2F;&#x2F;example.com&#x2F;index.html&quot;</span><br></pre></td></tr></table></figure>\n<p>同时，这种形式通常只在 ServiceWorkers 中使用。</p>\n<p>除 <code>URL</code> 之外的参数只能通过第二个参数传递，该参数是一个键值对：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var uploadReq &#x3D; new Request(&quot;&#x2F;uploadImage&quot;, &#123;</span><br><span class=\"line\">  method: &quot;POST&quot;,</span><br><span class=\"line\">  headers: &#123;</span><br><span class=\"line\">    &quot;Content-Type&quot;: &quot;image&#x2F;png&quot;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  body: &quot;image data&quot;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>mode</code> 参数用来决定是否允许跨域请求，以及哪些 <code>response</code> 属性可读。可选的 <code>mode</code> 值为 <code>&quot;same-origin&quot;</code>、<code>&quot;no-cors&quot;</code>（默认）以及 <code>&quot;cors&quot;</code>。</p>\n<h2 id=\"4-same-origin\"><a href=\"#4-same-origin\" class=\"headerlink\" title=\"4. same-origin\"></a>4. same-origin</h2><p>该模式很简单，如果一个请求是跨域的，那么将返回一个 <code>error</code>，这样确保所有的请求遵守同源策略。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arbitraryUrl &#x3D; document.getElementById(&quot;url-input&quot;).value;</span><br><span class=\"line\">fetch(arbitraryUrl, &#123; mode: &quot;same-origin&quot; &#125;).then(function(res) &#123;</span><br><span class=\"line\">  console.log(&quot;Response succeeded?&quot;, res.ok);</span><br><span class=\"line\">&#125;, function(e) &#123;</span><br><span class=\"line\">  console.log(&quot;Please enter a same-origin URL!&quot;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-no-cors\"><a href=\"#5-no-cors\" class=\"headerlink\" title=\"5. no-cors\"></a>5. no-cors</h2><p>该模式允许来自 CDN 的脚本、其他域的图片和其他一些跨域资源，但是首先有个前提条件，就是请求的 method 只能是<code>HEAD</code>、<code>GET</code> 或 <code>POST</code>。此外，如果 ServiceWorkers 拦截了这些请求，它不能随意添加或者修改除这些之外 Header 属性。第三，JS 不能访问 Response 对象中的任何属性，这确保了跨域时 ServiceWorkers 的安全和隐私信息泄漏问题。</p>\n<h2 id=\"6-cors\"><a href=\"#6-cors\" class=\"headerlink\" title=\"6.cors\"></a>6.cors</h2><p>该模式通常用于跨域请求，用来从第三方提供的 API 获取数据。该模式遵守 <a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"noopener\">CORS 协议</a>，并只有有限的一些 Header 被暴露给 Response 对象，但是 body 是可读的。例如，获取一个 Flickr 最感兴趣的照片的清单：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var u &#x3D; new URLSearchParams();</span><br><span class=\"line\">u.append(&#39;method&#39;, &#39;flickr.interestingness.getList&#39;);</span><br><span class=\"line\">u.append(&#39;api_key&#39;, &#39;&lt;insert api key here&gt;&#39;);</span><br><span class=\"line\">u.append(&#39;format&#39;, &#39;json&#39;);</span><br><span class=\"line\">u.append(&#39;nojsoncallback&#39;, &#39;1&#39;);</span><br><span class=\"line\"> </span><br><span class=\"line\">var apiCall &#x3D; fetch(&#39;https:&#x2F;&#x2F;api.flickr.com&#x2F;services&#x2F;rest?&#39; + u);</span><br><span class=\"line\"> </span><br><span class=\"line\">apiCall.then(function(response) &#123;</span><br><span class=\"line\">  return response.json().then(function(json) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; photo is a list of photos.</span><br><span class=\"line\">    return json.photos.photo;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;).then(function(photos) &#123;</span><br><span class=\"line\">  photos.forEach(function(photo) &#123;</span><br><span class=\"line\">    console.log(photo.title);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>我们无法从 Headers 中读取 Date 属性，因为 Flickr 在 Access-Control-Expose-Headers 中设置了不允许读取它。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.headers.get(&quot;Date&quot;); &#x2F;&#x2F; null</span><br></pre></td></tr></table></figure>\n\n<p>另外，<code>credentials</code> 属性决定了是否可以跨域访问 cookie 。该属性与 XHR 的<br><code>withCredentials</code> 标志相同，但是只有三个值，分别是 <code>omit</code>（默认）、<code>same-origin</code> 和 <code>include</code>。</p>\n<p><code>Request</code> 对象也提供了客户端缓存机制（caching hints）。这个属性还在安全复审阶段。Firefox 提供了这个属性，但目前还不起作用。</p>\n<p>Request 对象还有两个与 ServiceWorks 拦截有关的只读属性。其中一个是<code>referrer</code>，表示该 Request 的来源，可能为空。另外一个是 <code>context</code>，是一个非常大的枚举集合，定义了获得的资源的种类，它可能是 image 当请求来自于 img 标签时，可能是 worker 如果是一个 Worker 脚本，等等。如果使用 fetch() 函数，这个值是 fetch。</p>\n<h2 id=\"7-Response\"><a href=\"#7-Response\" class=\"headerlink\" title=\"7. Response\"></a>7. Response</h2><p>Response 对象通常在 <code>fetch()</code> 的回调中获得，也可以通过 JS 构造，不过这通常只在 ServiceWorkers 中使用。</p>\n<p>Response 对象中最常见的属性是 <code>status</code>（整数，默认值是 <code>200</code>）和<code>statusText</code>（默认值是 <code>&quot;OK&quot;</code>）。还有一个 ok 属性，这是 <code>status</code> 值为 <code>200~299</code> 时的语法糖。</p>\n<p>另外，还有一个 <code>type</code> 属性，它的值可能是 <code>&quot;basic&quot;</code>、<code>&quot;cors&quot;</code>、<code>&quot;default&quot;</code>、<code>&quot;error&quot;</code> 或 <code>&quot;opaque&quot;</code>。</p>\n<ul>\n<li><code>&quot;basic&quot;</code>：同域的响应，除 <code>Set-Cookie</code> 和 <code>Set-Cookie</code> 之外的所有 Header 可用</li>\n<li><code>&quot;cors&quot;</code>：Response 从一个合法的跨域请求获得，某些 Header 和 body 可读</li>\n<li><code>&quot;error&quot;</code>：网络错误。Response 对象的 status 属性为 0，headers 属性为空并且不可写。当 <code>Response</code>对象从 <code>Response.error()</code> 中得到时，就是这种类型</li>\n<li><code>&quot;opaque&quot;</code>：在 <code>&quot;no-cors&quot;</code> 模式下请求了跨域资源。依靠服务端来做限制</li>\n</ul>\n<p>当 <code>type</code> 属性值为 <code>&quot;error&quot;</code> 时会导致 fetch() 方法的 <code>Promise</code> 被 <code>reject</code>，reject 回调的参数为 TypeError 对象。</p>\n<p>还有一些属性只在 ServerWorker 下有效。在 ServerWorker 下返回一个 Response 的正确方式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addEventListener(&#39;fetch&#39;, function(event) &#123;</span><br><span class=\"line\">  event.respondWith(new Response(&quot;Response body&quot;, &#123;</span><br><span class=\"line\">    headers: &#123; &quot;Content-Type&quot; : &quot;text&#x2F;plain&quot; &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>正如我们所见，Response 构造函数接收两个参数：返回的 body 和一个键值对对象，通过该对象来设置 <code>status</code>、<code>statusText</code> 和 <code>headers</code> 属性。</p>\n<p>静态方法 <code>Response.error()</code> 将返回一个错误响应，<code>Response.redirect(url, status)</code> 将返回一个跳转响应。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是Fetch\"><a href=\"#什么是Fetch\" class=\"headerlink\" title=\"什么是Fetch\"></a>什么是Fetch</h1><p>&emsp;  Fetch 是浏览器提供的原生AJAX接口。由于原来的XMLHttpRequest不符合关注分离原则，且基于事件的模型在处理异步上已经没有现代的Promise等那么有优势。因此Fetch出现来解决这种问题。</p>\n<p>&emsp;  <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\" target=\"_blank\" rel=\"noopener\">Fetch API </a>提供了能够用于操作一部分 HTTP 的 JavaScript 接口，比如 requests 和 responses。它同时也提供了一个全局的 fetch() 方法——能够简单的异步的获取资源。 </p>\n<h2 id=\"1-简单示例\"><a href=\"#1-简单示例\" class=\"headerlink\" title=\"1. 简单示例\"></a>1. 简单示例</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(&quot;&#x2F;data.json&quot;).then(function(res) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; res instanceof Response &#x3D;&#x3D; true.</span><br><span class=\"line\">  if (res.ok) &#123;</span><br><span class=\"line\">    res.json().then(function(data) &#123;</span><br><span class=\"line\">      console.log(data.entries);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    console.log(&quot;Looks like the response wasn&#39;t perfect, got status&quot;, res.status);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, function(e) &#123;</span><br><span class=\"line\">  console.log(&quot;Fetch failed!&quot;, e);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>如果是提交一个POST请求，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(&quot;http:&#x2F;&#x2F;www.example.org&#x2F;submit.php&quot;, &#123;</span><br><span class=\"line\">  method: &quot;POST&quot;,</span><br><span class=\"line\">  headers: &#123;</span><br><span class=\"line\">    &quot;Content-Type&quot;: &quot;application&#x2F;x-www-form-urlencoded&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  body: &quot;firstName&#x3D;Nikhil&amp;favColor&#x3D;blue&amp;password&#x3D;easytoguess&quot;</span><br><span class=\"line\">&#125;).then(function(res) &#123;</span><br><span class=\"line\">  if (res.ok) &#123;</span><br><span class=\"line\">    alert(&quot;Perfect! Your settings are saved.&quot;);</span><br><span class=\"line\">  &#125; else if (res.status &#x3D;&#x3D; 401) &#123;</span><br><span class=\"line\">    alert(&quot;Oops! You are not authorized.&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, function(e) &#123;</span><br><span class=\"line\">  alert(&quot;Error submitting form!&quot;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>fetch()</code> 方法的参数和 <code>Request()</code> 构造函数的参数完全一致，所以我们可以传任意复杂的参数来实现更强大的 <code>fetch()</code>。</p>\n<h2 id=\"2-Headers\"><a href=\"#2-Headers\" class=\"headerlink\" title=\"2. Headers\"></a>2. Headers</h2><p>Fetch 引入了 3 个接口，分别是 <code>Headers</code>，<code>Request</code> 和 <code>Response</code>。他们直接对应于的 HTTP 中相应的概念，但是基于隐私和安全考虑，也有些区别，例如支持 CORS 规则以及保证 cookies 不能被第三方获取。</p>\n<p><code>Headers</code> 接口是一个简单的键值对：</p>\n<figure class=\"highlight plain\"><figcaption><span>接口</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var content &#x3D; &quot;Hello World&quot;;</span><br><span class=\"line\">var reqHeaders &#x3D; new Headers();</span><br><span class=\"line\">reqHeaders.append(&quot;Content-Type&quot;, &quot;text&#x2F;plain&quot;);</span><br><span class=\"line\">reqHeaders.append(&quot;Content-Length&quot;, content.length.toString());</span><br><span class=\"line\">reqHeaders.append(&quot;X-Custom-Header&quot;, &quot;ProcessThisImmediately&quot;);</span><br></pre></td></tr></table></figure>\n<p>也可以给构造函数传一个多维数组或 JS 字面量对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reqHeaders &#x3D; new Headers(&#123;</span><br><span class=\"line\">  &quot;Content-Type&quot;: &quot;text&#x2F;plain&quot;,</span><br><span class=\"line\">  &quot;Content-Length&quot;: content.length.toString(),</span><br><span class=\"line\">  &quot;X-Custom-Header&quot;: &quot;ProcessThisImmediately&quot;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Headers 的内容可被检索：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(reqHeaders.has(&quot;Content-Type&quot;)); &#x2F;&#x2F; true</span><br><span class=\"line\">console.log(reqHeaders.has(&quot;Set-Cookie&quot;)); &#x2F;&#x2F; false</span><br><span class=\"line\">reqHeaders.set(&quot;Content-Type&quot;, &quot;text&#x2F;html&quot;);</span><br><span class=\"line\">reqHeaders.append(&quot;X-Custom-Header&quot;, &quot;AnotherValue&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(reqHeaders.get(&quot;Content-Length&quot;)); &#x2F;&#x2F; 11</span><br><span class=\"line\">console.log(reqHeaders.getAll(&quot;X-Custom-Header&quot;)); &#x2F;&#x2F; [&quot;ProcessThisImmediately&quot;, &quot;AnotherValue&quot;]</span><br><span class=\"line\"> </span><br><span class=\"line\">reqHeaders.delete(&quot;X-Custom-Header&quot;);</span><br><span class=\"line\">console.log(reqHeaders.getAll(&quot;X-Custom-Header&quot;)); &#x2F;&#x2F; []</span><br></pre></td></tr></table></figure>\n<p>一些操作只在 ServiceWorkers 中可用，但这些 API 使得操作 header 更为方便。</p>\n<p>由于 header 可以在发送请求时被发送或在收到响应时被接收，并规定了那些参数可写，所以在 <code>Headers</code> 对象中有个一 <code>guard</code> 属性，来指定哪些参数可以被改变。</p>\n<p>可能的值如下：</p>\n<ul>\n<li><code>&quot;none&quot;</code>：默认值</li>\n<li><code>&quot;request&quot;</code>：<code>Request.headers</code> 对象只读</li>\n<li><code>&quot;request-no-cors&quot;</code>：在 <code>no-cors</code> 模式下，<code>Request.headers</code> 对象只读</li>\n<li><code>&quot;response&quot;</code>：<code>Response.headers</code> 对象只读</li>\n<li><code>&quot;immutable&quot;</code>：通常在 ServiceWorkers 中使用，所有 Header 对象都为只读</li>\n</ul>\n<p>在规范中对每个 <code>guard</code> 属性值有更详细的描述。例如，当 <code>guard</code> 为 <code>request</code> 时，你将不能添加或修改<code>header 的 Content-Length</code> 属性。</p>\n<p>如果使用了一个不合法的 HTTP Header 名，那么 Headers 的方法通常都抛出 TypeError 异常。如果不小心写入了一个只读属性，也会抛出一个 TypeError 异常。除此以外，失败了将不抛出任何异常。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var res &#x3D; Response.error();</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">  res.headers.set(&quot;Origin&quot;, &quot;http:&#x2F;&#x2F;mybank.com&quot;);</span><br><span class=\"line\">&#125; catch(e) &#123;</span><br><span class=\"line\">  console.log(&quot;Cannot pretend to be a bank!&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-Request\"><a href=\"#3-Request\" class=\"headerlink\" title=\"3. Request\"></a>3. Request</h2><p>通过构造一个 <code>Request</code> 对象来获取网络资源，构造函数需要 <code>URL</code>、<code>method</code> 和 <code>headers</code> 参数，同时也可以提供请求体（body）、请求模式（mode）、<code>credentials</code> 和 <code>cache hints</code> 等参数。</p>\n<p>最简单的形式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var req &#x3D; new Request(&quot;&#x2F;index.html&quot;);</span><br><span class=\"line\">console.log(req.method); &#x2F;&#x2F; &quot;GET&quot;</span><br><span class=\"line\">console.log(req.url); &#x2F;&#x2F; &quot;http:&#x2F;&#x2F;example.com&#x2F;index.html&quot;</span><br></pre></td></tr></table></figure>\n<p>也可以将一个 <code>Request</code> 对象传给构造函数，这将返回该对象的一个副本（这与 <code>clone()</code> 方法不同，后面将介绍）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var copy &#x3D; new Request(req);</span><br><span class=\"line\">console.log(copy.method); &#x2F;&#x2F; &quot;GET&quot;</span><br><span class=\"line\">console.log(copy.url); &#x2F;&#x2F; &quot;http:&#x2F;&#x2F;example.com&#x2F;index.html&quot;</span><br></pre></td></tr></table></figure>\n<p>同时，这种形式通常只在 ServiceWorkers 中使用。</p>\n<p>除 <code>URL</code> 之外的参数只能通过第二个参数传递，该参数是一个键值对：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var uploadReq &#x3D; new Request(&quot;&#x2F;uploadImage&quot;, &#123;</span><br><span class=\"line\">  method: &quot;POST&quot;,</span><br><span class=\"line\">  headers: &#123;</span><br><span class=\"line\">    &quot;Content-Type&quot;: &quot;image&#x2F;png&quot;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  body: &quot;image data&quot;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>mode</code> 参数用来决定是否允许跨域请求，以及哪些 <code>response</code> 属性可读。可选的 <code>mode</code> 值为 <code>&quot;same-origin&quot;</code>、<code>&quot;no-cors&quot;</code>（默认）以及 <code>&quot;cors&quot;</code>。</p>\n<h2 id=\"4-same-origin\"><a href=\"#4-same-origin\" class=\"headerlink\" title=\"4. same-origin\"></a>4. same-origin</h2><p>该模式很简单，如果一个请求是跨域的，那么将返回一个 <code>error</code>，这样确保所有的请求遵守同源策略。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arbitraryUrl &#x3D; document.getElementById(&quot;url-input&quot;).value;</span><br><span class=\"line\">fetch(arbitraryUrl, &#123; mode: &quot;same-origin&quot; &#125;).then(function(res) &#123;</span><br><span class=\"line\">  console.log(&quot;Response succeeded?&quot;, res.ok);</span><br><span class=\"line\">&#125;, function(e) &#123;</span><br><span class=\"line\">  console.log(&quot;Please enter a same-origin URL!&quot;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-no-cors\"><a href=\"#5-no-cors\" class=\"headerlink\" title=\"5. no-cors\"></a>5. no-cors</h2><p>该模式允许来自 CDN 的脚本、其他域的图片和其他一些跨域资源，但是首先有个前提条件，就是请求的 method 只能是<code>HEAD</code>、<code>GET</code> 或 <code>POST</code>。此外，如果 ServiceWorkers 拦截了这些请求，它不能随意添加或者修改除这些之外 Header 属性。第三，JS 不能访问 Response 对象中的任何属性，这确保了跨域时 ServiceWorkers 的安全和隐私信息泄漏问题。</p>\n<h2 id=\"6-cors\"><a href=\"#6-cors\" class=\"headerlink\" title=\"6.cors\"></a>6.cors</h2><p>该模式通常用于跨域请求，用来从第三方提供的 API 获取数据。该模式遵守 <a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"noopener\">CORS 协议</a>，并只有有限的一些 Header 被暴露给 Response 对象，但是 body 是可读的。例如，获取一个 Flickr 最感兴趣的照片的清单：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var u &#x3D; new URLSearchParams();</span><br><span class=\"line\">u.append(&#39;method&#39;, &#39;flickr.interestingness.getList&#39;);</span><br><span class=\"line\">u.append(&#39;api_key&#39;, &#39;&lt;insert api key here&gt;&#39;);</span><br><span class=\"line\">u.append(&#39;format&#39;, &#39;json&#39;);</span><br><span class=\"line\">u.append(&#39;nojsoncallback&#39;, &#39;1&#39;);</span><br><span class=\"line\"> </span><br><span class=\"line\">var apiCall &#x3D; fetch(&#39;https:&#x2F;&#x2F;api.flickr.com&#x2F;services&#x2F;rest?&#39; + u);</span><br><span class=\"line\"> </span><br><span class=\"line\">apiCall.then(function(response) &#123;</span><br><span class=\"line\">  return response.json().then(function(json) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; photo is a list of photos.</span><br><span class=\"line\">    return json.photos.photo;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;).then(function(photos) &#123;</span><br><span class=\"line\">  photos.forEach(function(photo) &#123;</span><br><span class=\"line\">    console.log(photo.title);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>我们无法从 Headers 中读取 Date 属性，因为 Flickr 在 Access-Control-Expose-Headers 中设置了不允许读取它。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.headers.get(&quot;Date&quot;); &#x2F;&#x2F; null</span><br></pre></td></tr></table></figure>\n\n<p>另外，<code>credentials</code> 属性决定了是否可以跨域访问 cookie 。该属性与 XHR 的<br><code>withCredentials</code> 标志相同，但是只有三个值，分别是 <code>omit</code>（默认）、<code>same-origin</code> 和 <code>include</code>。</p>\n<p><code>Request</code> 对象也提供了客户端缓存机制（caching hints）。这个属性还在安全复审阶段。Firefox 提供了这个属性，但目前还不起作用。</p>\n<p>Request 对象还有两个与 ServiceWorks 拦截有关的只读属性。其中一个是<code>referrer</code>，表示该 Request 的来源，可能为空。另外一个是 <code>context</code>，是一个非常大的枚举集合，定义了获得的资源的种类，它可能是 image 当请求来自于 img 标签时，可能是 worker 如果是一个 Worker 脚本，等等。如果使用 fetch() 函数，这个值是 fetch。</p>\n<h2 id=\"7-Response\"><a href=\"#7-Response\" class=\"headerlink\" title=\"7. Response\"></a>7. Response</h2><p>Response 对象通常在 <code>fetch()</code> 的回调中获得，也可以通过 JS 构造，不过这通常只在 ServiceWorkers 中使用。</p>\n<p>Response 对象中最常见的属性是 <code>status</code>（整数，默认值是 <code>200</code>）和<code>statusText</code>（默认值是 <code>&quot;OK&quot;</code>）。还有一个 ok 属性，这是 <code>status</code> 值为 <code>200~299</code> 时的语法糖。</p>\n<p>另外，还有一个 <code>type</code> 属性，它的值可能是 <code>&quot;basic&quot;</code>、<code>&quot;cors&quot;</code>、<code>&quot;default&quot;</code>、<code>&quot;error&quot;</code> 或 <code>&quot;opaque&quot;</code>。</p>\n<ul>\n<li><code>&quot;basic&quot;</code>：同域的响应，除 <code>Set-Cookie</code> 和 <code>Set-Cookie</code> 之外的所有 Header 可用</li>\n<li><code>&quot;cors&quot;</code>：Response 从一个合法的跨域请求获得，某些 Header 和 body 可读</li>\n<li><code>&quot;error&quot;</code>：网络错误。Response 对象的 status 属性为 0，headers 属性为空并且不可写。当 <code>Response</code>对象从 <code>Response.error()</code> 中得到时，就是这种类型</li>\n<li><code>&quot;opaque&quot;</code>：在 <code>&quot;no-cors&quot;</code> 模式下请求了跨域资源。依靠服务端来做限制</li>\n</ul>\n<p>当 <code>type</code> 属性值为 <code>&quot;error&quot;</code> 时会导致 fetch() 方法的 <code>Promise</code> 被 <code>reject</code>，reject 回调的参数为 TypeError 对象。</p>\n<p>还有一些属性只在 ServerWorker 下有效。在 ServerWorker 下返回一个 Response 的正确方式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addEventListener(&#39;fetch&#39;, function(event) &#123;</span><br><span class=\"line\">  event.respondWith(new Response(&quot;Response body&quot;, &#123;</span><br><span class=\"line\">    headers: &#123; &quot;Content-Type&quot; : &quot;text&#x2F;plain&quot; &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>正如我们所见，Response 构造函数接收两个参数：返回的 body 和一个键值对对象，通过该对象来设置 <code>status</code>、<code>statusText</code> 和 <code>headers</code> 属性。</p>\n<p>静态方法 <code>Response.error()</code> 将返回一个错误响应，<code>Response.redirect(url, status)</code> 将返回一个跳转响应。</p>\n"},{"title":"Ajax学习知识点","date":"2018-03-01T13:50:08.000Z","_content":"\n## Ajax基础\n* 什么是服务器\n    * 网页浏览过程分析\n    * 如何配置自己的服务器程序(AMP)\n* 什么是Ajax\n    * 无刷新数据读取\n        * 用户注册、在线聊天室\n        * 异步、同步\n* 使用Ajax\n    * 基础：请求并显示静态TXT文件\n        * 字符集编码\n        * 缓存、阻止缓存\n    * 动态数据：请求JS(或json)文件\n        * eval的使用\n        * DOM创建元素\n    * 局部刷新：请求并显示部分网页文件\n\n## Ajax原理\n* HTTP请求方法\n    * GET——用于获取数据(如：浏览帖子)\n    * POST——用于上传数据(如：用户注册)\n    * GET、POST区别\n        * get是在url里面传数据：安全性、容量\n        * 缓存\n\n## 编写Ajax\n* 创建对象\n    * ActiveVObject(\"Microsoft.XMLHTTP\")\n* 连接服务器\n    * open方法(方法、文件名、异步传输)\n        * 同步和异步\n* 发送请求\n    * send()\n* 请求状态监控\n    * onreadystatechange事件\n        * readyState属性：请求状态  \n        > 0(未初始化) 还没调用open方法  \n        > 1(载入)已调用send方法，正在发送请求  \n        > 2(载入完成)send()方法完成，已收到全部相应内容    \n        > 3(解析) 正在解析响应内容  \n        > 4(完成)响应内容解析完成，可以在客户端调用了 \n\n        * status属性：请求结果\n        * responseText\n\n## Ajax数据\n* 数据类型\n    * 什么叫数据类型——英语、中文\n    * XML、Json\n* 字符集\n    * 所有文件字符集相同","source":"_posts/Ajax学习知识点.md","raw":"---\ntitle: Ajax学习知识点  \ndate: 2018-03-01 21:50:08  \ncategories: ajax  \ntags:\n---\n\n## Ajax基础\n* 什么是服务器\n    * 网页浏览过程分析\n    * 如何配置自己的服务器程序(AMP)\n* 什么是Ajax\n    * 无刷新数据读取\n        * 用户注册、在线聊天室\n        * 异步、同步\n* 使用Ajax\n    * 基础：请求并显示静态TXT文件\n        * 字符集编码\n        * 缓存、阻止缓存\n    * 动态数据：请求JS(或json)文件\n        * eval的使用\n        * DOM创建元素\n    * 局部刷新：请求并显示部分网页文件\n\n## Ajax原理\n* HTTP请求方法\n    * GET——用于获取数据(如：浏览帖子)\n    * POST——用于上传数据(如：用户注册)\n    * GET、POST区别\n        * get是在url里面传数据：安全性、容量\n        * 缓存\n\n## 编写Ajax\n* 创建对象\n    * ActiveVObject(\"Microsoft.XMLHTTP\")\n* 连接服务器\n    * open方法(方法、文件名、异步传输)\n        * 同步和异步\n* 发送请求\n    * send()\n* 请求状态监控\n    * onreadystatechange事件\n        * readyState属性：请求状态  \n        > 0(未初始化) 还没调用open方法  \n        > 1(载入)已调用send方法，正在发送请求  \n        > 2(载入完成)send()方法完成，已收到全部相应内容    \n        > 3(解析) 正在解析响应内容  \n        > 4(完成)响应内容解析完成，可以在客户端调用了 \n\n        * status属性：请求结果\n        * responseText\n\n## Ajax数据\n* 数据类型\n    * 什么叫数据类型——英语、中文\n    * XML、Json\n* 字符集\n    * 所有文件字符集相同","slug":"Ajax学习知识点","published":1,"updated":"2020-04-01T02:15:52.389Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8gp7rxn0001kb9hge9hate0","content":"<h2 id=\"Ajax基础\"><a href=\"#Ajax基础\" class=\"headerlink\" title=\"Ajax基础\"></a>Ajax基础</h2><ul>\n<li>什么是服务器<ul>\n<li>网页浏览过程分析</li>\n<li>如何配置自己的服务器程序(AMP)</li>\n</ul>\n</li>\n<li>什么是Ajax<ul>\n<li>无刷新数据读取<ul>\n<li>用户注册、在线聊天室</li>\n<li>异步、同步</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>使用Ajax<ul>\n<li>基础：请求并显示静态TXT文件<ul>\n<li>字符集编码</li>\n<li>缓存、阻止缓存</li>\n</ul>\n</li>\n<li>动态数据：请求JS(或json)文件<ul>\n<li>eval的使用</li>\n<li>DOM创建元素</li>\n</ul>\n</li>\n<li>局部刷新：请求并显示部分网页文件</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Ajax原理\"><a href=\"#Ajax原理\" class=\"headerlink\" title=\"Ajax原理\"></a>Ajax原理</h2><ul>\n<li>HTTP请求方法<ul>\n<li>GET——用于获取数据(如：浏览帖子)</li>\n<li>POST——用于上传数据(如：用户注册)</li>\n<li>GET、POST区别<ul>\n<li>get是在url里面传数据：安全性、容量</li>\n<li>缓存</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"编写Ajax\"><a href=\"#编写Ajax\" class=\"headerlink\" title=\"编写Ajax\"></a>编写Ajax</h2><ul>\n<li><p>创建对象</p>\n<ul>\n<li>ActiveVObject(“Microsoft.XMLHTTP”)</li>\n</ul>\n</li>\n<li><p>连接服务器</p>\n<ul>\n<li>open方法(方法、文件名、异步传输)<ul>\n<li>同步和异步</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>发送请求</p>\n<ul>\n<li>send()</li>\n</ul>\n</li>\n<li><p>请求状态监控</p>\n<ul>\n<li><p>onreadystatechange事件</p>\n<ul>\n<li><p>readyState属性：请求状态  </p>\n<blockquote>\n<p>0(未初始化) 还没调用open方法<br>1(载入)已调用send方法，正在发送请求<br>2(载入完成)send()方法完成，已收到全部相应内容<br>3(解析) 正在解析响应内容<br>4(完成)响应内容解析完成，可以在客户端调用了 </p>\n</blockquote>\n</li>\n<li><p>status属性：请求结果</p>\n</li>\n<li><p>responseText</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Ajax数据\"><a href=\"#Ajax数据\" class=\"headerlink\" title=\"Ajax数据\"></a>Ajax数据</h2><ul>\n<li>数据类型<ul>\n<li>什么叫数据类型——英语、中文</li>\n<li>XML、Json</li>\n</ul>\n</li>\n<li>字符集<ul>\n<li>所有文件字符集相同</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Ajax基础\"><a href=\"#Ajax基础\" class=\"headerlink\" title=\"Ajax基础\"></a>Ajax基础</h2><ul>\n<li>什么是服务器<ul>\n<li>网页浏览过程分析</li>\n<li>如何配置自己的服务器程序(AMP)</li>\n</ul>\n</li>\n<li>什么是Ajax<ul>\n<li>无刷新数据读取<ul>\n<li>用户注册、在线聊天室</li>\n<li>异步、同步</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>使用Ajax<ul>\n<li>基础：请求并显示静态TXT文件<ul>\n<li>字符集编码</li>\n<li>缓存、阻止缓存</li>\n</ul>\n</li>\n<li>动态数据：请求JS(或json)文件<ul>\n<li>eval的使用</li>\n<li>DOM创建元素</li>\n</ul>\n</li>\n<li>局部刷新：请求并显示部分网页文件</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Ajax原理\"><a href=\"#Ajax原理\" class=\"headerlink\" title=\"Ajax原理\"></a>Ajax原理</h2><ul>\n<li>HTTP请求方法<ul>\n<li>GET——用于获取数据(如：浏览帖子)</li>\n<li>POST——用于上传数据(如：用户注册)</li>\n<li>GET、POST区别<ul>\n<li>get是在url里面传数据：安全性、容量</li>\n<li>缓存</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"编写Ajax\"><a href=\"#编写Ajax\" class=\"headerlink\" title=\"编写Ajax\"></a>编写Ajax</h2><ul>\n<li><p>创建对象</p>\n<ul>\n<li>ActiveVObject(“Microsoft.XMLHTTP”)</li>\n</ul>\n</li>\n<li><p>连接服务器</p>\n<ul>\n<li>open方法(方法、文件名、异步传输)<ul>\n<li>同步和异步</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>发送请求</p>\n<ul>\n<li>send()</li>\n</ul>\n</li>\n<li><p>请求状态监控</p>\n<ul>\n<li><p>onreadystatechange事件</p>\n<ul>\n<li><p>readyState属性：请求状态  </p>\n<blockquote>\n<p>0(未初始化) 还没调用open方法<br>1(载入)已调用send方法，正在发送请求<br>2(载入完成)send()方法完成，已收到全部相应内容<br>3(解析) 正在解析响应内容<br>4(完成)响应内容解析完成，可以在客户端调用了 </p>\n</blockquote>\n</li>\n<li><p>status属性：请求结果</p>\n</li>\n<li><p>responseText</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Ajax数据\"><a href=\"#Ajax数据\" class=\"headerlink\" title=\"Ajax数据\"></a>Ajax数据</h2><ul>\n<li>数据类型<ul>\n<li>什么叫数据类型——英语、中文</li>\n<li>XML、Json</li>\n</ul>\n</li>\n<li>字符集<ul>\n<li>所有文件字符集相同</li>\n</ul>\n</li>\n</ul>\n"},{"title":"gulp","date":"2018-09-06T12:39:08.000Z","_content":"\n#### gulp-转码项目中的ES6-ES5并压缩js\n在这之前，请确保你的 `node` 和 `npm` 已经安装无误，可以用`node -v` 和 `npm -v`查看 `node` 和 `npm` 的版本。\n\n好了，接下来，gulp-babel，转码压缩，七步到位，走你！\n\n##### 1. 全局安装 gulp\n终端执行 `cnpm install gulp -g`。(这里默认大家已经安装了[淘宝镜像](http://npm.taobao.org/)，没有安装也可以使用 `npm`)。\n\n安装完毕后可以使用 `gulp -v`检测版本。\n\n##### 2. 在项目中安装 babel\n在项目根目录执行 `cnpm install babel-cli`，等待安装好项目所依赖的`babel`。\n\n安装完毕后可以使用 `.\\node_modules\\.bin\\babel --version` 检测版本。这时候你可以在你的项目中看到一个node_modules文件夹。\n\n##### 3. 在项目中安装 gulp\n在项目根目录执行 `cnpm install gulp`，安装项目中的 `gulp`。\n\n##### 4. 在项目中安装 gulp-babel\n在项目根目录执行 `cnpm install --save-dev gulp-babel babel-preset-env`。\n\n安装完毕后，你可以看到你的项目出现了 `package.json`(如果你没有预先 `npm init` 或者安装依赖的话一般是不会出现这个文件的)，你可以检测文件里会出现了以下依赖：\n\n    {\n      \"devDependencies\": {\n        \"babel-preset-env\": \"^1.6.1\",\n        \"gulp-babel\": \"^7.0.0\"\n      }\n    }\n\n##### 5. 在项目中安装 gulp-uglify\n在项目根目录执行 `cnpm install gulp-uglify --save-dev`, 于是 `package.json` 变成了这样：\n\n    {\n      \"devDependencies\": {\n        \"babel-preset-env\": \"^1.6.1\",\n        \"gulp-babel\": \"^7.0.0\",\n        \"gulp-uglify\": \"^3.0.0\"\n      }\n    }\n    \n##### 6.根目录创建 gulpfile.js\n在项目根目录创建 `gulpfile.js`，里面的代码是这样的：\n\n    const gulp = require('gulp'); // 引入gulp\n    const babel = require('gulp-babel'); // 引入gulp-babel\n    const uglify = require('gulp-uglify'); // 引入gulp-uglify\n    \n    // ES6代码转码为ES5\n    gulp.task('toes5', () =>\n        gulp.src('src/*.js') // 需要转码的es6文件，这里代表src文件夹下的所有js文件\n            /*\n    \t\t最新的presets: ['env']，是通用版，可以转码es2015、react、es2017, \n    \t\t这里只用于转码es2015，你可以下载相关转码依赖\n            */\n            .pipe(babel({\n                presets: ['env']\n            }))\n            .pipe(gulp.dest('dist')) // 转码后的文件输出位置\n    );\n    \n    // JS代码压缩\n    gulp.task('jsmin', () =>\n        gulp.src('dist/*.js') // 需要压缩的js文件\n            .pipe(uglify())\n            .pipe(gulp.dest('min')) // 压缩的js文件输出位置\n    );\n    \n    // 使用监听，但是需要预先使用命令 gulp auto，文件如果修改了，就一步到位\n    gulp.task('auto', () => {\n    gulp.watch('src/*.js', ['toes5']) // 需要转码的js文件位置 + 口令\n    gulp.watch('dist/*.js', ['jsmin']) // 需要压缩的js文件位置 + 口令\n});\n\n##### 7. 流水线的骚操作\n在项目根目录终端运行 `gulp toes5`，就将 `es6` 文件转为 `es5` 文件了。运行 `gulp jsmin`，就将 `js` 文件稳稳当当地压缩了。\n\n如果我们需要一步到位，而且不用随时去执行这繁琐的命令，我们还可以使用监听。在项目根目录终端使用 `gulp auto`，然后每次修改开发文件( `src` 下的 `js` )，就会自动同步转码和压缩。【==监听还可以监听更多的 gulp task，这点非常重要==】\n\n附录\n----\n##### 8. gulp-htmlmin 压缩html\n`cnpm install gulp-htmlmin --save-dev`\n\n    const htmlmin = require('gulp-htmlmin');\n    \n    // 压缩html和html页面内的css/js\n    gulp.task('htmlmin', function () {\n        var options = {\n            removeComments: true,//清除HTML注释\n            collapseWhitespace: true,//压缩HTML\n            collapseBooleanAttributes: true,//省略布尔属性的值 <input checked=\"true\"/> ==> <input />\n            removeEmptyAttributes: true,//删除所有空格作属性值 <input id=\"\" /> ==> <input />\n            removeScriptTypeAttributes: true,//删除<script>的type=\"text/javascript\"\n            removeStyleLinkTypeAttributes: true,//删除<style>和<link>的type=\"text/css\"\n            minifyJS: true,//压缩页面JS\n            minifyCSS: true//压缩页面CSS\n        };\n        gulp.src('src/*.html')\n            .pipe(htmlmin(options))\n            .pipe(gulp.dest('min'));\n    });\n\n##### 9. gulp-clean-css 压缩css\n`cnpm install gulp-clean-css --save-dev`\n\n    \n    const cleanCSS = require('gulp-clean-css');\n\n    // 压缩css文件, 如果有外部引用，为了保持项目结构，需要使用插件 gulp-sourcemaps\n    gulp.task('cssmin', () => {\n        gulp.src('src/*.css')\n            .pipe(cleanCSS({compatibility: 'ie8'})) // 兼容IE8及以下浏览器\n            .pipe(gulp.dest('min'));\n    });\n\n##### 10. gulp-concat 合并 js 文件\n`cnpm install gulp-concat --save-dev`\n\n    const concat = require('gulp-concat');\n    \n    // 合并 js 文件, 但不会转码和压缩\n    gulp.task('jsconcat', function () {\n        gulp.src('src/*.js')\n            .pipe(concat('index.js'))//合并后的文件名\n            .pipe(gulp.dest('dist'));\n    });\n    \n##### 11. gulp-less 将less文件编译成css\n`cnpm install gulp-less --save-dev`\n\n    const less = require('gulp-less');\n    \n    // 编译less文件，如果有外部引用，为了保持项目结构，需要使用插件 gulp-sourcemaps\n    gulp.task('lesstocss', function () {\n        //编译src目录下的所有less文件\n        //除了reset.less和test.less（**匹配src/less的0个或多个子文件夹）\n        gulp.src(['src/*.less', '!src/less/**/{reset,test}.less']) \n            .pipe(less())\n            // 编译后压缩css文件输出到min\n            .pipe(cleanCSS({compatibility: 'ie8'})) // 兼容IE8及以下浏览器\n            .pipe(gulp.dest('min'));\n    });\n\n##### 12. gulp-autoprefixer 给 css 项处理浏览器前缀\n`cnpm install --save-dev gulp-autoprefixer`\n\n    const autoprefixer = require('gulp-autoprefixer');\n    \n    // 自动补齐css前缀\n    gulp.task('autoprefixer', () => {\n        gulp.src('src/index.css')\n            .pipe(autoprefixer({\n                browsers: ['last 2 versions'], // 主流浏览器的最新两个版本\n                cascade: true, // 是否美化属性值 默认：true\n                remove:true // 是否去掉不必要的前缀 默认：true \n            }))\n            .pipe(gulp.dest('dist'))\n    });\n    \n    \n    \n    // 需要适配的页面\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>Document</title>\n    </head>\n    <body>\n        @@include('include/header.html')\n    \n        <p> 这是 layout 的内容 </p>\n    \n        @@include('include/footer.html')\n    </body>\n    </html>\n\n##### 13. gulp-file-include 头尾共用、文件合并\n`cnpm install gulp-file-include --save-dev`\n\n    const fileinclude  = require('gulp-file-include');\n\n    // 头尾共用\n    gulp.task('fileinclude', () => {\n        // 适配page中所有文件夹下的所有html，排除page下的include文件夹中html\n            gulp.src(['src/*.html','!src/include/**.html'])\n            .pipe(fileinclude({\n              prefix: '@@',\n              basepath: '@file'\n            }))\n        .pipe(gulp.dest('dist'))\n    });\n\n##### 14. gulp-livereload 监听文件变化局部刷新\n\n##### 15. gulp-imagemin 压缩图片\n\n示例\n---\n\n    const gulp = require('gulp');\n    const babel = require('gulp-babel');\n    const uglify = require('gulp-uglify');\n    const htmlmin = require('gulp-htmlmin');\n    const cleanCSS = require('gulp-clean-css');\n    const concat = require('gulp-concat');\n    const less = require('gulp-less');\n    const autoprefixer = require('gulp-autoprefixer');\n    const fileinclude  = require('gulp-file-include');\n    \n    // 头尾共用\n    gulp.task('fileinclude', () => {\n        // 适配page中所有文件夹下的所有html，排除page下的include文件夹中html\n            gulp.src(['src/*.html','!src/include/**.html'])\n            .pipe(fileinclude({\n              prefix: '@@',\n              basepath: '@file'\n            }))\n        .pipe(gulp.dest('dist'))\n    });\n    \n    // 压缩html和html页面内的css/js\n    gulp.task('htmlmin', function () {\n        var options = {\n            removeComments: true,//清除HTML注释\n            collapseWhitespace: true,//压缩HTML\n            collapseBooleanAttributes: true,//省略布尔属性的值 <input checked=\"true\"/> ==> <input />\n            removeEmptyAttributes: true,//删除所有空格作属性值 <input id=\"\" /> ==> <input />\n            removeScriptTypeAttributes: true,//删除<script>的type=\"text/javascript\"\n            removeStyleLinkTypeAttributes: true,//删除<style>和<link>的type=\"text/css\"\n            minifyJS: true,//压缩页面JS\n            minifyCSS: true//压缩页面CSS\n        };\n        gulp.src('dist/*.html')\n            .pipe(htmlmin(options))\n            .pipe(gulp.dest('min'));\n    });\n    \n    // 编译less文件，如果有外部引用，为了保持项目结构，需要使用插件 gulp-sourcemaps\n    gulp.task('lesstocss', function () {\n        //编译src目录下的所有less文件\n        //除了reset.less和test.less（**匹配src的0个或多个子文件夹）\n        gulp.src(['src/*.less', '!src/**/{reset,test}.less']) \n            .pipe(less())\n            // 编译后自动补齐css前缀\n            .pipe(autoprefixer({\n                browsers: ['last 2 versions'], // 主流浏览器的最新两个版本\n                cascade: true, // 是否美化属性值 默认：true\n                remove:true // 是否去掉不必要的前缀 默认：true \n            }))\n            // 然后压缩css文件输出到min\n            .pipe(cleanCSS({compatibility: 'ie8'})) // 兼容IE8及以下浏览器\n            .pipe(gulp.dest('min'));\n    });\n    \n    // ES6代码转码为ES5\n    gulp.task('toes5', () =>\n        gulp.src('src/*.js') // 需要转码的es6文件，这里代表src文件夹下的所有js文件\n            /*\n    \t\t最新的presets: ['env']，是通用版，可以转码es2015、react、es2017, \n    \t\t这里只用于转码es2015，你可以下载相关转码依赖\n            */\n            .pipe(babel({\n                presets: ['env']\n            }))\n            .pipe(gulp.dest('dist')) // 转码后的文件输出位置\n    );\n    \n    // 合并 js 文件, 但不会转码和压缩\n    gulp.task('jsconcat', () => {\n        gulp.src('src/*.js')\n            .pipe(concat('index.js')) // 合并后的文件名\n            .pipe(gulp.dest('dist'))\n    });\n    \n    // JS代码压缩\n    gulp.task('jsmin', () =>\n        gulp.src('dist/*.js') // 需要压缩的js文件\n            .pipe(uglify())\n            .pipe(gulp.dest('min')) // 压缩的js文件输出位置\n    );\n    \n    \n    \n    // // 使用监听，但是需要预先使用命令 gulp auto，文件如果修改了，就一步到位\n    // gulp.task('auto', () => {\n    //     gulp.watch('src/*.js', ['toes5']) // 需要转码的js文件位置 + 口令\n    //     gulp.watch('dist/*.js', ['jsmin']) // 需要压缩的js文件位置 + 口令\n    //     // gulp.watch...\n    // });","source":"_posts/Gulp.md","raw":"---\ntitle: gulp  \ndate: 2018-09-06 20:39:08  \ncategories: gulp  \ntags:\n---\n\n#### gulp-转码项目中的ES6-ES5并压缩js\n在这之前，请确保你的 `node` 和 `npm` 已经安装无误，可以用`node -v` 和 `npm -v`查看 `node` 和 `npm` 的版本。\n\n好了，接下来，gulp-babel，转码压缩，七步到位，走你！\n\n##### 1. 全局安装 gulp\n终端执行 `cnpm install gulp -g`。(这里默认大家已经安装了[淘宝镜像](http://npm.taobao.org/)，没有安装也可以使用 `npm`)。\n\n安装完毕后可以使用 `gulp -v`检测版本。\n\n##### 2. 在项目中安装 babel\n在项目根目录执行 `cnpm install babel-cli`，等待安装好项目所依赖的`babel`。\n\n安装完毕后可以使用 `.\\node_modules\\.bin\\babel --version` 检测版本。这时候你可以在你的项目中看到一个node_modules文件夹。\n\n##### 3. 在项目中安装 gulp\n在项目根目录执行 `cnpm install gulp`，安装项目中的 `gulp`。\n\n##### 4. 在项目中安装 gulp-babel\n在项目根目录执行 `cnpm install --save-dev gulp-babel babel-preset-env`。\n\n安装完毕后，你可以看到你的项目出现了 `package.json`(如果你没有预先 `npm init` 或者安装依赖的话一般是不会出现这个文件的)，你可以检测文件里会出现了以下依赖：\n\n    {\n      \"devDependencies\": {\n        \"babel-preset-env\": \"^1.6.1\",\n        \"gulp-babel\": \"^7.0.0\"\n      }\n    }\n\n##### 5. 在项目中安装 gulp-uglify\n在项目根目录执行 `cnpm install gulp-uglify --save-dev`, 于是 `package.json` 变成了这样：\n\n    {\n      \"devDependencies\": {\n        \"babel-preset-env\": \"^1.6.1\",\n        \"gulp-babel\": \"^7.0.0\",\n        \"gulp-uglify\": \"^3.0.0\"\n      }\n    }\n    \n##### 6.根目录创建 gulpfile.js\n在项目根目录创建 `gulpfile.js`，里面的代码是这样的：\n\n    const gulp = require('gulp'); // 引入gulp\n    const babel = require('gulp-babel'); // 引入gulp-babel\n    const uglify = require('gulp-uglify'); // 引入gulp-uglify\n    \n    // ES6代码转码为ES5\n    gulp.task('toes5', () =>\n        gulp.src('src/*.js') // 需要转码的es6文件，这里代表src文件夹下的所有js文件\n            /*\n    \t\t最新的presets: ['env']，是通用版，可以转码es2015、react、es2017, \n    \t\t这里只用于转码es2015，你可以下载相关转码依赖\n            */\n            .pipe(babel({\n                presets: ['env']\n            }))\n            .pipe(gulp.dest('dist')) // 转码后的文件输出位置\n    );\n    \n    // JS代码压缩\n    gulp.task('jsmin', () =>\n        gulp.src('dist/*.js') // 需要压缩的js文件\n            .pipe(uglify())\n            .pipe(gulp.dest('min')) // 压缩的js文件输出位置\n    );\n    \n    // 使用监听，但是需要预先使用命令 gulp auto，文件如果修改了，就一步到位\n    gulp.task('auto', () => {\n    gulp.watch('src/*.js', ['toes5']) // 需要转码的js文件位置 + 口令\n    gulp.watch('dist/*.js', ['jsmin']) // 需要压缩的js文件位置 + 口令\n});\n\n##### 7. 流水线的骚操作\n在项目根目录终端运行 `gulp toes5`，就将 `es6` 文件转为 `es5` 文件了。运行 `gulp jsmin`，就将 `js` 文件稳稳当当地压缩了。\n\n如果我们需要一步到位，而且不用随时去执行这繁琐的命令，我们还可以使用监听。在项目根目录终端使用 `gulp auto`，然后每次修改开发文件( `src` 下的 `js` )，就会自动同步转码和压缩。【==监听还可以监听更多的 gulp task，这点非常重要==】\n\n附录\n----\n##### 8. gulp-htmlmin 压缩html\n`cnpm install gulp-htmlmin --save-dev`\n\n    const htmlmin = require('gulp-htmlmin');\n    \n    // 压缩html和html页面内的css/js\n    gulp.task('htmlmin', function () {\n        var options = {\n            removeComments: true,//清除HTML注释\n            collapseWhitespace: true,//压缩HTML\n            collapseBooleanAttributes: true,//省略布尔属性的值 <input checked=\"true\"/> ==> <input />\n            removeEmptyAttributes: true,//删除所有空格作属性值 <input id=\"\" /> ==> <input />\n            removeScriptTypeAttributes: true,//删除<script>的type=\"text/javascript\"\n            removeStyleLinkTypeAttributes: true,//删除<style>和<link>的type=\"text/css\"\n            minifyJS: true,//压缩页面JS\n            minifyCSS: true//压缩页面CSS\n        };\n        gulp.src('src/*.html')\n            .pipe(htmlmin(options))\n            .pipe(gulp.dest('min'));\n    });\n\n##### 9. gulp-clean-css 压缩css\n`cnpm install gulp-clean-css --save-dev`\n\n    \n    const cleanCSS = require('gulp-clean-css');\n\n    // 压缩css文件, 如果有外部引用，为了保持项目结构，需要使用插件 gulp-sourcemaps\n    gulp.task('cssmin', () => {\n        gulp.src('src/*.css')\n            .pipe(cleanCSS({compatibility: 'ie8'})) // 兼容IE8及以下浏览器\n            .pipe(gulp.dest('min'));\n    });\n\n##### 10. gulp-concat 合并 js 文件\n`cnpm install gulp-concat --save-dev`\n\n    const concat = require('gulp-concat');\n    \n    // 合并 js 文件, 但不会转码和压缩\n    gulp.task('jsconcat', function () {\n        gulp.src('src/*.js')\n            .pipe(concat('index.js'))//合并后的文件名\n            .pipe(gulp.dest('dist'));\n    });\n    \n##### 11. gulp-less 将less文件编译成css\n`cnpm install gulp-less --save-dev`\n\n    const less = require('gulp-less');\n    \n    // 编译less文件，如果有外部引用，为了保持项目结构，需要使用插件 gulp-sourcemaps\n    gulp.task('lesstocss', function () {\n        //编译src目录下的所有less文件\n        //除了reset.less和test.less（**匹配src/less的0个或多个子文件夹）\n        gulp.src(['src/*.less', '!src/less/**/{reset,test}.less']) \n            .pipe(less())\n            // 编译后压缩css文件输出到min\n            .pipe(cleanCSS({compatibility: 'ie8'})) // 兼容IE8及以下浏览器\n            .pipe(gulp.dest('min'));\n    });\n\n##### 12. gulp-autoprefixer 给 css 项处理浏览器前缀\n`cnpm install --save-dev gulp-autoprefixer`\n\n    const autoprefixer = require('gulp-autoprefixer');\n    \n    // 自动补齐css前缀\n    gulp.task('autoprefixer', () => {\n        gulp.src('src/index.css')\n            .pipe(autoprefixer({\n                browsers: ['last 2 versions'], // 主流浏览器的最新两个版本\n                cascade: true, // 是否美化属性值 默认：true\n                remove:true // 是否去掉不必要的前缀 默认：true \n            }))\n            .pipe(gulp.dest('dist'))\n    });\n    \n    \n    \n    // 需要适配的页面\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>Document</title>\n    </head>\n    <body>\n        @@include('include/header.html')\n    \n        <p> 这是 layout 的内容 </p>\n    \n        @@include('include/footer.html')\n    </body>\n    </html>\n\n##### 13. gulp-file-include 头尾共用、文件合并\n`cnpm install gulp-file-include --save-dev`\n\n    const fileinclude  = require('gulp-file-include');\n\n    // 头尾共用\n    gulp.task('fileinclude', () => {\n        // 适配page中所有文件夹下的所有html，排除page下的include文件夹中html\n            gulp.src(['src/*.html','!src/include/**.html'])\n            .pipe(fileinclude({\n              prefix: '@@',\n              basepath: '@file'\n            }))\n        .pipe(gulp.dest('dist'))\n    });\n\n##### 14. gulp-livereload 监听文件变化局部刷新\n\n##### 15. gulp-imagemin 压缩图片\n\n示例\n---\n\n    const gulp = require('gulp');\n    const babel = require('gulp-babel');\n    const uglify = require('gulp-uglify');\n    const htmlmin = require('gulp-htmlmin');\n    const cleanCSS = require('gulp-clean-css');\n    const concat = require('gulp-concat');\n    const less = require('gulp-less');\n    const autoprefixer = require('gulp-autoprefixer');\n    const fileinclude  = require('gulp-file-include');\n    \n    // 头尾共用\n    gulp.task('fileinclude', () => {\n        // 适配page中所有文件夹下的所有html，排除page下的include文件夹中html\n            gulp.src(['src/*.html','!src/include/**.html'])\n            .pipe(fileinclude({\n              prefix: '@@',\n              basepath: '@file'\n            }))\n        .pipe(gulp.dest('dist'))\n    });\n    \n    // 压缩html和html页面内的css/js\n    gulp.task('htmlmin', function () {\n        var options = {\n            removeComments: true,//清除HTML注释\n            collapseWhitespace: true,//压缩HTML\n            collapseBooleanAttributes: true,//省略布尔属性的值 <input checked=\"true\"/> ==> <input />\n            removeEmptyAttributes: true,//删除所有空格作属性值 <input id=\"\" /> ==> <input />\n            removeScriptTypeAttributes: true,//删除<script>的type=\"text/javascript\"\n            removeStyleLinkTypeAttributes: true,//删除<style>和<link>的type=\"text/css\"\n            minifyJS: true,//压缩页面JS\n            minifyCSS: true//压缩页面CSS\n        };\n        gulp.src('dist/*.html')\n            .pipe(htmlmin(options))\n            .pipe(gulp.dest('min'));\n    });\n    \n    // 编译less文件，如果有外部引用，为了保持项目结构，需要使用插件 gulp-sourcemaps\n    gulp.task('lesstocss', function () {\n        //编译src目录下的所有less文件\n        //除了reset.less和test.less（**匹配src的0个或多个子文件夹）\n        gulp.src(['src/*.less', '!src/**/{reset,test}.less']) \n            .pipe(less())\n            // 编译后自动补齐css前缀\n            .pipe(autoprefixer({\n                browsers: ['last 2 versions'], // 主流浏览器的最新两个版本\n                cascade: true, // 是否美化属性值 默认：true\n                remove:true // 是否去掉不必要的前缀 默认：true \n            }))\n            // 然后压缩css文件输出到min\n            .pipe(cleanCSS({compatibility: 'ie8'})) // 兼容IE8及以下浏览器\n            .pipe(gulp.dest('min'));\n    });\n    \n    // ES6代码转码为ES5\n    gulp.task('toes5', () =>\n        gulp.src('src/*.js') // 需要转码的es6文件，这里代表src文件夹下的所有js文件\n            /*\n    \t\t最新的presets: ['env']，是通用版，可以转码es2015、react、es2017, \n    \t\t这里只用于转码es2015，你可以下载相关转码依赖\n            */\n            .pipe(babel({\n                presets: ['env']\n            }))\n            .pipe(gulp.dest('dist')) // 转码后的文件输出位置\n    );\n    \n    // 合并 js 文件, 但不会转码和压缩\n    gulp.task('jsconcat', () => {\n        gulp.src('src/*.js')\n            .pipe(concat('index.js')) // 合并后的文件名\n            .pipe(gulp.dest('dist'))\n    });\n    \n    // JS代码压缩\n    gulp.task('jsmin', () =>\n        gulp.src('dist/*.js') // 需要压缩的js文件\n            .pipe(uglify())\n            .pipe(gulp.dest('min')) // 压缩的js文件输出位置\n    );\n    \n    \n    \n    // // 使用监听，但是需要预先使用命令 gulp auto，文件如果修改了，就一步到位\n    // gulp.task('auto', () => {\n    //     gulp.watch('src/*.js', ['toes5']) // 需要转码的js文件位置 + 口令\n    //     gulp.watch('dist/*.js', ['jsmin']) // 需要压缩的js文件位置 + 口令\n    //     // gulp.watch...\n    // });","slug":"Gulp","published":1,"updated":"2020-04-01T02:15:52.390Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8gp7rxp0002kb9hcd7j56f5","content":"<h4 id=\"gulp-转码项目中的ES6-ES5并压缩js\"><a href=\"#gulp-转码项目中的ES6-ES5并压缩js\" class=\"headerlink\" title=\"gulp-转码项目中的ES6-ES5并压缩js\"></a>gulp-转码项目中的ES6-ES5并压缩js</h4><p>在这之前，请确保你的 <code>node</code> 和 <code>npm</code> 已经安装无误，可以用<code>node -v</code> 和 <code>npm -v</code>查看 <code>node</code> 和 <code>npm</code> 的版本。</p>\n<p>好了，接下来，gulp-babel，转码压缩，七步到位，走你！</p>\n<h5 id=\"1-全局安装-gulp\"><a href=\"#1-全局安装-gulp\" class=\"headerlink\" title=\"1. 全局安装 gulp\"></a>1. 全局安装 gulp</h5><p>终端执行 <code>cnpm install gulp -g</code>。(这里默认大家已经安装了<a href=\"http://npm.taobao.org/\" target=\"_blank\" rel=\"noopener\">淘宝镜像</a>，没有安装也可以使用 <code>npm</code>)。</p>\n<p>安装完毕后可以使用 <code>gulp -v</code>检测版本。</p>\n<h5 id=\"2-在项目中安装-babel\"><a href=\"#2-在项目中安装-babel\" class=\"headerlink\" title=\"2. 在项目中安装 babel\"></a>2. 在项目中安装 babel</h5><p>在项目根目录执行 <code>cnpm install babel-cli</code>，等待安装好项目所依赖的<code>babel</code>。</p>\n<p>安装完毕后可以使用 <code>.\\node_modules\\.bin\\babel --version</code> 检测版本。这时候你可以在你的项目中看到一个node_modules文件夹。</p>\n<h5 id=\"3-在项目中安装-gulp\"><a href=\"#3-在项目中安装-gulp\" class=\"headerlink\" title=\"3. 在项目中安装 gulp\"></a>3. 在项目中安装 gulp</h5><p>在项目根目录执行 <code>cnpm install gulp</code>，安装项目中的 <code>gulp</code>。</p>\n<h5 id=\"4-在项目中安装-gulp-babel\"><a href=\"#4-在项目中安装-gulp-babel\" class=\"headerlink\" title=\"4. 在项目中安装 gulp-babel\"></a>4. 在项目中安装 gulp-babel</h5><p>在项目根目录执行 <code>cnpm install --save-dev gulp-babel babel-preset-env</code>。</p>\n<p>安装完毕后，你可以看到你的项目出现了 <code>package.json</code>(如果你没有预先 <code>npm init</code> 或者安装依赖的话一般是不会出现这个文件的)，你可以检测文件里会出现了以下依赖：</p>\n<pre><code>{\n  &quot;devDependencies&quot;: {\n    &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;,\n    &quot;gulp-babel&quot;: &quot;^7.0.0&quot;\n  }\n}</code></pre><h5 id=\"5-在项目中安装-gulp-uglify\"><a href=\"#5-在项目中安装-gulp-uglify\" class=\"headerlink\" title=\"5. 在项目中安装 gulp-uglify\"></a>5. 在项目中安装 gulp-uglify</h5><p>在项目根目录执行 <code>cnpm install gulp-uglify --save-dev</code>, 于是 <code>package.json</code> 变成了这样：</p>\n<pre><code>{\n  &quot;devDependencies&quot;: {\n    &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;,\n    &quot;gulp-babel&quot;: &quot;^7.0.0&quot;,\n    &quot;gulp-uglify&quot;: &quot;^3.0.0&quot;\n  }\n}</code></pre><h5 id=\"6-根目录创建-gulpfile-js\"><a href=\"#6-根目录创建-gulpfile-js\" class=\"headerlink\" title=\"6.根目录创建 gulpfile.js\"></a>6.根目录创建 gulpfile.js</h5><p>在项目根目录创建 <code>gulpfile.js</code>，里面的代码是这样的：</p>\n<pre><code>const gulp = require(&apos;gulp&apos;); // 引入gulp\nconst babel = require(&apos;gulp-babel&apos;); // 引入gulp-babel\nconst uglify = require(&apos;gulp-uglify&apos;); // 引入gulp-uglify\n\n// ES6代码转码为ES5\ngulp.task(&apos;toes5&apos;, () =&gt;\n    gulp.src(&apos;src/*.js&apos;) // 需要转码的es6文件，这里代表src文件夹下的所有js文件\n        /*\n        最新的presets: [&apos;env&apos;]，是通用版，可以转码es2015、react、es2017, \n        这里只用于转码es2015，你可以下载相关转码依赖\n        */\n        .pipe(babel({\n            presets: [&apos;env&apos;]\n        }))\n        .pipe(gulp.dest(&apos;dist&apos;)) // 转码后的文件输出位置\n);\n\n// JS代码压缩\ngulp.task(&apos;jsmin&apos;, () =&gt;\n    gulp.src(&apos;dist/*.js&apos;) // 需要压缩的js文件\n        .pipe(uglify())\n        .pipe(gulp.dest(&apos;min&apos;)) // 压缩的js文件输出位置\n);\n\n// 使用监听，但是需要预先使用命令 gulp auto，文件如果修改了，就一步到位\ngulp.task(&apos;auto&apos;, () =&gt; {\ngulp.watch(&apos;src/*.js&apos;, [&apos;toes5&apos;]) // 需要转码的js文件位置 + 口令\ngulp.watch(&apos;dist/*.js&apos;, [&apos;jsmin&apos;]) // 需要压缩的js文件位置 + 口令</code></pre><p>});</p>\n<h5 id=\"7-流水线的骚操作\"><a href=\"#7-流水线的骚操作\" class=\"headerlink\" title=\"7. 流水线的骚操作\"></a>7. 流水线的骚操作</h5><p>在项目根目录终端运行 <code>gulp toes5</code>，就将 <code>es6</code> 文件转为 <code>es5</code> 文件了。运行 <code>gulp jsmin</code>，就将 <code>js</code> 文件稳稳当当地压缩了。</p>\n<p>如果我们需要一步到位，而且不用随时去执行这繁琐的命令，我们还可以使用监听。在项目根目录终端使用 <code>gulp auto</code>，然后每次修改开发文件( <code>src</code> 下的 <code>js</code> )，就会自动同步转码和压缩。【==监听还可以监听更多的 gulp task，这点非常重要==】</p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><h5 id=\"8-gulp-htmlmin-压缩html\"><a href=\"#8-gulp-htmlmin-压缩html\" class=\"headerlink\" title=\"8. gulp-htmlmin 压缩html\"></a>8. gulp-htmlmin 压缩html</h5><p><code>cnpm install gulp-htmlmin --save-dev</code></p>\n<pre><code>const htmlmin = require(&apos;gulp-htmlmin&apos;);\n\n// 压缩html和html页面内的css/js\ngulp.task(&apos;htmlmin&apos;, function () {\n    var options = {\n        removeComments: true,//清除HTML注释\n        collapseWhitespace: true,//压缩HTML\n        collapseBooleanAttributes: true,//省略布尔属性的值 &lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input /&gt;\n        removeEmptyAttributes: true,//删除所有空格作属性值 &lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt;\n        removeScriptTypeAttributes: true,//删除&lt;script&gt;的type=&quot;text/javascript&quot;\n        removeStyleLinkTypeAttributes: true,//删除&lt;style&gt;和&lt;link&gt;的type=&quot;text/css&quot;\n        minifyJS: true,//压缩页面JS\n        minifyCSS: true//压缩页面CSS\n    };\n    gulp.src(&apos;src/*.html&apos;)\n        .pipe(htmlmin(options))\n        .pipe(gulp.dest(&apos;min&apos;));\n});</code></pre><h5 id=\"9-gulp-clean-css-压缩css\"><a href=\"#9-gulp-clean-css-压缩css\" class=\"headerlink\" title=\"9. gulp-clean-css 压缩css\"></a>9. gulp-clean-css 压缩css</h5><p><code>cnpm install gulp-clean-css --save-dev</code></p>\n<pre><code>const cleanCSS = require(&apos;gulp-clean-css&apos;);\n\n// 压缩css文件, 如果有外部引用，为了保持项目结构，需要使用插件 gulp-sourcemaps\ngulp.task(&apos;cssmin&apos;, () =&gt; {\n    gulp.src(&apos;src/*.css&apos;)\n        .pipe(cleanCSS({compatibility: &apos;ie8&apos;})) // 兼容IE8及以下浏览器\n        .pipe(gulp.dest(&apos;min&apos;));\n});</code></pre><h5 id=\"10-gulp-concat-合并-js-文件\"><a href=\"#10-gulp-concat-合并-js-文件\" class=\"headerlink\" title=\"10. gulp-concat 合并 js 文件\"></a>10. gulp-concat 合并 js 文件</h5><p><code>cnpm install gulp-concat --save-dev</code></p>\n<pre><code>const concat = require(&apos;gulp-concat&apos;);\n\n// 合并 js 文件, 但不会转码和压缩\ngulp.task(&apos;jsconcat&apos;, function () {\n    gulp.src(&apos;src/*.js&apos;)\n        .pipe(concat(&apos;index.js&apos;))//合并后的文件名\n        .pipe(gulp.dest(&apos;dist&apos;));\n});</code></pre><h5 id=\"11-gulp-less-将less文件编译成css\"><a href=\"#11-gulp-less-将less文件编译成css\" class=\"headerlink\" title=\"11. gulp-less 将less文件编译成css\"></a>11. gulp-less 将less文件编译成css</h5><p><code>cnpm install gulp-less --save-dev</code></p>\n<pre><code>const less = require(&apos;gulp-less&apos;);\n\n// 编译less文件，如果有外部引用，为了保持项目结构，需要使用插件 gulp-sourcemaps\ngulp.task(&apos;lesstocss&apos;, function () {\n    //编译src目录下的所有less文件\n    //除了reset.less和test.less（**匹配src/less的0个或多个子文件夹）\n    gulp.src([&apos;src/*.less&apos;, &apos;!src/less/**/{reset,test}.less&apos;]) \n        .pipe(less())\n        // 编译后压缩css文件输出到min\n        .pipe(cleanCSS({compatibility: &apos;ie8&apos;})) // 兼容IE8及以下浏览器\n        .pipe(gulp.dest(&apos;min&apos;));\n});</code></pre><h5 id=\"12-gulp-autoprefixer-给-css-项处理浏览器前缀\"><a href=\"#12-gulp-autoprefixer-给-css-项处理浏览器前缀\" class=\"headerlink\" title=\"12. gulp-autoprefixer 给 css 项处理浏览器前缀\"></a>12. gulp-autoprefixer 给 css 项处理浏览器前缀</h5><p><code>cnpm install --save-dev gulp-autoprefixer</code></p>\n<pre><code>const autoprefixer = require(&apos;gulp-autoprefixer&apos;);\n\n// 自动补齐css前缀\ngulp.task(&apos;autoprefixer&apos;, () =&gt; {\n    gulp.src(&apos;src/index.css&apos;)\n        .pipe(autoprefixer({\n            browsers: [&apos;last 2 versions&apos;], // 主流浏览器的最新两个版本\n            cascade: true, // 是否美化属性值 默认：true\n            remove:true // 是否去掉不必要的前缀 默认：true \n        }))\n        .pipe(gulp.dest(&apos;dist&apos;))\n});\n\n\n\n// 需要适配的页面\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    @@include(&apos;include/header.html&apos;)\n\n    &lt;p&gt; 这是 layout 的内容 &lt;/p&gt;\n\n    @@include(&apos;include/footer.html&apos;)\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><h5 id=\"13-gulp-file-include-头尾共用、文件合并\"><a href=\"#13-gulp-file-include-头尾共用、文件合并\" class=\"headerlink\" title=\"13. gulp-file-include 头尾共用、文件合并\"></a>13. gulp-file-include 头尾共用、文件合并</h5><p><code>cnpm install gulp-file-include --save-dev</code></p>\n<pre><code>const fileinclude  = require(&apos;gulp-file-include&apos;);\n\n// 头尾共用\ngulp.task(&apos;fileinclude&apos;, () =&gt; {\n    // 适配page中所有文件夹下的所有html，排除page下的include文件夹中html\n        gulp.src([&apos;src/*.html&apos;,&apos;!src/include/**.html&apos;])\n        .pipe(fileinclude({\n          prefix: &apos;@@&apos;,\n          basepath: &apos;@file&apos;\n        }))\n    .pipe(gulp.dest(&apos;dist&apos;))\n});</code></pre><h5 id=\"14-gulp-livereload-监听文件变化局部刷新\"><a href=\"#14-gulp-livereload-监听文件变化局部刷新\" class=\"headerlink\" title=\"14. gulp-livereload 监听文件变化局部刷新\"></a>14. gulp-livereload 监听文件变化局部刷新</h5><h5 id=\"15-gulp-imagemin-压缩图片\"><a href=\"#15-gulp-imagemin-压缩图片\" class=\"headerlink\" title=\"15. gulp-imagemin 压缩图片\"></a>15. gulp-imagemin 压缩图片</h5><h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><pre><code>const gulp = require(&apos;gulp&apos;);\nconst babel = require(&apos;gulp-babel&apos;);\nconst uglify = require(&apos;gulp-uglify&apos;);\nconst htmlmin = require(&apos;gulp-htmlmin&apos;);\nconst cleanCSS = require(&apos;gulp-clean-css&apos;);\nconst concat = require(&apos;gulp-concat&apos;);\nconst less = require(&apos;gulp-less&apos;);\nconst autoprefixer = require(&apos;gulp-autoprefixer&apos;);\nconst fileinclude  = require(&apos;gulp-file-include&apos;);\n\n// 头尾共用\ngulp.task(&apos;fileinclude&apos;, () =&gt; {\n    // 适配page中所有文件夹下的所有html，排除page下的include文件夹中html\n        gulp.src([&apos;src/*.html&apos;,&apos;!src/include/**.html&apos;])\n        .pipe(fileinclude({\n          prefix: &apos;@@&apos;,\n          basepath: &apos;@file&apos;\n        }))\n    .pipe(gulp.dest(&apos;dist&apos;))\n});\n\n// 压缩html和html页面内的css/js\ngulp.task(&apos;htmlmin&apos;, function () {\n    var options = {\n        removeComments: true,//清除HTML注释\n        collapseWhitespace: true,//压缩HTML\n        collapseBooleanAttributes: true,//省略布尔属性的值 &lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input /&gt;\n        removeEmptyAttributes: true,//删除所有空格作属性值 &lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt;\n        removeScriptTypeAttributes: true,//删除&lt;script&gt;的type=&quot;text/javascript&quot;\n        removeStyleLinkTypeAttributes: true,//删除&lt;style&gt;和&lt;link&gt;的type=&quot;text/css&quot;\n        minifyJS: true,//压缩页面JS\n        minifyCSS: true//压缩页面CSS\n    };\n    gulp.src(&apos;dist/*.html&apos;)\n        .pipe(htmlmin(options))\n        .pipe(gulp.dest(&apos;min&apos;));\n});\n\n// 编译less文件，如果有外部引用，为了保持项目结构，需要使用插件 gulp-sourcemaps\ngulp.task(&apos;lesstocss&apos;, function () {\n    //编译src目录下的所有less文件\n    //除了reset.less和test.less（**匹配src的0个或多个子文件夹）\n    gulp.src([&apos;src/*.less&apos;, &apos;!src/**/{reset,test}.less&apos;]) \n        .pipe(less())\n        // 编译后自动补齐css前缀\n        .pipe(autoprefixer({\n            browsers: [&apos;last 2 versions&apos;], // 主流浏览器的最新两个版本\n            cascade: true, // 是否美化属性值 默认：true\n            remove:true // 是否去掉不必要的前缀 默认：true \n        }))\n        // 然后压缩css文件输出到min\n        .pipe(cleanCSS({compatibility: &apos;ie8&apos;})) // 兼容IE8及以下浏览器\n        .pipe(gulp.dest(&apos;min&apos;));\n});\n\n// ES6代码转码为ES5\ngulp.task(&apos;toes5&apos;, () =&gt;\n    gulp.src(&apos;src/*.js&apos;) // 需要转码的es6文件，这里代表src文件夹下的所有js文件\n        /*\n        最新的presets: [&apos;env&apos;]，是通用版，可以转码es2015、react、es2017, \n        这里只用于转码es2015，你可以下载相关转码依赖\n        */\n        .pipe(babel({\n            presets: [&apos;env&apos;]\n        }))\n        .pipe(gulp.dest(&apos;dist&apos;)) // 转码后的文件输出位置\n);\n\n// 合并 js 文件, 但不会转码和压缩\ngulp.task(&apos;jsconcat&apos;, () =&gt; {\n    gulp.src(&apos;src/*.js&apos;)\n        .pipe(concat(&apos;index.js&apos;)) // 合并后的文件名\n        .pipe(gulp.dest(&apos;dist&apos;))\n});\n\n// JS代码压缩\ngulp.task(&apos;jsmin&apos;, () =&gt;\n    gulp.src(&apos;dist/*.js&apos;) // 需要压缩的js文件\n        .pipe(uglify())\n        .pipe(gulp.dest(&apos;min&apos;)) // 压缩的js文件输出位置\n);\n\n\n\n// // 使用监听，但是需要预先使用命令 gulp auto，文件如果修改了，就一步到位\n// gulp.task(&apos;auto&apos;, () =&gt; {\n//     gulp.watch(&apos;src/*.js&apos;, [&apos;toes5&apos;]) // 需要转码的js文件位置 + 口令\n//     gulp.watch(&apos;dist/*.js&apos;, [&apos;jsmin&apos;]) // 需要压缩的js文件位置 + 口令\n//     // gulp.watch...\n// });</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"gulp-转码项目中的ES6-ES5并压缩js\"><a href=\"#gulp-转码项目中的ES6-ES5并压缩js\" class=\"headerlink\" title=\"gulp-转码项目中的ES6-ES5并压缩js\"></a>gulp-转码项目中的ES6-ES5并压缩js</h4><p>在这之前，请确保你的 <code>node</code> 和 <code>npm</code> 已经安装无误，可以用<code>node -v</code> 和 <code>npm -v</code>查看 <code>node</code> 和 <code>npm</code> 的版本。</p>\n<p>好了，接下来，gulp-babel，转码压缩，七步到位，走你！</p>\n<h5 id=\"1-全局安装-gulp\"><a href=\"#1-全局安装-gulp\" class=\"headerlink\" title=\"1. 全局安装 gulp\"></a>1. 全局安装 gulp</h5><p>终端执行 <code>cnpm install gulp -g</code>。(这里默认大家已经安装了<a href=\"http://npm.taobao.org/\" target=\"_blank\" rel=\"noopener\">淘宝镜像</a>，没有安装也可以使用 <code>npm</code>)。</p>\n<p>安装完毕后可以使用 <code>gulp -v</code>检测版本。</p>\n<h5 id=\"2-在项目中安装-babel\"><a href=\"#2-在项目中安装-babel\" class=\"headerlink\" title=\"2. 在项目中安装 babel\"></a>2. 在项目中安装 babel</h5><p>在项目根目录执行 <code>cnpm install babel-cli</code>，等待安装好项目所依赖的<code>babel</code>。</p>\n<p>安装完毕后可以使用 <code>.\\node_modules\\.bin\\babel --version</code> 检测版本。这时候你可以在你的项目中看到一个node_modules文件夹。</p>\n<h5 id=\"3-在项目中安装-gulp\"><a href=\"#3-在项目中安装-gulp\" class=\"headerlink\" title=\"3. 在项目中安装 gulp\"></a>3. 在项目中安装 gulp</h5><p>在项目根目录执行 <code>cnpm install gulp</code>，安装项目中的 <code>gulp</code>。</p>\n<h5 id=\"4-在项目中安装-gulp-babel\"><a href=\"#4-在项目中安装-gulp-babel\" class=\"headerlink\" title=\"4. 在项目中安装 gulp-babel\"></a>4. 在项目中安装 gulp-babel</h5><p>在项目根目录执行 <code>cnpm install --save-dev gulp-babel babel-preset-env</code>。</p>\n<p>安装完毕后，你可以看到你的项目出现了 <code>package.json</code>(如果你没有预先 <code>npm init</code> 或者安装依赖的话一般是不会出现这个文件的)，你可以检测文件里会出现了以下依赖：</p>\n<pre><code>{\n  &quot;devDependencies&quot;: {\n    &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;,\n    &quot;gulp-babel&quot;: &quot;^7.0.0&quot;\n  }\n}</code></pre><h5 id=\"5-在项目中安装-gulp-uglify\"><a href=\"#5-在项目中安装-gulp-uglify\" class=\"headerlink\" title=\"5. 在项目中安装 gulp-uglify\"></a>5. 在项目中安装 gulp-uglify</h5><p>在项目根目录执行 <code>cnpm install gulp-uglify --save-dev</code>, 于是 <code>package.json</code> 变成了这样：</p>\n<pre><code>{\n  &quot;devDependencies&quot;: {\n    &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;,\n    &quot;gulp-babel&quot;: &quot;^7.0.0&quot;,\n    &quot;gulp-uglify&quot;: &quot;^3.0.0&quot;\n  }\n}</code></pre><h5 id=\"6-根目录创建-gulpfile-js\"><a href=\"#6-根目录创建-gulpfile-js\" class=\"headerlink\" title=\"6.根目录创建 gulpfile.js\"></a>6.根目录创建 gulpfile.js</h5><p>在项目根目录创建 <code>gulpfile.js</code>，里面的代码是这样的：</p>\n<pre><code>const gulp = require(&apos;gulp&apos;); // 引入gulp\nconst babel = require(&apos;gulp-babel&apos;); // 引入gulp-babel\nconst uglify = require(&apos;gulp-uglify&apos;); // 引入gulp-uglify\n\n// ES6代码转码为ES5\ngulp.task(&apos;toes5&apos;, () =&gt;\n    gulp.src(&apos;src/*.js&apos;) // 需要转码的es6文件，这里代表src文件夹下的所有js文件\n        /*\n        最新的presets: [&apos;env&apos;]，是通用版，可以转码es2015、react、es2017, \n        这里只用于转码es2015，你可以下载相关转码依赖\n        */\n        .pipe(babel({\n            presets: [&apos;env&apos;]\n        }))\n        .pipe(gulp.dest(&apos;dist&apos;)) // 转码后的文件输出位置\n);\n\n// JS代码压缩\ngulp.task(&apos;jsmin&apos;, () =&gt;\n    gulp.src(&apos;dist/*.js&apos;) // 需要压缩的js文件\n        .pipe(uglify())\n        .pipe(gulp.dest(&apos;min&apos;)) // 压缩的js文件输出位置\n);\n\n// 使用监听，但是需要预先使用命令 gulp auto，文件如果修改了，就一步到位\ngulp.task(&apos;auto&apos;, () =&gt; {\ngulp.watch(&apos;src/*.js&apos;, [&apos;toes5&apos;]) // 需要转码的js文件位置 + 口令\ngulp.watch(&apos;dist/*.js&apos;, [&apos;jsmin&apos;]) // 需要压缩的js文件位置 + 口令</code></pre><p>});</p>\n<h5 id=\"7-流水线的骚操作\"><a href=\"#7-流水线的骚操作\" class=\"headerlink\" title=\"7. 流水线的骚操作\"></a>7. 流水线的骚操作</h5><p>在项目根目录终端运行 <code>gulp toes5</code>，就将 <code>es6</code> 文件转为 <code>es5</code> 文件了。运行 <code>gulp jsmin</code>，就将 <code>js</code> 文件稳稳当当地压缩了。</p>\n<p>如果我们需要一步到位，而且不用随时去执行这繁琐的命令，我们还可以使用监听。在项目根目录终端使用 <code>gulp auto</code>，然后每次修改开发文件( <code>src</code> 下的 <code>js</code> )，就会自动同步转码和压缩。【==监听还可以监听更多的 gulp task，这点非常重要==】</p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><h5 id=\"8-gulp-htmlmin-压缩html\"><a href=\"#8-gulp-htmlmin-压缩html\" class=\"headerlink\" title=\"8. gulp-htmlmin 压缩html\"></a>8. gulp-htmlmin 压缩html</h5><p><code>cnpm install gulp-htmlmin --save-dev</code></p>\n<pre><code>const htmlmin = require(&apos;gulp-htmlmin&apos;);\n\n// 压缩html和html页面内的css/js\ngulp.task(&apos;htmlmin&apos;, function () {\n    var options = {\n        removeComments: true,//清除HTML注释\n        collapseWhitespace: true,//压缩HTML\n        collapseBooleanAttributes: true,//省略布尔属性的值 &lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input /&gt;\n        removeEmptyAttributes: true,//删除所有空格作属性值 &lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt;\n        removeScriptTypeAttributes: true,//删除&lt;script&gt;的type=&quot;text/javascript&quot;\n        removeStyleLinkTypeAttributes: true,//删除&lt;style&gt;和&lt;link&gt;的type=&quot;text/css&quot;\n        minifyJS: true,//压缩页面JS\n        minifyCSS: true//压缩页面CSS\n    };\n    gulp.src(&apos;src/*.html&apos;)\n        .pipe(htmlmin(options))\n        .pipe(gulp.dest(&apos;min&apos;));\n});</code></pre><h5 id=\"9-gulp-clean-css-压缩css\"><a href=\"#9-gulp-clean-css-压缩css\" class=\"headerlink\" title=\"9. gulp-clean-css 压缩css\"></a>9. gulp-clean-css 压缩css</h5><p><code>cnpm install gulp-clean-css --save-dev</code></p>\n<pre><code>const cleanCSS = require(&apos;gulp-clean-css&apos;);\n\n// 压缩css文件, 如果有外部引用，为了保持项目结构，需要使用插件 gulp-sourcemaps\ngulp.task(&apos;cssmin&apos;, () =&gt; {\n    gulp.src(&apos;src/*.css&apos;)\n        .pipe(cleanCSS({compatibility: &apos;ie8&apos;})) // 兼容IE8及以下浏览器\n        .pipe(gulp.dest(&apos;min&apos;));\n});</code></pre><h5 id=\"10-gulp-concat-合并-js-文件\"><a href=\"#10-gulp-concat-合并-js-文件\" class=\"headerlink\" title=\"10. gulp-concat 合并 js 文件\"></a>10. gulp-concat 合并 js 文件</h5><p><code>cnpm install gulp-concat --save-dev</code></p>\n<pre><code>const concat = require(&apos;gulp-concat&apos;);\n\n// 合并 js 文件, 但不会转码和压缩\ngulp.task(&apos;jsconcat&apos;, function () {\n    gulp.src(&apos;src/*.js&apos;)\n        .pipe(concat(&apos;index.js&apos;))//合并后的文件名\n        .pipe(gulp.dest(&apos;dist&apos;));\n});</code></pre><h5 id=\"11-gulp-less-将less文件编译成css\"><a href=\"#11-gulp-less-将less文件编译成css\" class=\"headerlink\" title=\"11. gulp-less 将less文件编译成css\"></a>11. gulp-less 将less文件编译成css</h5><p><code>cnpm install gulp-less --save-dev</code></p>\n<pre><code>const less = require(&apos;gulp-less&apos;);\n\n// 编译less文件，如果有外部引用，为了保持项目结构，需要使用插件 gulp-sourcemaps\ngulp.task(&apos;lesstocss&apos;, function () {\n    //编译src目录下的所有less文件\n    //除了reset.less和test.less（**匹配src/less的0个或多个子文件夹）\n    gulp.src([&apos;src/*.less&apos;, &apos;!src/less/**/{reset,test}.less&apos;]) \n        .pipe(less())\n        // 编译后压缩css文件输出到min\n        .pipe(cleanCSS({compatibility: &apos;ie8&apos;})) // 兼容IE8及以下浏览器\n        .pipe(gulp.dest(&apos;min&apos;));\n});</code></pre><h5 id=\"12-gulp-autoprefixer-给-css-项处理浏览器前缀\"><a href=\"#12-gulp-autoprefixer-给-css-项处理浏览器前缀\" class=\"headerlink\" title=\"12. gulp-autoprefixer 给 css 项处理浏览器前缀\"></a>12. gulp-autoprefixer 给 css 项处理浏览器前缀</h5><p><code>cnpm install --save-dev gulp-autoprefixer</code></p>\n<pre><code>const autoprefixer = require(&apos;gulp-autoprefixer&apos;);\n\n// 自动补齐css前缀\ngulp.task(&apos;autoprefixer&apos;, () =&gt; {\n    gulp.src(&apos;src/index.css&apos;)\n        .pipe(autoprefixer({\n            browsers: [&apos;last 2 versions&apos;], // 主流浏览器的最新两个版本\n            cascade: true, // 是否美化属性值 默认：true\n            remove:true // 是否去掉不必要的前缀 默认：true \n        }))\n        .pipe(gulp.dest(&apos;dist&apos;))\n});\n\n\n\n// 需要适配的页面\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    @@include(&apos;include/header.html&apos;)\n\n    &lt;p&gt; 这是 layout 的内容 &lt;/p&gt;\n\n    @@include(&apos;include/footer.html&apos;)\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><h5 id=\"13-gulp-file-include-头尾共用、文件合并\"><a href=\"#13-gulp-file-include-头尾共用、文件合并\" class=\"headerlink\" title=\"13. gulp-file-include 头尾共用、文件合并\"></a>13. gulp-file-include 头尾共用、文件合并</h5><p><code>cnpm install gulp-file-include --save-dev</code></p>\n<pre><code>const fileinclude  = require(&apos;gulp-file-include&apos;);\n\n// 头尾共用\ngulp.task(&apos;fileinclude&apos;, () =&gt; {\n    // 适配page中所有文件夹下的所有html，排除page下的include文件夹中html\n        gulp.src([&apos;src/*.html&apos;,&apos;!src/include/**.html&apos;])\n        .pipe(fileinclude({\n          prefix: &apos;@@&apos;,\n          basepath: &apos;@file&apos;\n        }))\n    .pipe(gulp.dest(&apos;dist&apos;))\n});</code></pre><h5 id=\"14-gulp-livereload-监听文件变化局部刷新\"><a href=\"#14-gulp-livereload-监听文件变化局部刷新\" class=\"headerlink\" title=\"14. gulp-livereload 监听文件变化局部刷新\"></a>14. gulp-livereload 监听文件变化局部刷新</h5><h5 id=\"15-gulp-imagemin-压缩图片\"><a href=\"#15-gulp-imagemin-压缩图片\" class=\"headerlink\" title=\"15. gulp-imagemin 压缩图片\"></a>15. gulp-imagemin 压缩图片</h5><h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><pre><code>const gulp = require(&apos;gulp&apos;);\nconst babel = require(&apos;gulp-babel&apos;);\nconst uglify = require(&apos;gulp-uglify&apos;);\nconst htmlmin = require(&apos;gulp-htmlmin&apos;);\nconst cleanCSS = require(&apos;gulp-clean-css&apos;);\nconst concat = require(&apos;gulp-concat&apos;);\nconst less = require(&apos;gulp-less&apos;);\nconst autoprefixer = require(&apos;gulp-autoprefixer&apos;);\nconst fileinclude  = require(&apos;gulp-file-include&apos;);\n\n// 头尾共用\ngulp.task(&apos;fileinclude&apos;, () =&gt; {\n    // 适配page中所有文件夹下的所有html，排除page下的include文件夹中html\n        gulp.src([&apos;src/*.html&apos;,&apos;!src/include/**.html&apos;])\n        .pipe(fileinclude({\n          prefix: &apos;@@&apos;,\n          basepath: &apos;@file&apos;\n        }))\n    .pipe(gulp.dest(&apos;dist&apos;))\n});\n\n// 压缩html和html页面内的css/js\ngulp.task(&apos;htmlmin&apos;, function () {\n    var options = {\n        removeComments: true,//清除HTML注释\n        collapseWhitespace: true,//压缩HTML\n        collapseBooleanAttributes: true,//省略布尔属性的值 &lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input /&gt;\n        removeEmptyAttributes: true,//删除所有空格作属性值 &lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt;\n        removeScriptTypeAttributes: true,//删除&lt;script&gt;的type=&quot;text/javascript&quot;\n        removeStyleLinkTypeAttributes: true,//删除&lt;style&gt;和&lt;link&gt;的type=&quot;text/css&quot;\n        minifyJS: true,//压缩页面JS\n        minifyCSS: true//压缩页面CSS\n    };\n    gulp.src(&apos;dist/*.html&apos;)\n        .pipe(htmlmin(options))\n        .pipe(gulp.dest(&apos;min&apos;));\n});\n\n// 编译less文件，如果有外部引用，为了保持项目结构，需要使用插件 gulp-sourcemaps\ngulp.task(&apos;lesstocss&apos;, function () {\n    //编译src目录下的所有less文件\n    //除了reset.less和test.less（**匹配src的0个或多个子文件夹）\n    gulp.src([&apos;src/*.less&apos;, &apos;!src/**/{reset,test}.less&apos;]) \n        .pipe(less())\n        // 编译后自动补齐css前缀\n        .pipe(autoprefixer({\n            browsers: [&apos;last 2 versions&apos;], // 主流浏览器的最新两个版本\n            cascade: true, // 是否美化属性值 默认：true\n            remove:true // 是否去掉不必要的前缀 默认：true \n        }))\n        // 然后压缩css文件输出到min\n        .pipe(cleanCSS({compatibility: &apos;ie8&apos;})) // 兼容IE8及以下浏览器\n        .pipe(gulp.dest(&apos;min&apos;));\n});\n\n// ES6代码转码为ES5\ngulp.task(&apos;toes5&apos;, () =&gt;\n    gulp.src(&apos;src/*.js&apos;) // 需要转码的es6文件，这里代表src文件夹下的所有js文件\n        /*\n        最新的presets: [&apos;env&apos;]，是通用版，可以转码es2015、react、es2017, \n        这里只用于转码es2015，你可以下载相关转码依赖\n        */\n        .pipe(babel({\n            presets: [&apos;env&apos;]\n        }))\n        .pipe(gulp.dest(&apos;dist&apos;)) // 转码后的文件输出位置\n);\n\n// 合并 js 文件, 但不会转码和压缩\ngulp.task(&apos;jsconcat&apos;, () =&gt; {\n    gulp.src(&apos;src/*.js&apos;)\n        .pipe(concat(&apos;index.js&apos;)) // 合并后的文件名\n        .pipe(gulp.dest(&apos;dist&apos;))\n});\n\n// JS代码压缩\ngulp.task(&apos;jsmin&apos;, () =&gt;\n    gulp.src(&apos;dist/*.js&apos;) // 需要压缩的js文件\n        .pipe(uglify())\n        .pipe(gulp.dest(&apos;min&apos;)) // 压缩的js文件输出位置\n);\n\n\n\n// // 使用监听，但是需要预先使用命令 gulp auto，文件如果修改了，就一步到位\n// gulp.task(&apos;auto&apos;, () =&gt; {\n//     gulp.watch(&apos;src/*.js&apos;, [&apos;toes5&apos;]) // 需要转码的js文件位置 + 口令\n//     gulp.watch(&apos;dist/*.js&apos;, [&apos;jsmin&apos;]) // 需要压缩的js文件位置 + 口令\n//     // gulp.watch...\n// });</code></pre>"},{"title":"JS中的严格模式","date":"2019-03-18T06:21:08.000Z","_content":"\n## \"use strict\"\n\n&#160; &#160; &#160; &#160;`\"use strict\"`是`ECMAScript`引入的一条指令。指令不是语句（但非常接近于语句）。\n\n##### 1. 与普通语句的区别\n&#160; &#160; &#160; &#160;`\"use strict\"`指令和普通的语句之间有两个重要的`区别`：\n - 它不包含任何语言的`关键字`，指令仅仅是一个包含一个特殊字符串直接量的表达式（可以是使用单引号也可以使用双引号），对于那些没有实现`ECMAScript5`的JavaScript的解释器来说，它只是一条没有副作用的表达式语句，它什么也没做。将来的ECMAScript标准希望将use用做关键字，这样就可以省略引号了。\n -  它只能出现在脚本代码的开始或者函数体的开始，任何实体语句之前。但它不必一定出现在脚本的首行或函数体内的首行，因为`\"use strict\"`指令之后或之前都可以能有其它字符串直接量表达式语句，并且JavaScript的具体实现可能将它们解析为解释器自有的指令。在脚本或者函数体内第一条常规语句之后字符串直接量表达式语句只当做普通的表达式语句对待；它们不会当做指令解析，它们也没有任何副作用。\n\n##### 2. 指令的目的\n&#160; &#160; &#160; &#160;使用`\"use strict\"`指令的目的是说明（脚本或函数中）后续的代码将会解析为严格代码`(strict code)`.如果顶层（不在任何函数内的）代码使用了`\"use strict\"`指令，那么它们就是严格代码。如果函数体内定义所处的代码是严格代码或者函数体使用了`\"use strict\"`指令，那么函数体的代码也是严格代码。如果`eval()`调用时所处的代码是严格代码或者`eval()`要执行的字符串中使用了`\"use strict\"`指令，则`eval()`内的代码是严格代码。\n\n##### 3. 与非严格模式的区别\n&#160; &#160; &#160; &#160;严格代码以严格模式执行。`ECMAScript5`中的严格模式是该语言的一个受限制的子集，它修正了语言的重要缺陷，并提供健壮的查错功能和增强的安全机制。严格模式和非严格模式之间的区别如下（前三条十分重要）。\n -  在严格模式中禁止使用`with`语句。\n - 在严格模式中，`所有的变量`都要首先声明，如果给一个未声明的变量、函数、函数参数、catch从句参数或全局对象的属性赋值，将会抛出一个引用错误异常（在非严格模式中，这种隐式声明的全局变量的方法是给全局对象新添加一个新属性）。\n - 在严格模式中，调用的函数（不是方法）中的一个`this`值是`undefined`。（在非严格模式中，调用的函数中的this值总是全局对象）。可以利用这种特殊来判断JavaScript实现是否支持严格模式。\n ```\nvar hasStrictMode = (function(){ \"use strict\"; return this===undefined}());\n```\n - 同样，在严格模式中，当通过`call()`或者`apply()`来调用函数时，其中的this值就是通过`call()`或者`apply()`传入的第一个参数（在非严格模式中，null和undefined值被全局对象和转换为对象的非对象值所代替）。\n - 在严格模式中，给只读属性赋值和给不可扩展的对象穿件新成员都将抛出一个类型错误异常（在非严格模式中，这些操作知识简单地操作失败，不会报错）。\n - 在严格模式中，传入`eval()`的代码不能再调用程序所在的上下文中声明变量或定义函数，而在费严格模式中是可以这样做得。相反，变量和函数的定义都是在`eval()`创建的新作用域中，这个作用域在`eval()`返回时就弃用了。\n - 在严格模式中，函数里的`arguments`对象拥有传入函数值的静态副本。在非严格模式中，`arguments`对象具有`“魔术般”`的行为，`arguments`里的数组元素和函数参数都是指向同一个值的引用。\n - 在严格模式中，当`delete`运算符后跟随非法的标识符（比如变量、函数、函数参数）时，将会抛出一个语法错误异常（在非严格模式中，这种`delete`表达式什么也没做，并返回false）。\n - 在严格模式中，试图删除一个不可配置的属性将会抛出一个类型错误异常（在非严格模式中，`delete`表达式操作失败，并返回false）。\n - 在严格模式中，在一个对象直接量中定义两个或多个同名属性将产生一个语法错误（在非严格模式中不会报错）。\n - 在严格模式中，函数声明中个存在两个或多个同名的参数将产生一个语法错误（在非严格模式中不会报错）。\n - 在严格模式中是不允许使用八进制整数直接量（以0为前缀，而不是以0x为前缀）的（在非严格模式中某些实现是允许八进制整数直接量的）。\n - 在严格模式中，标识符`eval`和`arguments`当做关键字，他们的值是不能更改的。不能给这些标识符赋值，也不能把它们声明为变量、用做函数名、用做函数参数或用做`catch`块的标识符。\n - 在严格模式中限制了对调用栈的检测能力，在严格模式的函数中，`arguments`、`caller`和`argument.callee`都会抛出一个类型错误异常。严格模式的函数同样据用`caller`和`arguments`属性，当访问这两个属性时将抛出类型错误异常（有一些JavaScript的实现在非严格模式里定义了这些非标准的属性）。\n\n\n","source":"_posts/JS中的严格模式.md","raw":"---\ntitle: JS中的严格模式\ndate: 2019-03-18 14:21:08  \ncategories: JavaScript  \ntags:\n---\n\n## \"use strict\"\n\n&#160; &#160; &#160; &#160;`\"use strict\"`是`ECMAScript`引入的一条指令。指令不是语句（但非常接近于语句）。\n\n##### 1. 与普通语句的区别\n&#160; &#160; &#160; &#160;`\"use strict\"`指令和普通的语句之间有两个重要的`区别`：\n - 它不包含任何语言的`关键字`，指令仅仅是一个包含一个特殊字符串直接量的表达式（可以是使用单引号也可以使用双引号），对于那些没有实现`ECMAScript5`的JavaScript的解释器来说，它只是一条没有副作用的表达式语句，它什么也没做。将来的ECMAScript标准希望将use用做关键字，这样就可以省略引号了。\n -  它只能出现在脚本代码的开始或者函数体的开始，任何实体语句之前。但它不必一定出现在脚本的首行或函数体内的首行，因为`\"use strict\"`指令之后或之前都可以能有其它字符串直接量表达式语句，并且JavaScript的具体实现可能将它们解析为解释器自有的指令。在脚本或者函数体内第一条常规语句之后字符串直接量表达式语句只当做普通的表达式语句对待；它们不会当做指令解析，它们也没有任何副作用。\n\n##### 2. 指令的目的\n&#160; &#160; &#160; &#160;使用`\"use strict\"`指令的目的是说明（脚本或函数中）后续的代码将会解析为严格代码`(strict code)`.如果顶层（不在任何函数内的）代码使用了`\"use strict\"`指令，那么它们就是严格代码。如果函数体内定义所处的代码是严格代码或者函数体使用了`\"use strict\"`指令，那么函数体的代码也是严格代码。如果`eval()`调用时所处的代码是严格代码或者`eval()`要执行的字符串中使用了`\"use strict\"`指令，则`eval()`内的代码是严格代码。\n\n##### 3. 与非严格模式的区别\n&#160; &#160; &#160; &#160;严格代码以严格模式执行。`ECMAScript5`中的严格模式是该语言的一个受限制的子集，它修正了语言的重要缺陷，并提供健壮的查错功能和增强的安全机制。严格模式和非严格模式之间的区别如下（前三条十分重要）。\n -  在严格模式中禁止使用`with`语句。\n - 在严格模式中，`所有的变量`都要首先声明，如果给一个未声明的变量、函数、函数参数、catch从句参数或全局对象的属性赋值，将会抛出一个引用错误异常（在非严格模式中，这种隐式声明的全局变量的方法是给全局对象新添加一个新属性）。\n - 在严格模式中，调用的函数（不是方法）中的一个`this`值是`undefined`。（在非严格模式中，调用的函数中的this值总是全局对象）。可以利用这种特殊来判断JavaScript实现是否支持严格模式。\n ```\nvar hasStrictMode = (function(){ \"use strict\"; return this===undefined}());\n```\n - 同样，在严格模式中，当通过`call()`或者`apply()`来调用函数时，其中的this值就是通过`call()`或者`apply()`传入的第一个参数（在非严格模式中，null和undefined值被全局对象和转换为对象的非对象值所代替）。\n - 在严格模式中，给只读属性赋值和给不可扩展的对象穿件新成员都将抛出一个类型错误异常（在非严格模式中，这些操作知识简单地操作失败，不会报错）。\n - 在严格模式中，传入`eval()`的代码不能再调用程序所在的上下文中声明变量或定义函数，而在费严格模式中是可以这样做得。相反，变量和函数的定义都是在`eval()`创建的新作用域中，这个作用域在`eval()`返回时就弃用了。\n - 在严格模式中，函数里的`arguments`对象拥有传入函数值的静态副本。在非严格模式中，`arguments`对象具有`“魔术般”`的行为，`arguments`里的数组元素和函数参数都是指向同一个值的引用。\n - 在严格模式中，当`delete`运算符后跟随非法的标识符（比如变量、函数、函数参数）时，将会抛出一个语法错误异常（在非严格模式中，这种`delete`表达式什么也没做，并返回false）。\n - 在严格模式中，试图删除一个不可配置的属性将会抛出一个类型错误异常（在非严格模式中，`delete`表达式操作失败，并返回false）。\n - 在严格模式中，在一个对象直接量中定义两个或多个同名属性将产生一个语法错误（在非严格模式中不会报错）。\n - 在严格模式中，函数声明中个存在两个或多个同名的参数将产生一个语法错误（在非严格模式中不会报错）。\n - 在严格模式中是不允许使用八进制整数直接量（以0为前缀，而不是以0x为前缀）的（在非严格模式中某些实现是允许八进制整数直接量的）。\n - 在严格模式中，标识符`eval`和`arguments`当做关键字，他们的值是不能更改的。不能给这些标识符赋值，也不能把它们声明为变量、用做函数名、用做函数参数或用做`catch`块的标识符。\n - 在严格模式中限制了对调用栈的检测能力，在严格模式的函数中，`arguments`、`caller`和`argument.callee`都会抛出一个类型错误异常。严格模式的函数同样据用`caller`和`arguments`属性，当访问这两个属性时将抛出类型错误异常（有一些JavaScript的实现在非严格模式里定义了这些非标准的属性）。\n\n\n","slug":"JS中的严格模式","published":1,"updated":"2020-04-01T02:15:52.391Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8gp7rxs0003kb9hetw8dkcd","content":"<h2 id=\"“use-strict”\"><a href=\"#“use-strict”\" class=\"headerlink\" title=\"“use strict”\"></a>“use strict”</h2><p>&#160; &#160; &#160; &#160;<code>&quot;use strict&quot;</code>是<code>ECMAScript</code>引入的一条指令。指令不是语句（但非常接近于语句）。</p>\n<h5 id=\"1-与普通语句的区别\"><a href=\"#1-与普通语句的区别\" class=\"headerlink\" title=\"1. 与普通语句的区别\"></a>1. 与普通语句的区别</h5><p>&#160; &#160; &#160; &#160;<code>&quot;use strict&quot;</code>指令和普通的语句之间有两个重要的<code>区别</code>：</p>\n<ul>\n<li>它不包含任何语言的<code>关键字</code>，指令仅仅是一个包含一个特殊字符串直接量的表达式（可以是使用单引号也可以使用双引号），对于那些没有实现<code>ECMAScript5</code>的JavaScript的解释器来说，它只是一条没有副作用的表达式语句，它什么也没做。将来的ECMAScript标准希望将use用做关键字，这样就可以省略引号了。</li>\n<li>它只能出现在脚本代码的开始或者函数体的开始，任何实体语句之前。但它不必一定出现在脚本的首行或函数体内的首行，因为<code>&quot;use strict&quot;</code>指令之后或之前都可以能有其它字符串直接量表达式语句，并且JavaScript的具体实现可能将它们解析为解释器自有的指令。在脚本或者函数体内第一条常规语句之后字符串直接量表达式语句只当做普通的表达式语句对待；它们不会当做指令解析，它们也没有任何副作用。</li>\n</ul>\n<h5 id=\"2-指令的目的\"><a href=\"#2-指令的目的\" class=\"headerlink\" title=\"2. 指令的目的\"></a>2. 指令的目的</h5><p>&#160; &#160; &#160; &#160;使用<code>&quot;use strict&quot;</code>指令的目的是说明（脚本或函数中）后续的代码将会解析为严格代码<code>(strict code)</code>.如果顶层（不在任何函数内的）代码使用了<code>&quot;use strict&quot;</code>指令，那么它们就是严格代码。如果函数体内定义所处的代码是严格代码或者函数体使用了<code>&quot;use strict&quot;</code>指令，那么函数体的代码也是严格代码。如果<code>eval()</code>调用时所处的代码是严格代码或者<code>eval()</code>要执行的字符串中使用了<code>&quot;use strict&quot;</code>指令，则<code>eval()</code>内的代码是严格代码。</p>\n<h5 id=\"3-与非严格模式的区别\"><a href=\"#3-与非严格模式的区别\" class=\"headerlink\" title=\"3. 与非严格模式的区别\"></a>3. 与非严格模式的区别</h5><p>&#160; &#160; &#160; &#160;严格代码以严格模式执行。<code>ECMAScript5</code>中的严格模式是该语言的一个受限制的子集，它修正了语言的重要缺陷，并提供健壮的查错功能和增强的安全机制。严格模式和非严格模式之间的区别如下（前三条十分重要）。</p>\n<ul>\n<li>在严格模式中禁止使用<code>with</code>语句。</li>\n<li>在严格模式中，<code>所有的变量</code>都要首先声明，如果给一个未声明的变量、函数、函数参数、catch从句参数或全局对象的属性赋值，将会抛出一个引用错误异常（在非严格模式中，这种隐式声明的全局变量的方法是给全局对象新添加一个新属性）。</li>\n<li>在严格模式中，调用的函数（不是方法）中的一个<code>this</code>值是<code>undefined</code>。（在非严格模式中，调用的函数中的this值总是全局对象）。可以利用这种特殊来判断JavaScript实现是否支持严格模式。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var hasStrictMode &#x3D; (function()&#123; &quot;use strict&quot;; return this&#x3D;&#x3D;&#x3D;undefined&#125;());</span><br></pre></td></tr></table></figure></li>\n<li>同样，在严格模式中，当通过<code>call()</code>或者<code>apply()</code>来调用函数时，其中的this值就是通过<code>call()</code>或者<code>apply()</code>传入的第一个参数（在非严格模式中，null和undefined值被全局对象和转换为对象的非对象值所代替）。</li>\n<li>在严格模式中，给只读属性赋值和给不可扩展的对象穿件新成员都将抛出一个类型错误异常（在非严格模式中，这些操作知识简单地操作失败，不会报错）。</li>\n<li>在严格模式中，传入<code>eval()</code>的代码不能再调用程序所在的上下文中声明变量或定义函数，而在费严格模式中是可以这样做得。相反，变量和函数的定义都是在<code>eval()</code>创建的新作用域中，这个作用域在<code>eval()</code>返回时就弃用了。</li>\n<li>在严格模式中，函数里的<code>arguments</code>对象拥有传入函数值的静态副本。在非严格模式中，<code>arguments</code>对象具有<code>“魔术般”</code>的行为，<code>arguments</code>里的数组元素和函数参数都是指向同一个值的引用。</li>\n<li>在严格模式中，当<code>delete</code>运算符后跟随非法的标识符（比如变量、函数、函数参数）时，将会抛出一个语法错误异常（在非严格模式中，这种<code>delete</code>表达式什么也没做，并返回false）。</li>\n<li>在严格模式中，试图删除一个不可配置的属性将会抛出一个类型错误异常（在非严格模式中，<code>delete</code>表达式操作失败，并返回false）。</li>\n<li>在严格模式中，在一个对象直接量中定义两个或多个同名属性将产生一个语法错误（在非严格模式中不会报错）。</li>\n<li>在严格模式中，函数声明中个存在两个或多个同名的参数将产生一个语法错误（在非严格模式中不会报错）。</li>\n<li>在严格模式中是不允许使用八进制整数直接量（以0为前缀，而不是以0x为前缀）的（在非严格模式中某些实现是允许八进制整数直接量的）。</li>\n<li>在严格模式中，标识符<code>eval</code>和<code>arguments</code>当做关键字，他们的值是不能更改的。不能给这些标识符赋值，也不能把它们声明为变量、用做函数名、用做函数参数或用做<code>catch</code>块的标识符。</li>\n<li>在严格模式中限制了对调用栈的检测能力，在严格模式的函数中，<code>arguments</code>、<code>caller</code>和<code>argument.callee</code>都会抛出一个类型错误异常。严格模式的函数同样据用<code>caller</code>和<code>arguments</code>属性，当访问这两个属性时将抛出类型错误异常（有一些JavaScript的实现在非严格模式里定义了这些非标准的属性）。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"“use-strict”\"><a href=\"#“use-strict”\" class=\"headerlink\" title=\"“use strict”\"></a>“use strict”</h2><p>&#160; &#160; &#160; &#160;<code>&quot;use strict&quot;</code>是<code>ECMAScript</code>引入的一条指令。指令不是语句（但非常接近于语句）。</p>\n<h5 id=\"1-与普通语句的区别\"><a href=\"#1-与普通语句的区别\" class=\"headerlink\" title=\"1. 与普通语句的区别\"></a>1. 与普通语句的区别</h5><p>&#160; &#160; &#160; &#160;<code>&quot;use strict&quot;</code>指令和普通的语句之间有两个重要的<code>区别</code>：</p>\n<ul>\n<li>它不包含任何语言的<code>关键字</code>，指令仅仅是一个包含一个特殊字符串直接量的表达式（可以是使用单引号也可以使用双引号），对于那些没有实现<code>ECMAScript5</code>的JavaScript的解释器来说，它只是一条没有副作用的表达式语句，它什么也没做。将来的ECMAScript标准希望将use用做关键字，这样就可以省略引号了。</li>\n<li>它只能出现在脚本代码的开始或者函数体的开始，任何实体语句之前。但它不必一定出现在脚本的首行或函数体内的首行，因为<code>&quot;use strict&quot;</code>指令之后或之前都可以能有其它字符串直接量表达式语句，并且JavaScript的具体实现可能将它们解析为解释器自有的指令。在脚本或者函数体内第一条常规语句之后字符串直接量表达式语句只当做普通的表达式语句对待；它们不会当做指令解析，它们也没有任何副作用。</li>\n</ul>\n<h5 id=\"2-指令的目的\"><a href=\"#2-指令的目的\" class=\"headerlink\" title=\"2. 指令的目的\"></a>2. 指令的目的</h5><p>&#160; &#160; &#160; &#160;使用<code>&quot;use strict&quot;</code>指令的目的是说明（脚本或函数中）后续的代码将会解析为严格代码<code>(strict code)</code>.如果顶层（不在任何函数内的）代码使用了<code>&quot;use strict&quot;</code>指令，那么它们就是严格代码。如果函数体内定义所处的代码是严格代码或者函数体使用了<code>&quot;use strict&quot;</code>指令，那么函数体的代码也是严格代码。如果<code>eval()</code>调用时所处的代码是严格代码或者<code>eval()</code>要执行的字符串中使用了<code>&quot;use strict&quot;</code>指令，则<code>eval()</code>内的代码是严格代码。</p>\n<h5 id=\"3-与非严格模式的区别\"><a href=\"#3-与非严格模式的区别\" class=\"headerlink\" title=\"3. 与非严格模式的区别\"></a>3. 与非严格模式的区别</h5><p>&#160; &#160; &#160; &#160;严格代码以严格模式执行。<code>ECMAScript5</code>中的严格模式是该语言的一个受限制的子集，它修正了语言的重要缺陷，并提供健壮的查错功能和增强的安全机制。严格模式和非严格模式之间的区别如下（前三条十分重要）。</p>\n<ul>\n<li>在严格模式中禁止使用<code>with</code>语句。</li>\n<li>在严格模式中，<code>所有的变量</code>都要首先声明，如果给一个未声明的变量、函数、函数参数、catch从句参数或全局对象的属性赋值，将会抛出一个引用错误异常（在非严格模式中，这种隐式声明的全局变量的方法是给全局对象新添加一个新属性）。</li>\n<li>在严格模式中，调用的函数（不是方法）中的一个<code>this</code>值是<code>undefined</code>。（在非严格模式中，调用的函数中的this值总是全局对象）。可以利用这种特殊来判断JavaScript实现是否支持严格模式。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var hasStrictMode &#x3D; (function()&#123; &quot;use strict&quot;; return this&#x3D;&#x3D;&#x3D;undefined&#125;());</span><br></pre></td></tr></table></figure></li>\n<li>同样，在严格模式中，当通过<code>call()</code>或者<code>apply()</code>来调用函数时，其中的this值就是通过<code>call()</code>或者<code>apply()</code>传入的第一个参数（在非严格模式中，null和undefined值被全局对象和转换为对象的非对象值所代替）。</li>\n<li>在严格模式中，给只读属性赋值和给不可扩展的对象穿件新成员都将抛出一个类型错误异常（在非严格模式中，这些操作知识简单地操作失败，不会报错）。</li>\n<li>在严格模式中，传入<code>eval()</code>的代码不能再调用程序所在的上下文中声明变量或定义函数，而在费严格模式中是可以这样做得。相反，变量和函数的定义都是在<code>eval()</code>创建的新作用域中，这个作用域在<code>eval()</code>返回时就弃用了。</li>\n<li>在严格模式中，函数里的<code>arguments</code>对象拥有传入函数值的静态副本。在非严格模式中，<code>arguments</code>对象具有<code>“魔术般”</code>的行为，<code>arguments</code>里的数组元素和函数参数都是指向同一个值的引用。</li>\n<li>在严格模式中，当<code>delete</code>运算符后跟随非法的标识符（比如变量、函数、函数参数）时，将会抛出一个语法错误异常（在非严格模式中，这种<code>delete</code>表达式什么也没做，并返回false）。</li>\n<li>在严格模式中，试图删除一个不可配置的属性将会抛出一个类型错误异常（在非严格模式中，<code>delete</code>表达式操作失败，并返回false）。</li>\n<li>在严格模式中，在一个对象直接量中定义两个或多个同名属性将产生一个语法错误（在非严格模式中不会报错）。</li>\n<li>在严格模式中，函数声明中个存在两个或多个同名的参数将产生一个语法错误（在非严格模式中不会报错）。</li>\n<li>在严格模式中是不允许使用八进制整数直接量（以0为前缀，而不是以0x为前缀）的（在非严格模式中某些实现是允许八进制整数直接量的）。</li>\n<li>在严格模式中，标识符<code>eval</code>和<code>arguments</code>当做关键字，他们的值是不能更改的。不能给这些标识符赋值，也不能把它们声明为变量、用做函数名、用做函数参数或用做<code>catch</code>块的标识符。</li>\n<li>在严格模式中限制了对调用栈的检测能力，在严格模式的函数中，<code>arguments</code>、<code>caller</code>和<code>argument.callee</code>都会抛出一个类型错误异常。严格模式的函数同样据用<code>caller</code>和<code>arguments</code>属性，当访问这两个属性时将抛出类型错误异常（有一些JavaScript的实现在非严格模式里定义了这些非标准的属性）。</li>\n</ul>\n"},{"title":"ECMAScript5中的数组方法","date":"2019-03-30T01:21:08.000Z","_content":"\n## 概述\n\n&#160; &#160; &#160; &#160; ECMAScript5定义了9个心得数组方法来遍历、映射、过滤、检测、简化和搜索数组。大多数方法的第一个参数接收一个函数，并且对数组的每个元素（或一些元素）调用一次该函数。如果是稀疏数组，对不存在的元素不调用传递的函数。在大多数情况下，调用提供的函数使用三个参数：数组元素、元素的索引和数组本身。通常，只需要第一个参数值，客户忽略后两个参数。大多数ECMAScript5数组方法的第一个参数是一个函数，第二个参数是可以选的。如果有第三个参数，则调用的函数被看做是第二个参数的方法。也就是说，在调用函数时传递进去的第二个参数作为它的this关键字的值来使用。被调用的函数的返回值非常重要，但是不同的方法处理返回值的方式也不一样。ECMAScript5中的数组方法都不会修改他们调用的原是数组。当然，传递给这些方法的函数是可以修改这些数组的。\n\n##### 1. forEach()\n\n&#160; &#160; &#160; &#160; `forEach()` 方法从头至尾遍历数组，为每个元素调用指定的函数。传递的函数作为 `forEach()` 的第一个参数。然后 `forEach()` 使用三个参数调用该函数：数组元素、元素的索引和元素本身。如果只关心数组元素的值，可以编写只有一个参数的函数——额外的参数将忽略：\n\n``` javascript\nvar data = [1, 2, 3, 4, 5]; // 要求和的数组\n// 计算数组元素的和值\nvar sum = 0; // 初始值为0\ndata.forEach(function(value) { // 将每个值累加到sum上\n    sum += value;\n});\nsum; // 15\n// 每个数组元素的值自加1\ndata.forEach(function(v, i, a) {\n    a[i] = v + 1;\n});\ndata; // => [2,3,4,5,6]\n```\n\n&#160; &#160; &#160; &#160; `forEach()` 方法无法再所有元素都传递给调用的函数之前终止遍历。也就是说，没有像for循环中使用的响应的break语句。如果要提前终止，必须把 `forEach()` 方法放在一个try块中，并能抛出一个异常。如果 `forEach()` 方法调用的函数抛出 `forEach.break` 异常，循环会提前终止：\n\n``` javascript\nfunction foreach(a, f, t) {\n    try {\n        a.forEach(f, t);\n    } catch (e) {\n        if (e === foreach.break) return;\n        else throw e;\n    }\n}\nforeach.break = new Error(\"StopIteration\");\n```\n\n##### 2. map()\n\n&#160; &#160; &#160; &#160; `map()` 方法将调用的数组的每个元素传递给指定的函数，并返回一个数组，它包含该函数的返回值。例如：\n\n``` javascript\na = [1, 2, 3];\nb = a.map(function(x) {\n    return x * x;\n}); //b是[1, 4, 9]\n```\n\n&#160; &#160; &#160; &#160; 传递给 `map()` 的函数的调用方式和传递给 `forEach()` 的函数的调用方式一样。但传递给 `map()` 的函数应该有返回值。注意， `map()` 返回的是新数组：它不修改调用的数组。如果是稀疏数组，返回的也是相同方式的稀疏数组：它具有相同的长度，相同的缺失元素。\n\n##### 3. filter()\n\n&#160; &#160; &#160; &#160; `filter()` 方法返回的数组元素是调用的数组的一个子集。传递的函数是用来逻辑判定的：该函数返回 `true` 或 `false` 。调用判定函数就像调用 `forEach()` 和 `map()` 一样。如果返回值为 `true` 或者 `false` ，那么传递给判定函数的就是这个子集的成员，它将被添加到一个座位返回值的数组中。例如：\n\n``` javascript\na = [5, 4, 3, 2, 1];\nsmallvalue = a.filter(function(x) {\n    return x < 3;\n}); // [2 ,1]\neveryoher = a.filter(function(x) {\n    return i % 2 == 0;\n}); // [5, 3, 1]\n```\n\n&#160; &#160; &#160; &#160; `filter()` 会跳过稀疏数组中缺少的元素，它的返回数组总是稠密的。为了压缩稀疏数组的空缺，代码如下：\n\n``` \nvar dense = sparse.filter(function () { return true; });\n```\n\n&#160; &#160; &#160; &#160; 甚至，压缩空缺并删除 `undefined` 和 `null` 元素，可以这样使用 `filter()` ：\n\n``` \na = a.filter(function (x) { return x != undefined && x != null; });\n```\n\n##### 4. every()和some()\n\n&#160; &#160; &#160; &#160; `every()` 和 `some()` 方法是数组的逻辑判定：它们对数组元素应用指定的函数进行判定，返回 `true` 或 `false` 。\n`every()` 方法就像数学中的\"针对所有\"的量词∀：当且仅当数组中的所有元素调用判定函数都返回true，它才返回true：\n\n``` javascript\na = [1, 2, 3, 4, 5];\na.every(function(x) {\n    return x < 10;\n}); // => true:所有的值<10\na.every(function(x) {\n    return x % 2 === 0;\n}); // => false: 不是所有的值都是偶数\n```\n\n&#160; &#160; &#160; &#160; `some()` 方法就像数学的\"存在\"量词∃：当数组中至少有一个元素调用判定函数返回true，它就返回true；并且当且仅当数值中的所有元素调用判定函数都返回false，它才返回false：\n\n``` javascript\na = [1, 2, 3, 4, 5];\na.some(function(x) {\n    return x % 2 === 0;\n}); // => true:a包含有偶数\na.some(isNaN); // => false: a不包含非数值元素\n```\n\n&#160; &#160; &#160; &#160; 一旦 `every()` 和 `some()` 确认该返回什么值他们就会停止遍历数组元素。 `some()` 在判定函数第一次返回true后就返回true，但如果判定函数一直返回false，它将会遍历整个数组。 `every()` 切好相反：他在判定函数第一次返回false就返回false，但如果判定函数一直返回true，它将会便利整个数组。注意，根据数学上的惯例，在空数组上调用时， `every()` 返回true， `some()` 返回false。\n\n##### 5. reduce()和reduceRight()\n\n&#160; &#160; &#160; &#160; `reduce()` 和 `reduceRight()` 方法使用指定的函数将数组元素进行组合，生成单个值。这在函数式编程中是常见的操作们也可以称为\"注入\"和\"折叠\"：\n\n``` javascript\nvar a = [1, 2, 3, 4, 5];\nvar sum = a.reduce(function(x, y) {\n    return x + y\n}, 0); // => 数组求和\nvar product = a.reduce(function(x, y) {\n    return x * y\n}, 1); // => 数组求积\nvar max = a.reduce(function(x, y) {\n    return (x > y) ? x : y;\n}); // => 求最大值\n```\n\n&#160; &#160; &#160; &#160; `reduce()` 需要两个参数。第一个是执行化简操作的函数。化简函数的任务就是用某种方法把两个值组合或花间为一个值，并返回化简后的值。在上述例子中，函数通过加法、乘法或取最大值的方法组合两个值。第二个（可选）的参数是一个传递给函数的初始值。\n&#160; &#160; &#160; &#160; `reduce()` 使用的函数与 `forEach()` 和 `map()` 使用的函数不同。比较熟悉的是，数组元素、元素的索引和数组本身将作为第2~4个参数传递给函数。第一个参数是到目前为止的化简操作累积的结果。第一次调用函数式，第一个参数是一个初始值，它就是传递给 `reduce()` 的第二个参数。在接下来的调用中，这个值就是上一次化简函数的返回值。在示例的第一个例子中，第一次调用化简函数时的参数是0和1。将两者相加并返回1。再次调用时的参数是1和2，它返回3。然后它计算3+3=6、6+4=10，最后计算10+5=15。最后的值是15， `reduce()` 返回这个值。\n&#160; &#160; &#160; &#160; 上面第三次调用 `reduce()` 时只有一个参数：没有指定初始值。当不指定初始值调用 `reduce()` 时，它将使用数组的第一个元素作为其初始值。这意味着第一次调用化简函数就使用了第一个和第二个数组元素作为其第一个和第二个参数。在上面求和和求积的例子里面，可以省略初始值参数。\n在空数组上，不带初始值参数调用 `reduce()` 将导致类型错误异常。如果调用它的时候只有一个值——数组只有一个元素并且没有指定初始值，或者有一个空数组并指定一个初始值—— `reduce()` 只是简单地返回那个值而不会调用化简函数。\n&#160; &#160; &#160; &#160; `reduceRight()` 的工作原理和 `reduce()` 一样，不用的是它按照数组索引从高倒地（从右到左）处理数组，而不是从低到高。如果化简操作的优先顺序是从右到左，我们可以把它用在这些地方：\n\n``` javascript\nvar a = [2, 3, 4];\n// 计算2^(3^4)。乘方操作的优先顺序是从右到左\nvar big = a.reduceRight(function(accmulator, value) {\n    return Math.pow(value, accmulator);\n});\n```\n\n&#160; &#160; &#160; &#160; `reduce()` 和 `reduceRight()` 都能接收一个可选参数，它指定了化简函数调用时的 `this关键字` 的值。可选的初始值参数仍然需要占一个位置。如果想让化简函数作为一个特殊对象的方法调用，可以想到 `Function.bind()` 方法.\n&#160; &#160; &#160; &#160; 上面说的 `every()` 和 `some()` 方法是一种类型的数组化操作。但是不同的是，它们会尽早终止遍历而不总是访问每一个数组元素。\n&#160; &#160; &#160; &#160; 数学计算不是 `reduce()` 和 `reduceRight()` 的唯一用途。比如，我们可以用它写一个 `union()` 函数：它计算两个对象的\"并集\"，并返回另一个新对象，新对象具有二者的属性。该函数期待两个对象并返回另一个对象，所以它的工作原理和一个化简函数一样，并且可以使用 `reduce()` 来把它一般化，计算任意数目的对象的\"并集\"。\n\n``` javascript\nvar objects = [{\n    x: 1\n}, {\n    y: 2\n}, {\n    z: 3\n}];\nvar merged = objects.reduce(union); // => {x:1,y:2,z:3}\n```\n\n&#160; &#160; &#160; &#160; 当两个对象拥有同名的属性时， `union()` 函数使用第一个参数的属性值。这样， `reduce()` 和 `reduceRight()` 在使用 `union()` 时会给出不同的结果：\n\n``` javascript\nvar objects = [{\n    x: 1,\n    a: 1\n}, {\n    y: 2,\n    a: 2\n}, {\n    z: 3,\n    a: 3\n}];\nvar leftunion = objects.reduce(union); // => {x:1, y:2, z:3, a:1}\nvar rightunion = objects.reduceRight(union); // => {x:1, y:2, z:3, a:3}\n```\n\n    \n\n##### 6.indexOf()和lastIndexOf()\n\n&#160; &#160; &#160; &#160; `indexOf()` 和 `lastIndexOf()` 搜索整个数组中具有给定值的元素，返回找到的第一个元素的索引或者如果没有找到就返回-1。 `indexOf()` 从头至尾搜索，而 `lastIndexOf()` 则反向搜索。\n\n``` javascript\nvar a = [0, 1, 2, 1, 0];\na.indexOf(1); // => 1:a[1]是1\na.lastIndexOf(1); // => 3:a[3]是1\na.indexOf(3); // => -1:没有值为3的元素\n```\n\n&#160; &#160; &#160; &#160; 不同于其他方法， `indexOf()` 和 `lastIndexOf()` 方法不接受一个函数作为其参数。第一个参数是需要搜索的值，第二个参数是可选的：它指定数组中的一个索引，从那里开始搜索，如果省略该参数， `indexOf()` 从头开始搜索，而 `lastIndexOf()` 从末尾开始搜索。第二个参数也可以是负数，它代表对数组末尾的偏移量，对于 `splice()` 方法：例如，-1指定数组的最后一个元素。\n如下函数在一个数组中搜索指定的值并返回包含所有匹配的数组索引的一个数组。它展示了如何运用 `indexOf()` 的第二个参数来查找除了第一个意外匹配的值。\n\n``` javascript\n// 在数组中查找所有出现的x，并返回一个包含匹配索引的数组\nfunction findall(a, x) {\n    var results = [], // 将会返回的数组\n        len = a.length, // 待搜索数组的长度\n        pos = 0; // 开始搜索的位置\n    while (pos < len) {\n        // 循环搜索多个元素...\n        pos = a.indexOf(x, pos); // 搜索\n        if (pos === -1) { // 未找到，就完成搜索\n            break;\n        }\n        results.push(pos); // 否则，在数组中存储索引\n        pos = pos + 1; // 并从下一个位置开始搜索\n    }\n    return results; // 返回包含索引的数组\n}\n```\n\n&#160; &#160; &#160; &#160; 字符串也有 `indexOf()` 和 `lastIndexOf()` 方法，它们和数组方法的功能类似。\n","source":"_posts/ECMAScript5中的数组方法.md","raw":"---\ntitle: ECMAScript5中的数组方法\ndate: 2019-03-30 09:21:08  \ncategories: JavaScript\ntags:\n---\n\n## 概述\n\n&#160; &#160; &#160; &#160; ECMAScript5定义了9个心得数组方法来遍历、映射、过滤、检测、简化和搜索数组。大多数方法的第一个参数接收一个函数，并且对数组的每个元素（或一些元素）调用一次该函数。如果是稀疏数组，对不存在的元素不调用传递的函数。在大多数情况下，调用提供的函数使用三个参数：数组元素、元素的索引和数组本身。通常，只需要第一个参数值，客户忽略后两个参数。大多数ECMAScript5数组方法的第一个参数是一个函数，第二个参数是可以选的。如果有第三个参数，则调用的函数被看做是第二个参数的方法。也就是说，在调用函数时传递进去的第二个参数作为它的this关键字的值来使用。被调用的函数的返回值非常重要，但是不同的方法处理返回值的方式也不一样。ECMAScript5中的数组方法都不会修改他们调用的原是数组。当然，传递给这些方法的函数是可以修改这些数组的。\n\n##### 1. forEach()\n\n&#160; &#160; &#160; &#160; `forEach()` 方法从头至尾遍历数组，为每个元素调用指定的函数。传递的函数作为 `forEach()` 的第一个参数。然后 `forEach()` 使用三个参数调用该函数：数组元素、元素的索引和元素本身。如果只关心数组元素的值，可以编写只有一个参数的函数——额外的参数将忽略：\n\n``` javascript\nvar data = [1, 2, 3, 4, 5]; // 要求和的数组\n// 计算数组元素的和值\nvar sum = 0; // 初始值为0\ndata.forEach(function(value) { // 将每个值累加到sum上\n    sum += value;\n});\nsum; // 15\n// 每个数组元素的值自加1\ndata.forEach(function(v, i, a) {\n    a[i] = v + 1;\n});\ndata; // => [2,3,4,5,6]\n```\n\n&#160; &#160; &#160; &#160; `forEach()` 方法无法再所有元素都传递给调用的函数之前终止遍历。也就是说，没有像for循环中使用的响应的break语句。如果要提前终止，必须把 `forEach()` 方法放在一个try块中，并能抛出一个异常。如果 `forEach()` 方法调用的函数抛出 `forEach.break` 异常，循环会提前终止：\n\n``` javascript\nfunction foreach(a, f, t) {\n    try {\n        a.forEach(f, t);\n    } catch (e) {\n        if (e === foreach.break) return;\n        else throw e;\n    }\n}\nforeach.break = new Error(\"StopIteration\");\n```\n\n##### 2. map()\n\n&#160; &#160; &#160; &#160; `map()` 方法将调用的数组的每个元素传递给指定的函数，并返回一个数组，它包含该函数的返回值。例如：\n\n``` javascript\na = [1, 2, 3];\nb = a.map(function(x) {\n    return x * x;\n}); //b是[1, 4, 9]\n```\n\n&#160; &#160; &#160; &#160; 传递给 `map()` 的函数的调用方式和传递给 `forEach()` 的函数的调用方式一样。但传递给 `map()` 的函数应该有返回值。注意， `map()` 返回的是新数组：它不修改调用的数组。如果是稀疏数组，返回的也是相同方式的稀疏数组：它具有相同的长度，相同的缺失元素。\n\n##### 3. filter()\n\n&#160; &#160; &#160; &#160; `filter()` 方法返回的数组元素是调用的数组的一个子集。传递的函数是用来逻辑判定的：该函数返回 `true` 或 `false` 。调用判定函数就像调用 `forEach()` 和 `map()` 一样。如果返回值为 `true` 或者 `false` ，那么传递给判定函数的就是这个子集的成员，它将被添加到一个座位返回值的数组中。例如：\n\n``` javascript\na = [5, 4, 3, 2, 1];\nsmallvalue = a.filter(function(x) {\n    return x < 3;\n}); // [2 ,1]\neveryoher = a.filter(function(x) {\n    return i % 2 == 0;\n}); // [5, 3, 1]\n```\n\n&#160; &#160; &#160; &#160; `filter()` 会跳过稀疏数组中缺少的元素，它的返回数组总是稠密的。为了压缩稀疏数组的空缺，代码如下：\n\n``` \nvar dense = sparse.filter(function () { return true; });\n```\n\n&#160; &#160; &#160; &#160; 甚至，压缩空缺并删除 `undefined` 和 `null` 元素，可以这样使用 `filter()` ：\n\n``` \na = a.filter(function (x) { return x != undefined && x != null; });\n```\n\n##### 4. every()和some()\n\n&#160; &#160; &#160; &#160; `every()` 和 `some()` 方法是数组的逻辑判定：它们对数组元素应用指定的函数进行判定，返回 `true` 或 `false` 。\n`every()` 方法就像数学中的\"针对所有\"的量词∀：当且仅当数组中的所有元素调用判定函数都返回true，它才返回true：\n\n``` javascript\na = [1, 2, 3, 4, 5];\na.every(function(x) {\n    return x < 10;\n}); // => true:所有的值<10\na.every(function(x) {\n    return x % 2 === 0;\n}); // => false: 不是所有的值都是偶数\n```\n\n&#160; &#160; &#160; &#160; `some()` 方法就像数学的\"存在\"量词∃：当数组中至少有一个元素调用判定函数返回true，它就返回true；并且当且仅当数值中的所有元素调用判定函数都返回false，它才返回false：\n\n``` javascript\na = [1, 2, 3, 4, 5];\na.some(function(x) {\n    return x % 2 === 0;\n}); // => true:a包含有偶数\na.some(isNaN); // => false: a不包含非数值元素\n```\n\n&#160; &#160; &#160; &#160; 一旦 `every()` 和 `some()` 确认该返回什么值他们就会停止遍历数组元素。 `some()` 在判定函数第一次返回true后就返回true，但如果判定函数一直返回false，它将会遍历整个数组。 `every()` 切好相反：他在判定函数第一次返回false就返回false，但如果判定函数一直返回true，它将会便利整个数组。注意，根据数学上的惯例，在空数组上调用时， `every()` 返回true， `some()` 返回false。\n\n##### 5. reduce()和reduceRight()\n\n&#160; &#160; &#160; &#160; `reduce()` 和 `reduceRight()` 方法使用指定的函数将数组元素进行组合，生成单个值。这在函数式编程中是常见的操作们也可以称为\"注入\"和\"折叠\"：\n\n``` javascript\nvar a = [1, 2, 3, 4, 5];\nvar sum = a.reduce(function(x, y) {\n    return x + y\n}, 0); // => 数组求和\nvar product = a.reduce(function(x, y) {\n    return x * y\n}, 1); // => 数组求积\nvar max = a.reduce(function(x, y) {\n    return (x > y) ? x : y;\n}); // => 求最大值\n```\n\n&#160; &#160; &#160; &#160; `reduce()` 需要两个参数。第一个是执行化简操作的函数。化简函数的任务就是用某种方法把两个值组合或花间为一个值，并返回化简后的值。在上述例子中，函数通过加法、乘法或取最大值的方法组合两个值。第二个（可选）的参数是一个传递给函数的初始值。\n&#160; &#160; &#160; &#160; `reduce()` 使用的函数与 `forEach()` 和 `map()` 使用的函数不同。比较熟悉的是，数组元素、元素的索引和数组本身将作为第2~4个参数传递给函数。第一个参数是到目前为止的化简操作累积的结果。第一次调用函数式，第一个参数是一个初始值，它就是传递给 `reduce()` 的第二个参数。在接下来的调用中，这个值就是上一次化简函数的返回值。在示例的第一个例子中，第一次调用化简函数时的参数是0和1。将两者相加并返回1。再次调用时的参数是1和2，它返回3。然后它计算3+3=6、6+4=10，最后计算10+5=15。最后的值是15， `reduce()` 返回这个值。\n&#160; &#160; &#160; &#160; 上面第三次调用 `reduce()` 时只有一个参数：没有指定初始值。当不指定初始值调用 `reduce()` 时，它将使用数组的第一个元素作为其初始值。这意味着第一次调用化简函数就使用了第一个和第二个数组元素作为其第一个和第二个参数。在上面求和和求积的例子里面，可以省略初始值参数。\n在空数组上，不带初始值参数调用 `reduce()` 将导致类型错误异常。如果调用它的时候只有一个值——数组只有一个元素并且没有指定初始值，或者有一个空数组并指定一个初始值—— `reduce()` 只是简单地返回那个值而不会调用化简函数。\n&#160; &#160; &#160; &#160; `reduceRight()` 的工作原理和 `reduce()` 一样，不用的是它按照数组索引从高倒地（从右到左）处理数组，而不是从低到高。如果化简操作的优先顺序是从右到左，我们可以把它用在这些地方：\n\n``` javascript\nvar a = [2, 3, 4];\n// 计算2^(3^4)。乘方操作的优先顺序是从右到左\nvar big = a.reduceRight(function(accmulator, value) {\n    return Math.pow(value, accmulator);\n});\n```\n\n&#160; &#160; &#160; &#160; `reduce()` 和 `reduceRight()` 都能接收一个可选参数，它指定了化简函数调用时的 `this关键字` 的值。可选的初始值参数仍然需要占一个位置。如果想让化简函数作为一个特殊对象的方法调用，可以想到 `Function.bind()` 方法.\n&#160; &#160; &#160; &#160; 上面说的 `every()` 和 `some()` 方法是一种类型的数组化操作。但是不同的是，它们会尽早终止遍历而不总是访问每一个数组元素。\n&#160; &#160; &#160; &#160; 数学计算不是 `reduce()` 和 `reduceRight()` 的唯一用途。比如，我们可以用它写一个 `union()` 函数：它计算两个对象的\"并集\"，并返回另一个新对象，新对象具有二者的属性。该函数期待两个对象并返回另一个对象，所以它的工作原理和一个化简函数一样，并且可以使用 `reduce()` 来把它一般化，计算任意数目的对象的\"并集\"。\n\n``` javascript\nvar objects = [{\n    x: 1\n}, {\n    y: 2\n}, {\n    z: 3\n}];\nvar merged = objects.reduce(union); // => {x:1,y:2,z:3}\n```\n\n&#160; &#160; &#160; &#160; 当两个对象拥有同名的属性时， `union()` 函数使用第一个参数的属性值。这样， `reduce()` 和 `reduceRight()` 在使用 `union()` 时会给出不同的结果：\n\n``` javascript\nvar objects = [{\n    x: 1,\n    a: 1\n}, {\n    y: 2,\n    a: 2\n}, {\n    z: 3,\n    a: 3\n}];\nvar leftunion = objects.reduce(union); // => {x:1, y:2, z:3, a:1}\nvar rightunion = objects.reduceRight(union); // => {x:1, y:2, z:3, a:3}\n```\n\n    \n\n##### 6.indexOf()和lastIndexOf()\n\n&#160; &#160; &#160; &#160; `indexOf()` 和 `lastIndexOf()` 搜索整个数组中具有给定值的元素，返回找到的第一个元素的索引或者如果没有找到就返回-1。 `indexOf()` 从头至尾搜索，而 `lastIndexOf()` 则反向搜索。\n\n``` javascript\nvar a = [0, 1, 2, 1, 0];\na.indexOf(1); // => 1:a[1]是1\na.lastIndexOf(1); // => 3:a[3]是1\na.indexOf(3); // => -1:没有值为3的元素\n```\n\n&#160; &#160; &#160; &#160; 不同于其他方法， `indexOf()` 和 `lastIndexOf()` 方法不接受一个函数作为其参数。第一个参数是需要搜索的值，第二个参数是可选的：它指定数组中的一个索引，从那里开始搜索，如果省略该参数， `indexOf()` 从头开始搜索，而 `lastIndexOf()` 从末尾开始搜索。第二个参数也可以是负数，它代表对数组末尾的偏移量，对于 `splice()` 方法：例如，-1指定数组的最后一个元素。\n如下函数在一个数组中搜索指定的值并返回包含所有匹配的数组索引的一个数组。它展示了如何运用 `indexOf()` 的第二个参数来查找除了第一个意外匹配的值。\n\n``` javascript\n// 在数组中查找所有出现的x，并返回一个包含匹配索引的数组\nfunction findall(a, x) {\n    var results = [], // 将会返回的数组\n        len = a.length, // 待搜索数组的长度\n        pos = 0; // 开始搜索的位置\n    while (pos < len) {\n        // 循环搜索多个元素...\n        pos = a.indexOf(x, pos); // 搜索\n        if (pos === -1) { // 未找到，就完成搜索\n            break;\n        }\n        results.push(pos); // 否则，在数组中存储索引\n        pos = pos + 1; // 并从下一个位置开始搜索\n    }\n    return results; // 返回包含索引的数组\n}\n```\n\n&#160; &#160; &#160; &#160; 字符串也有 `indexOf()` 和 `lastIndexOf()` 方法，它们和数组方法的功能类似。\n","slug":"ECMAScript5中的数组方法","published":1,"updated":"2020-06-03T09:06:48.630Z","_id":"ck8gp7rxu0005kb9ha4dm5jot","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>&#160; &#160; &#160; &#160; ECMAScript5定义了9个心得数组方法来遍历、映射、过滤、检测、简化和搜索数组。大多数方法的第一个参数接收一个函数，并且对数组的每个元素（或一些元素）调用一次该函数。如果是稀疏数组，对不存在的元素不调用传递的函数。在大多数情况下，调用提供的函数使用三个参数：数组元素、元素的索引和数组本身。通常，只需要第一个参数值，客户忽略后两个参数。大多数ECMAScript5数组方法的第一个参数是一个函数，第二个参数是可以选的。如果有第三个参数，则调用的函数被看做是第二个参数的方法。也就是说，在调用函数时传递进去的第二个参数作为它的this关键字的值来使用。被调用的函数的返回值非常重要，但是不同的方法处理返回值的方式也不一样。ECMAScript5中的数组方法都不会修改他们调用的原是数组。当然，传递给这些方法的函数是可以修改这些数组的。</p>\n<h5 id=\"1-forEach\"><a href=\"#1-forEach\" class=\"headerlink\" title=\"1. forEach()\"></a>1. forEach()</h5><p>&#160; &#160; &#160; &#160; <code>forEach()</code> 方法从头至尾遍历数组，为每个元素调用指定的函数。传递的函数作为 <code>forEach()</code> 的第一个参数。然后 <code>forEach()</code> 使用三个参数调用该函数：数组元素、元素的索引和元素本身。如果只关心数组元素的值，可以编写只有一个参数的函数——额外的参数将忽略：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]; <span class=\"comment\">// 要求和的数组</span></span><br><span class=\"line\"><span class=\"comment\">// 计算数组元素的和值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"number\">0</span>; <span class=\"comment\">// 初始值为0</span></span><br><span class=\"line\">data.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123; <span class=\"comment\">// 将每个值累加到sum上</span></span><br><span class=\"line\">    sum += value;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">sum; <span class=\"comment\">// 15</span></span><br><span class=\"line\"><span class=\"comment\">// 每个数组元素的值自加1</span></span><br><span class=\"line\">data.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v, i, a</span>) </span>&#123;</span><br><span class=\"line\">    a[i] = v + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">data; <span class=\"comment\">// =&gt; [2,3,4,5,6]</span></span><br></pre></td></tr></table></figure>\n\n<p>&#160; &#160; &#160; &#160; <code>forEach()</code> 方法无法再所有元素都传递给调用的函数之前终止遍历。也就是说，没有像for循环中使用的响应的break语句。如果要提前终止，必须把 <code>forEach()</code> 方法放在一个try块中，并能抛出一个异常。如果 <code>forEach()</code> 方法调用的函数抛出 <code>forEach.break</code> 异常，循环会提前终止：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foreach</span>(<span class=\"params\">a, f, t</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        a.forEach(f, t);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e === foreach.break) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foreach.break = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"StopIteration\"</span>);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2-map\"><a href=\"#2-map\" class=\"headerlink\" title=\"2. map()\"></a>2. map()</h5><p>&#160; &#160; &#160; &#160; <code>map()</code> 方法将调用的数组的每个元素传递给指定的函数，并返回一个数组，它包含该函数的返回值。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">b = a.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * x;</span><br><span class=\"line\">&#125;); <span class=\"comment\">//b是[1, 4, 9]</span></span><br></pre></td></tr></table></figure>\n\n<p>&#160; &#160; &#160; &#160; 传递给 <code>map()</code> 的函数的调用方式和传递给 <code>forEach()</code> 的函数的调用方式一样。但传递给 <code>map()</code> 的函数应该有返回值。注意， <code>map()</code> 返回的是新数组：它不修改调用的数组。如果是稀疏数组，返回的也是相同方式的稀疏数组：它具有相同的长度，相同的缺失元素。</p>\n<h5 id=\"3-filter\"><a href=\"#3-filter\" class=\"headerlink\" title=\"3. filter()\"></a>3. filter()</h5><p>&#160; &#160; &#160; &#160; <code>filter()</code> 方法返回的数组元素是调用的数组的一个子集。传递的函数是用来逻辑判定的：该函数返回 <code>true</code> 或 <code>false</code> 。调用判定函数就像调用 <code>forEach()</code> 和 <code>map()</code> 一样。如果返回值为 <code>true</code> 或者 <code>false</code> ，那么传递给判定函数的就是这个子集的成员，它将被添加到一个座位返回值的数组中。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [<span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>];</span><br><span class=\"line\">smallvalue = a.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x &lt; <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;); <span class=\"comment\">// [2 ,1]</span></span><br><span class=\"line\">everyoher = a.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i % <span class=\"number\">2</span> == <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;); <span class=\"comment\">// [5, 3, 1]</span></span><br></pre></td></tr></table></figure>\n\n<p>&#160; &#160; &#160; &#160; <code>filter()</code> 会跳过稀疏数组中缺少的元素，它的返回数组总是稠密的。为了压缩稀疏数组的空缺，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var dense &#x3D; sparse.filter(function () &#123; return true; &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>&#160; &#160; &#160; &#160; 甚至，压缩空缺并删除 <code>undefined</code> 和 <code>null</code> 元素，可以这样使用 <code>filter()</code> ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a &#x3D; a.filter(function (x) &#123; return x !&#x3D; undefined &amp;&amp; x !&#x3D; null; &#125;);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4-every-和some\"><a href=\"#4-every-和some\" class=\"headerlink\" title=\"4. every()和some()\"></a>4. every()和some()</h5><p>&#160; &#160; &#160; &#160; <code>every()</code> 和 <code>some()</code> 方法是数组的逻辑判定：它们对数组元素应用指定的函数进行判定，返回 <code>true</code> 或 <code>false</code> 。<br><code>every()</code> 方法就像数学中的”针对所有”的量词∀：当且仅当数组中的所有元素调用判定函数都返回true，它才返回true：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">a.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x &lt; <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;); <span class=\"comment\">// =&gt; true:所有的值&lt;10</span></span><br><span class=\"line\">a.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x % <span class=\"number\">2</span> === <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;); <span class=\"comment\">// =&gt; false: 不是所有的值都是偶数</span></span><br></pre></td></tr></table></figure>\n\n<p>&#160; &#160; &#160; &#160; <code>some()</code> 方法就像数学的”存在”量词∃：当数组中至少有一个元素调用判定函数返回true，它就返回true；并且当且仅当数值中的所有元素调用判定函数都返回false，它才返回false：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">a.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x % <span class=\"number\">2</span> === <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;); <span class=\"comment\">// =&gt; true:a包含有偶数</span></span><br><span class=\"line\">a.some(<span class=\"built_in\">isNaN</span>); <span class=\"comment\">// =&gt; false: a不包含非数值元素</span></span><br></pre></td></tr></table></figure>\n\n<p>&#160; &#160; &#160; &#160; 一旦 <code>every()</code> 和 <code>some()</code> 确认该返回什么值他们就会停止遍历数组元素。 <code>some()</code> 在判定函数第一次返回true后就返回true，但如果判定函数一直返回false，它将会遍历整个数组。 <code>every()</code> 切好相反：他在判定函数第一次返回false就返回false，但如果判定函数一直返回true，它将会便利整个数组。注意，根据数学上的惯例，在空数组上调用时， <code>every()</code> 返回true， <code>some()</code> 返回false。</p>\n<h5 id=\"5-reduce-和reduceRight\"><a href=\"#5-reduce-和reduceRight\" class=\"headerlink\" title=\"5. reduce()和reduceRight()\"></a>5. reduce()和reduceRight()</h5><p>&#160; &#160; &#160; &#160; <code>reduce()</code> 和 <code>reduceRight()</code> 方法使用指定的函数将数组元素进行组合，生成单个值。这在函数式编程中是常见的操作们也可以称为”注入”和”折叠”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = a.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>); <span class=\"comment\">// =&gt; 数组求和</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> product = a.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * y</span><br><span class=\"line\">&#125;, <span class=\"number\">1</span>); <span class=\"comment\">// =&gt; 数组求积</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> max = a.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (x &gt; y) ? x : y;</span><br><span class=\"line\">&#125;); <span class=\"comment\">// =&gt; 求最大值</span></span><br></pre></td></tr></table></figure>\n\n<p>&#160; &#160; &#160; &#160; <code>reduce()</code> 需要两个参数。第一个是执行化简操作的函数。化简函数的任务就是用某种方法把两个值组合或花间为一个值，并返回化简后的值。在上述例子中，函数通过加法、乘法或取最大值的方法组合两个值。第二个（可选）的参数是一个传递给函数的初始值。<br>&#160; &#160; &#160; &#160; <code>reduce()</code> 使用的函数与 <code>forEach()</code> 和 <code>map()</code> 使用的函数不同。比较熟悉的是，数组元素、元素的索引和数组本身将作为第2~4个参数传递给函数。第一个参数是到目前为止的化简操作累积的结果。第一次调用函数式，第一个参数是一个初始值，它就是传递给 <code>reduce()</code> 的第二个参数。在接下来的调用中，这个值就是上一次化简函数的返回值。在示例的第一个例子中，第一次调用化简函数时的参数是0和1。将两者相加并返回1。再次调用时的参数是1和2，它返回3。然后它计算3+3=6、6+4=10，最后计算10+5=15。最后的值是15， <code>reduce()</code> 返回这个值。<br>&#160; &#160; &#160; &#160; 上面第三次调用 <code>reduce()</code> 时只有一个参数：没有指定初始值。当不指定初始值调用 <code>reduce()</code> 时，它将使用数组的第一个元素作为其初始值。这意味着第一次调用化简函数就使用了第一个和第二个数组元素作为其第一个和第二个参数。在上面求和和求积的例子里面，可以省略初始值参数。<br>在空数组上，不带初始值参数调用 <code>reduce()</code> 将导致类型错误异常。如果调用它的时候只有一个值——数组只有一个元素并且没有指定初始值，或者有一个空数组并指定一个初始值—— <code>reduce()</code> 只是简单地返回那个值而不会调用化简函数。<br>&#160; &#160; &#160; &#160; <code>reduceRight()</code> 的工作原理和 <code>reduce()</code> 一样，不用的是它按照数组索引从高倒地（从右到左）处理数组，而不是从低到高。如果化简操作的优先顺序是从右到左，我们可以把它用在这些地方：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"comment\">// 计算2^(3^4)。乘方操作的优先顺序是从右到左</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> big = a.reduceRight(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">accmulator, value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.pow(value, accmulator);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>&#160; &#160; &#160; &#160; <code>reduce()</code> 和 <code>reduceRight()</code> 都能接收一个可选参数，它指定了化简函数调用时的 <code>this关键字</code> 的值。可选的初始值参数仍然需要占一个位置。如果想让化简函数作为一个特殊对象的方法调用，可以想到 <code>Function.bind()</code> 方法.<br>&#160; &#160; &#160; &#160; 上面说的 <code>every()</code> 和 <code>some()</code> 方法是一种类型的数组化操作。但是不同的是，它们会尽早终止遍历而不总是访问每一个数组元素。<br>&#160; &#160; &#160; &#160; 数学计算不是 <code>reduce()</code> 和 <code>reduceRight()</code> 的唯一用途。比如，我们可以用它写一个 <code>union()</code> 函数：它计算两个对象的”并集”，并返回另一个新对象，新对象具有二者的属性。该函数期待两个对象并返回另一个对象，所以它的工作原理和一个化简函数一样，并且可以使用 <code>reduce()</code> 来把它一般化，计算任意数目的对象的”并集”。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> objects = [&#123;</span><br><span class=\"line\">    x: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    y: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    z: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"><span class=\"keyword\">var</span> merged = objects.reduce(union); <span class=\"comment\">// =&gt; &#123;x:1,y:2,z:3&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>&#160; &#160; &#160; &#160; 当两个对象拥有同名的属性时， <code>union()</code> 函数使用第一个参数的属性值。这样， <code>reduce()</code> 和 <code>reduceRight()</code> 在使用 <code>union()</code> 时会给出不同的结果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> objects = [&#123;</span><br><span class=\"line\">    x: <span class=\"number\">1</span>,</span><br><span class=\"line\">    a: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    y: <span class=\"number\">2</span>,</span><br><span class=\"line\">    a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    z: <span class=\"number\">3</span>,</span><br><span class=\"line\">    a: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"><span class=\"keyword\">var</span> leftunion = objects.reduce(union); <span class=\"comment\">// =&gt; &#123;x:1, y:2, z:3, a:1&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> rightunion = objects.reduceRight(union); <span class=\"comment\">// =&gt; &#123;x:1, y:2, z:3, a:3&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"6-indexOf-和lastIndexOf\"><a href=\"#6-indexOf-和lastIndexOf\" class=\"headerlink\" title=\"6.indexOf()和lastIndexOf()\"></a>6.indexOf()和lastIndexOf()</h5><p>&#160; &#160; &#160; &#160; <code>indexOf()</code> 和 <code>lastIndexOf()</code> 搜索整个数组中具有给定值的元素，返回找到的第一个元素的索引或者如果没有找到就返回-1。 <code>indexOf()</code> 从头至尾搜索，而 <code>lastIndexOf()</code> 则反向搜索。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>];</span><br><span class=\"line\">a.indexOf(<span class=\"number\">1</span>); <span class=\"comment\">// =&gt; 1:a[1]是1</span></span><br><span class=\"line\">a.lastIndexOf(<span class=\"number\">1</span>); <span class=\"comment\">// =&gt; 3:a[3]是1</span></span><br><span class=\"line\">a.indexOf(<span class=\"number\">3</span>); <span class=\"comment\">// =&gt; -1:没有值为3的元素</span></span><br></pre></td></tr></table></figure>\n\n<p>&#160; &#160; &#160; &#160; 不同于其他方法， <code>indexOf()</code> 和 <code>lastIndexOf()</code> 方法不接受一个函数作为其参数。第一个参数是需要搜索的值，第二个参数是可选的：它指定数组中的一个索引，从那里开始搜索，如果省略该参数， <code>indexOf()</code> 从头开始搜索，而 <code>lastIndexOf()</code> 从末尾开始搜索。第二个参数也可以是负数，它代表对数组末尾的偏移量，对于 <code>splice()</code> 方法：例如，-1指定数组的最后一个元素。<br>如下函数在一个数组中搜索指定的值并返回包含所有匹配的数组索引的一个数组。它展示了如何运用 <code>indexOf()</code> 的第二个参数来查找除了第一个意外匹配的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在数组中查找所有出现的x，并返回一个包含匹配索引的数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findall</span>(<span class=\"params\">a, x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> results = [], <span class=\"comment\">// 将会返回的数组</span></span><br><span class=\"line\">        len = a.length, <span class=\"comment\">// 待搜索数组的长度</span></span><br><span class=\"line\">        pos = <span class=\"number\">0</span>; <span class=\"comment\">// 开始搜索的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (pos &lt; len) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 循环搜索多个元素...</span></span><br><span class=\"line\">        pos = a.indexOf(x, pos); <span class=\"comment\">// 搜索</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pos === <span class=\"number\">-1</span>) &#123; <span class=\"comment\">// 未找到，就完成搜索</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        results.push(pos); <span class=\"comment\">// 否则，在数组中存储索引</span></span><br><span class=\"line\">        pos = pos + <span class=\"number\">1</span>; <span class=\"comment\">// 并从下一个位置开始搜索</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> results; <span class=\"comment\">// 返回包含索引的数组</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>&#160; &#160; &#160; &#160; 字符串也有 <code>indexOf()</code> 和 <code>lastIndexOf()</code> 方法，它们和数组方法的功能类似。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>&#160; &#160; &#160; &#160; ECMAScript5定义了9个心得数组方法来遍历、映射、过滤、检测、简化和搜索数组。大多数方法的第一个参数接收一个函数，并且对数组的每个元素（或一些元素）调用一次该函数。如果是稀疏数组，对不存在的元素不调用传递的函数。在大多数情况下，调用提供的函数使用三个参数：数组元素、元素的索引和数组本身。通常，只需要第一个参数值，客户忽略后两个参数。大多数ECMAScript5数组方法的第一个参数是一个函数，第二个参数是可以选的。如果有第三个参数，则调用的函数被看做是第二个参数的方法。也就是说，在调用函数时传递进去的第二个参数作为它的this关键字的值来使用。被调用的函数的返回值非常重要，但是不同的方法处理返回值的方式也不一样。ECMAScript5中的数组方法都不会修改他们调用的原是数组。当然，传递给这些方法的函数是可以修改这些数组的。</p>\n<h5 id=\"1-forEach\"><a href=\"#1-forEach\" class=\"headerlink\" title=\"1. forEach()\"></a>1. forEach()</h5><p>&#160; &#160; &#160; &#160; <code>forEach()</code> 方法从头至尾遍历数组，为每个元素调用指定的函数。传递的函数作为 <code>forEach()</code> 的第一个参数。然后 <code>forEach()</code> 使用三个参数调用该函数：数组元素、元素的索引和元素本身。如果只关心数组元素的值，可以编写只有一个参数的函数——额外的参数将忽略：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]; <span class=\"comment\">// 要求和的数组</span></span><br><span class=\"line\"><span class=\"comment\">// 计算数组元素的和值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"number\">0</span>; <span class=\"comment\">// 初始值为0</span></span><br><span class=\"line\">data.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123; <span class=\"comment\">// 将每个值累加到sum上</span></span><br><span class=\"line\">    sum += value;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">sum; <span class=\"comment\">// 15</span></span><br><span class=\"line\"><span class=\"comment\">// 每个数组元素的值自加1</span></span><br><span class=\"line\">data.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v, i, a</span>) </span>&#123;</span><br><span class=\"line\">    a[i] = v + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">data; <span class=\"comment\">// =&gt; [2,3,4,5,6]</span></span><br></pre></td></tr></table></figure>\n\n<p>&#160; &#160; &#160; &#160; <code>forEach()</code> 方法无法再所有元素都传递给调用的函数之前终止遍历。也就是说，没有像for循环中使用的响应的break语句。如果要提前终止，必须把 <code>forEach()</code> 方法放在一个try块中，并能抛出一个异常。如果 <code>forEach()</code> 方法调用的函数抛出 <code>forEach.break</code> 异常，循环会提前终止：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foreach</span>(<span class=\"params\">a, f, t</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        a.forEach(f, t);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e === foreach.break) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foreach.break = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"StopIteration\"</span>);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2-map\"><a href=\"#2-map\" class=\"headerlink\" title=\"2. map()\"></a>2. map()</h5><p>&#160; &#160; &#160; &#160; <code>map()</code> 方法将调用的数组的每个元素传递给指定的函数，并返回一个数组，它包含该函数的返回值。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">b = a.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * x;</span><br><span class=\"line\">&#125;); <span class=\"comment\">//b是[1, 4, 9]</span></span><br></pre></td></tr></table></figure>\n\n<p>&#160; &#160; &#160; &#160; 传递给 <code>map()</code> 的函数的调用方式和传递给 <code>forEach()</code> 的函数的调用方式一样。但传递给 <code>map()</code> 的函数应该有返回值。注意， <code>map()</code> 返回的是新数组：它不修改调用的数组。如果是稀疏数组，返回的也是相同方式的稀疏数组：它具有相同的长度，相同的缺失元素。</p>\n<h5 id=\"3-filter\"><a href=\"#3-filter\" class=\"headerlink\" title=\"3. filter()\"></a>3. filter()</h5><p>&#160; &#160; &#160; &#160; <code>filter()</code> 方法返回的数组元素是调用的数组的一个子集。传递的函数是用来逻辑判定的：该函数返回 <code>true</code> 或 <code>false</code> 。调用判定函数就像调用 <code>forEach()</code> 和 <code>map()</code> 一样。如果返回值为 <code>true</code> 或者 <code>false</code> ，那么传递给判定函数的就是这个子集的成员，它将被添加到一个座位返回值的数组中。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [<span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>];</span><br><span class=\"line\">smallvalue = a.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x &lt; <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;); <span class=\"comment\">// [2 ,1]</span></span><br><span class=\"line\">everyoher = a.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i % <span class=\"number\">2</span> == <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;); <span class=\"comment\">// [5, 3, 1]</span></span><br></pre></td></tr></table></figure>\n\n<p>&#160; &#160; &#160; &#160; <code>filter()</code> 会跳过稀疏数组中缺少的元素，它的返回数组总是稠密的。为了压缩稀疏数组的空缺，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var dense &#x3D; sparse.filter(function () &#123; return true; &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>&#160; &#160; &#160; &#160; 甚至，压缩空缺并删除 <code>undefined</code> 和 <code>null</code> 元素，可以这样使用 <code>filter()</code> ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a &#x3D; a.filter(function (x) &#123; return x !&#x3D; undefined &amp;&amp; x !&#x3D; null; &#125;);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4-every-和some\"><a href=\"#4-every-和some\" class=\"headerlink\" title=\"4. every()和some()\"></a>4. every()和some()</h5><p>&#160; &#160; &#160; &#160; <code>every()</code> 和 <code>some()</code> 方法是数组的逻辑判定：它们对数组元素应用指定的函数进行判定，返回 <code>true</code> 或 <code>false</code> 。<br><code>every()</code> 方法就像数学中的”针对所有”的量词∀：当且仅当数组中的所有元素调用判定函数都返回true，它才返回true：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">a.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x &lt; <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;); <span class=\"comment\">// =&gt; true:所有的值&lt;10</span></span><br><span class=\"line\">a.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x % <span class=\"number\">2</span> === <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;); <span class=\"comment\">// =&gt; false: 不是所有的值都是偶数</span></span><br></pre></td></tr></table></figure>\n\n<p>&#160; &#160; &#160; &#160; <code>some()</code> 方法就像数学的”存在”量词∃：当数组中至少有一个元素调用判定函数返回true，它就返回true；并且当且仅当数值中的所有元素调用判定函数都返回false，它才返回false：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">a.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x % <span class=\"number\">2</span> === <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;); <span class=\"comment\">// =&gt; true:a包含有偶数</span></span><br><span class=\"line\">a.some(<span class=\"built_in\">isNaN</span>); <span class=\"comment\">// =&gt; false: a不包含非数值元素</span></span><br></pre></td></tr></table></figure>\n\n<p>&#160; &#160; &#160; &#160; 一旦 <code>every()</code> 和 <code>some()</code> 确认该返回什么值他们就会停止遍历数组元素。 <code>some()</code> 在判定函数第一次返回true后就返回true，但如果判定函数一直返回false，它将会遍历整个数组。 <code>every()</code> 切好相反：他在判定函数第一次返回false就返回false，但如果判定函数一直返回true，它将会便利整个数组。注意，根据数学上的惯例，在空数组上调用时， <code>every()</code> 返回true， <code>some()</code> 返回false。</p>\n<h5 id=\"5-reduce-和reduceRight\"><a href=\"#5-reduce-和reduceRight\" class=\"headerlink\" title=\"5. reduce()和reduceRight()\"></a>5. reduce()和reduceRight()</h5><p>&#160; &#160; &#160; &#160; <code>reduce()</code> 和 <code>reduceRight()</code> 方法使用指定的函数将数组元素进行组合，生成单个值。这在函数式编程中是常见的操作们也可以称为”注入”和”折叠”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = a.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>); <span class=\"comment\">// =&gt; 数组求和</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> product = a.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * y</span><br><span class=\"line\">&#125;, <span class=\"number\">1</span>); <span class=\"comment\">// =&gt; 数组求积</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> max = a.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (x &gt; y) ? x : y;</span><br><span class=\"line\">&#125;); <span class=\"comment\">// =&gt; 求最大值</span></span><br></pre></td></tr></table></figure>\n\n<p>&#160; &#160; &#160; &#160; <code>reduce()</code> 需要两个参数。第一个是执行化简操作的函数。化简函数的任务就是用某种方法把两个值组合或花间为一个值，并返回化简后的值。在上述例子中，函数通过加法、乘法或取最大值的方法组合两个值。第二个（可选）的参数是一个传递给函数的初始值。<br>&#160; &#160; &#160; &#160; <code>reduce()</code> 使用的函数与 <code>forEach()</code> 和 <code>map()</code> 使用的函数不同。比较熟悉的是，数组元素、元素的索引和数组本身将作为第2~4个参数传递给函数。第一个参数是到目前为止的化简操作累积的结果。第一次调用函数式，第一个参数是一个初始值，它就是传递给 <code>reduce()</code> 的第二个参数。在接下来的调用中，这个值就是上一次化简函数的返回值。在示例的第一个例子中，第一次调用化简函数时的参数是0和1。将两者相加并返回1。再次调用时的参数是1和2，它返回3。然后它计算3+3=6、6+4=10，最后计算10+5=15。最后的值是15， <code>reduce()</code> 返回这个值。<br>&#160; &#160; &#160; &#160; 上面第三次调用 <code>reduce()</code> 时只有一个参数：没有指定初始值。当不指定初始值调用 <code>reduce()</code> 时，它将使用数组的第一个元素作为其初始值。这意味着第一次调用化简函数就使用了第一个和第二个数组元素作为其第一个和第二个参数。在上面求和和求积的例子里面，可以省略初始值参数。<br>在空数组上，不带初始值参数调用 <code>reduce()</code> 将导致类型错误异常。如果调用它的时候只有一个值——数组只有一个元素并且没有指定初始值，或者有一个空数组并指定一个初始值—— <code>reduce()</code> 只是简单地返回那个值而不会调用化简函数。<br>&#160; &#160; &#160; &#160; <code>reduceRight()</code> 的工作原理和 <code>reduce()</code> 一样，不用的是它按照数组索引从高倒地（从右到左）处理数组，而不是从低到高。如果化简操作的优先顺序是从右到左，我们可以把它用在这些地方：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"comment\">// 计算2^(3^4)。乘方操作的优先顺序是从右到左</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> big = a.reduceRight(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">accmulator, value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.pow(value, accmulator);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>&#160; &#160; &#160; &#160; <code>reduce()</code> 和 <code>reduceRight()</code> 都能接收一个可选参数，它指定了化简函数调用时的 <code>this关键字</code> 的值。可选的初始值参数仍然需要占一个位置。如果想让化简函数作为一个特殊对象的方法调用，可以想到 <code>Function.bind()</code> 方法.<br>&#160; &#160; &#160; &#160; 上面说的 <code>every()</code> 和 <code>some()</code> 方法是一种类型的数组化操作。但是不同的是，它们会尽早终止遍历而不总是访问每一个数组元素。<br>&#160; &#160; &#160; &#160; 数学计算不是 <code>reduce()</code> 和 <code>reduceRight()</code> 的唯一用途。比如，我们可以用它写一个 <code>union()</code> 函数：它计算两个对象的”并集”，并返回另一个新对象，新对象具有二者的属性。该函数期待两个对象并返回另一个对象，所以它的工作原理和一个化简函数一样，并且可以使用 <code>reduce()</code> 来把它一般化，计算任意数目的对象的”并集”。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> objects = [&#123;</span><br><span class=\"line\">    x: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    y: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    z: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"><span class=\"keyword\">var</span> merged = objects.reduce(union); <span class=\"comment\">// =&gt; &#123;x:1,y:2,z:3&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>&#160; &#160; &#160; &#160; 当两个对象拥有同名的属性时， <code>union()</code> 函数使用第一个参数的属性值。这样， <code>reduce()</code> 和 <code>reduceRight()</code> 在使用 <code>union()</code> 时会给出不同的结果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> objects = [&#123;</span><br><span class=\"line\">    x: <span class=\"number\">1</span>,</span><br><span class=\"line\">    a: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    y: <span class=\"number\">2</span>,</span><br><span class=\"line\">    a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    z: <span class=\"number\">3</span>,</span><br><span class=\"line\">    a: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"><span class=\"keyword\">var</span> leftunion = objects.reduce(union); <span class=\"comment\">// =&gt; &#123;x:1, y:2, z:3, a:1&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> rightunion = objects.reduceRight(union); <span class=\"comment\">// =&gt; &#123;x:1, y:2, z:3, a:3&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"6-indexOf-和lastIndexOf\"><a href=\"#6-indexOf-和lastIndexOf\" class=\"headerlink\" title=\"6.indexOf()和lastIndexOf()\"></a>6.indexOf()和lastIndexOf()</h5><p>&#160; &#160; &#160; &#160; <code>indexOf()</code> 和 <code>lastIndexOf()</code> 搜索整个数组中具有给定值的元素，返回找到的第一个元素的索引或者如果没有找到就返回-1。 <code>indexOf()</code> 从头至尾搜索，而 <code>lastIndexOf()</code> 则反向搜索。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>];</span><br><span class=\"line\">a.indexOf(<span class=\"number\">1</span>); <span class=\"comment\">// =&gt; 1:a[1]是1</span></span><br><span class=\"line\">a.lastIndexOf(<span class=\"number\">1</span>); <span class=\"comment\">// =&gt; 3:a[3]是1</span></span><br><span class=\"line\">a.indexOf(<span class=\"number\">3</span>); <span class=\"comment\">// =&gt; -1:没有值为3的元素</span></span><br></pre></td></tr></table></figure>\n\n<p>&#160; &#160; &#160; &#160; 不同于其他方法， <code>indexOf()</code> 和 <code>lastIndexOf()</code> 方法不接受一个函数作为其参数。第一个参数是需要搜索的值，第二个参数是可选的：它指定数组中的一个索引，从那里开始搜索，如果省略该参数， <code>indexOf()</code> 从头开始搜索，而 <code>lastIndexOf()</code> 从末尾开始搜索。第二个参数也可以是负数，它代表对数组末尾的偏移量，对于 <code>splice()</code> 方法：例如，-1指定数组的最后一个元素。<br>如下函数在一个数组中搜索指定的值并返回包含所有匹配的数组索引的一个数组。它展示了如何运用 <code>indexOf()</code> 的第二个参数来查找除了第一个意外匹配的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在数组中查找所有出现的x，并返回一个包含匹配索引的数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findall</span>(<span class=\"params\">a, x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> results = [], <span class=\"comment\">// 将会返回的数组</span></span><br><span class=\"line\">        len = a.length, <span class=\"comment\">// 待搜索数组的长度</span></span><br><span class=\"line\">        pos = <span class=\"number\">0</span>; <span class=\"comment\">// 开始搜索的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (pos &lt; len) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 循环搜索多个元素...</span></span><br><span class=\"line\">        pos = a.indexOf(x, pos); <span class=\"comment\">// 搜索</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pos === <span class=\"number\">-1</span>) &#123; <span class=\"comment\">// 未找到，就完成搜索</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        results.push(pos); <span class=\"comment\">// 否则，在数组中存储索引</span></span><br><span class=\"line\">        pos = pos + <span class=\"number\">1</span>; <span class=\"comment\">// 并从下一个位置开始搜索</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> results; <span class=\"comment\">// 返回包含索引的数组</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>&#160; &#160; &#160; &#160; 字符串也有 <code>indexOf()</code> 和 <code>lastIndexOf()</code> 方法，它们和数组方法的功能类似。</p>\n"},{"title":"JavaScript数组方法","date":"2019-03-23T01:21:08.000Z","_content":"\n## 数组方法\n\n&#160; &#160; &#160; &#160;ECMAScript在Array.prototype中定义了一些很有用的操作数组的函数，这意味着这些函数作为任何数组的方法都是可用的。\n\n##### 1. join()\n`Array.join()`方法将数组中所有元素都专户为字符串并连接在一起，返回最后生成的字符串。可以指定一个可选的字符串在生在的字符串中来分隔数组的各个元素。如果不指定分隔符，默认使用逗号。代码如下：\n```\nvar a = [1, 2, 3];     // 创建一个包含三个元素的数组\na.join();              // => \"1,2,3\"\na.join(\" \");           // => \"1 2 3\"\na.join(\"\");            // => \"123\"\n```\n`Array.join()` 方法是String.split()方法的逆向操作，后者是将字符串分割成若干块来创建一个数组。\n\n##### 2. reverse()\n`Array.reverse()`方法将数组中的元素颠倒顺序，返回逆向的数组。它采取了替换；换句话说，它不通过重新排列的元素创建新的数组，而是在原先的数组中重新排列他们。例如，下面的代码使用`reverse()`和`join()`方法生成字符串“3，2，1”：\n```\nvar a = [1,2,3];\na.reverse().join();   // => \"3,2,1\",并且现在的a是[3,2,1] \n```\n\n##### 3. sort()\n`Array.sort()`方法将数组中的元素排序并返回排序后的数组。当不带参数调用`sort()`时，数组元素以字母表顺序排列（如有必要将临时转化为字符串进行比较）：\n```\nvar a = new Array(\"banana\", \"cherry\", \"apple\");\na.sort();\nvar s = a.join(\"， ”)；  //  s = \"apple, banana, cherry\"\n```\n如果参数包含undefined元素，它们会被排到数组的尾部。\n为了按照其他方式而非字母表顺序进行排序，必须给`sort()`方法传递一个比较函数。该函数决定了它的两个参数在排好序的数组中的先后顺序。假设第一个参数应该在前，比较函数应该返回一个小鱼0的数值。反之，假设第一个参数应该在后，函数应该返回一个大于0的数值。并且，假设两个值相等（也就是说，他们的顺序无关紧要），函数应该返回0。因此，例如，用数值大小而非字母表顺序进行数组排序，代码如下：\n```\nvar a = [33, 4, 1111, 222];\na.sort();                // 字母表顺序: 1111, 222, 33, 4\na.sort(function (a, b) { // 数值顺序: 4, 33, 222, 1111\n  return a - b;          // 根据顺序，返回负数、0、正数\n})\na.sort(function (a, b) { // 数值大小相反顺序\n  return b - a;\n})\n```\n另外一个数组元素排序的例子，也许需要对一个字符串数组执行不区分大小写的字母表排序，比较函数首先将参数都转化为小写字符串（使用`toLowerCase()`方法），再开始比较：\n```\na = ['ant', 'Bug', 'cat', 'Dog']\na.sort();                // 区分大小写的排序: ['Bug','Dog','ant','cat']\na.sort(function (s, t) { // 不区分大小写的排序\n  var a = s.toLowerCase();\n  var b = t.toLowerCase();\n  if (a < b) {\n    return -1;\n  }\n  if (a > b) {\n    return 1;\n  }\n  return 0;\n});                     // => ['ant','Bug','cat','Dog']\n```\n\n##### 4. concat()\n`Array.concat()`方法创建并返回一个新数组，它的元素包括调用`concat()`的元时数组的元素和`concat()`的每个参数。如果这些参数中的任何一个自身是数组，则连接的是数组的元素，而非数组本身。但要注意，`concat()`不会递归扁平化数组的数组。`concat()`也不会修改调用的数组。示例如下：\n```\nvar a = [1, 2, 3];\na.concat(4, 5);        // 返回[1, 2, 3, 4, 5]\na.concat([4, 5]);       // 返回[1, 2, 3, 4, 5]\na.concat([4, 5], [6, 7]); // 返回[1, 2, 3, 4, 5, 6, 7]\na.concat(4, [5, [6, 7]]); // 返回[1, 2, 3, 4, 5, [6, 7]]\n```\n\n##### 5. slice()\n`Array.slice()`方法返回指定数组的一个片段或子数组。它的两个参数分别指定了片段的开始和结束的位置。返回的数组包含第一个参数指定的位置和所有到但不包含第二参数指定的位置的所有数组元素。如果只指定一个参数，返回的数组将包含从开始位置到数组结尾的所有元素。如果参数中出现了负数，它表示相对数组中最后一个元素的位置。例如，参数-1指定了最后一个元素，而-3指定了倒数第三个元素。但是`slice()`不会修改调用的数组。例如：\n```\nvar a = [1, 2, 3, 4, 5];\na.slice(0, 3);   // 返回[1, 2, 3]\na.slice(3);      // 返回[4, 5]\na.slice(1, -1);  // 返回[2, 3, 4]\na.slice(-3, -2); // 返回[3]\n```\n    \n##### 6.splice()\n`Array.splice()`方法是在数组中插入或删除元素的通用方法。不同于`slice()`和`concat()`，`splice()`会修改调用的数组。但是，`splice()`和`slice()`拥有非常相似的名字，但它们的功能却有本质的区别。\n`splice()`能够从数组中删除元素、插入元素到数组中或者同时完成这两种操作。在插入或删除点之后的数组元素会根据需要增加或减小它们的索引值，因此数组的其他部分仍然保持连续的。`splice()`的第一个参数指定了插入和（或）删除的起始位置。第二个参数指定了应该从数组中删除的元素个数。如果省略第二个参数，从起始点开始到数组结尾的所有元素都将被删除。`splice()`返回一个由删除元素组成的数组，或者如果没有删除元素就返回一个空数组。例如：\n```\nvar a = [1, 2, 3, 4, 5, 6, 7, 8];\na.splice(4);    // 返回[5, 6, 7, 8];a是[1,2,3,4]\na.splice(1, 2); // 返回[2, 3];a是[1,4]\na.splice(1, 1); // 返回[4];a是[1]\n```\n`splice()`的前两个参数指定了需要删除的数组元素。紧随其后的任意个数的参数指定了需要插入到数组中的元素，从第一个参数指定的位置开始插入。例如：\n```\nvar a = [1, 2, 3, 4, 5];\na.splice(2, 0, 'a', 'b');  // 返回[],a是[1, 2, \"a\", \"b\", 3, 4, 5]\na.splice(2, 2, [1, 2], 3); // 返回[\"a\", \"b\"],a是[1, 2, [1, 2], 3, 3, 4, 5]\n```\n区别于`concat()`，`splice()`会插入数组本身而非数组的元素。\n\n##### 7. push()和pop()\n`push()`和`pop()`方法允许将数组当做栈来调用。`push()` 方法在数组的尾部添加一个或多个元素，并返回数组新的长度。`pop()` 方法则相反：它删除数组的最后一个元素，减小数组长度并返回它删除的值。两个方法都修改并替换原始数组而非生成一个修改版的新数组。组合使用`push()` 和`pop()` 能够用JavaScript数组实现现金后出的栈。例如：\n```\nvar stack = [];     // stack: []\nstack.push(1, 2);   // stack: [1, 2]\nstack.pop();        // stack: [1]\nstack.push(3);      // stack: [1, 3]\nstack.pop();        // stack: [1]\nstack.push([4, 5]); // stack: [1, [4, 5]]\nstack.pop();        // stack: [1]\nstack.pop();        // stack: []\n```\n\n##### 8. unshift()和shift()\n`unshift()`和`shift()`方法的行为非常类似于`push()` 和`pop()`，不一样的是前者是在数组的头部而非尾部进行元素的插入和删除操作。 `unshift()` 在数组的头部添加一个或多个元素，并将已存在的元素移动到更高索引的位置来获得足够的空间，最后返回数组新的长度。`shift()`删除数组的第一个元素并将其返回，然后把所有随后的元素下移一个位置来填补数组头部的空缺。例如：\n```\nvar a = [];            // a:[]\na.unshift(1);          // a:[1] 返回:1\na.unshift(22);         // a:[22, 1] 返回:2\na.shift();             // a:[1] 返回:22\na.unshift(3, [4, 5]);  // a:[3, [4, 5], 1] 返回:3\na.shift();             // a:[[4, 5], 1] 返回:3\na.shift();             // a:[1] 返回:[4, 5]\na.shift();             // a:[] 返回:1\n```\n当使用多个参数调用 `unshift()`时它的行为很奇怪。参数是一次性插入的（就像`splice()`方法）而非一次一个地插入。这意味着最终的数组中插入的元素的顺序和它们在参数列表中的顺序一致。而假如元素是一次一个地插入，它们的顺序应该是反过来的。\n\n##### 8. toString()和toLocaleString()\n数组和其他JavaScript对象一样拥有`toString()`方法。针对数组，该方法将其每个元素转化为字符串（如有必要将调用元素的`toString()`方法）并且输出用逗号分隔的字符串列表。但是要注意输出不包括方括号或其他任何形式的包裹数组值的分隔符。例如：\n```\n[1, 2, 3].toString();       // 生成\"1,2,3\"\n[\"a\", \"b\", \"c\"].toString(); // 生成\"a,b,c\"\n[1, [2, 'c']].toString();   // 生成\"1,2,c\"\n```\n这里于不适用任何参调用`join()`方法返回的字符串是一样的。\n`toLocaleString()`是`toString()`方法的本地化版本。它调用元素的`toLocaleString()`方法将每个数组元素转化为字符串，并且使用本地化（和自定义实现的）分隔符将这些字符串连接起来生成最终的字符串。\n","source":"_posts/JavaScript数组方法.md","raw":"---\ntitle: JavaScript数组方法\ndate: 2019-03-23 09:21:08  \ncategories: JavaScript\ntags:\n---\n\n## 数组方法\n\n&#160; &#160; &#160; &#160;ECMAScript在Array.prototype中定义了一些很有用的操作数组的函数，这意味着这些函数作为任何数组的方法都是可用的。\n\n##### 1. join()\n`Array.join()`方法将数组中所有元素都专户为字符串并连接在一起，返回最后生成的字符串。可以指定一个可选的字符串在生在的字符串中来分隔数组的各个元素。如果不指定分隔符，默认使用逗号。代码如下：\n```\nvar a = [1, 2, 3];     // 创建一个包含三个元素的数组\na.join();              // => \"1,2,3\"\na.join(\" \");           // => \"1 2 3\"\na.join(\"\");            // => \"123\"\n```\n`Array.join()` 方法是String.split()方法的逆向操作，后者是将字符串分割成若干块来创建一个数组。\n\n##### 2. reverse()\n`Array.reverse()`方法将数组中的元素颠倒顺序，返回逆向的数组。它采取了替换；换句话说，它不通过重新排列的元素创建新的数组，而是在原先的数组中重新排列他们。例如，下面的代码使用`reverse()`和`join()`方法生成字符串“3，2，1”：\n```\nvar a = [1,2,3];\na.reverse().join();   // => \"3,2,1\",并且现在的a是[3,2,1] \n```\n\n##### 3. sort()\n`Array.sort()`方法将数组中的元素排序并返回排序后的数组。当不带参数调用`sort()`时，数组元素以字母表顺序排列（如有必要将临时转化为字符串进行比较）：\n```\nvar a = new Array(\"banana\", \"cherry\", \"apple\");\na.sort();\nvar s = a.join(\"， ”)；  //  s = \"apple, banana, cherry\"\n```\n如果参数包含undefined元素，它们会被排到数组的尾部。\n为了按照其他方式而非字母表顺序进行排序，必须给`sort()`方法传递一个比较函数。该函数决定了它的两个参数在排好序的数组中的先后顺序。假设第一个参数应该在前，比较函数应该返回一个小鱼0的数值。反之，假设第一个参数应该在后，函数应该返回一个大于0的数值。并且，假设两个值相等（也就是说，他们的顺序无关紧要），函数应该返回0。因此，例如，用数值大小而非字母表顺序进行数组排序，代码如下：\n```\nvar a = [33, 4, 1111, 222];\na.sort();                // 字母表顺序: 1111, 222, 33, 4\na.sort(function (a, b) { // 数值顺序: 4, 33, 222, 1111\n  return a - b;          // 根据顺序，返回负数、0、正数\n})\na.sort(function (a, b) { // 数值大小相反顺序\n  return b - a;\n})\n```\n另外一个数组元素排序的例子，也许需要对一个字符串数组执行不区分大小写的字母表排序，比较函数首先将参数都转化为小写字符串（使用`toLowerCase()`方法），再开始比较：\n```\na = ['ant', 'Bug', 'cat', 'Dog']\na.sort();                // 区分大小写的排序: ['Bug','Dog','ant','cat']\na.sort(function (s, t) { // 不区分大小写的排序\n  var a = s.toLowerCase();\n  var b = t.toLowerCase();\n  if (a < b) {\n    return -1;\n  }\n  if (a > b) {\n    return 1;\n  }\n  return 0;\n});                     // => ['ant','Bug','cat','Dog']\n```\n\n##### 4. concat()\n`Array.concat()`方法创建并返回一个新数组，它的元素包括调用`concat()`的元时数组的元素和`concat()`的每个参数。如果这些参数中的任何一个自身是数组，则连接的是数组的元素，而非数组本身。但要注意，`concat()`不会递归扁平化数组的数组。`concat()`也不会修改调用的数组。示例如下：\n```\nvar a = [1, 2, 3];\na.concat(4, 5);        // 返回[1, 2, 3, 4, 5]\na.concat([4, 5]);       // 返回[1, 2, 3, 4, 5]\na.concat([4, 5], [6, 7]); // 返回[1, 2, 3, 4, 5, 6, 7]\na.concat(4, [5, [6, 7]]); // 返回[1, 2, 3, 4, 5, [6, 7]]\n```\n\n##### 5. slice()\n`Array.slice()`方法返回指定数组的一个片段或子数组。它的两个参数分别指定了片段的开始和结束的位置。返回的数组包含第一个参数指定的位置和所有到但不包含第二参数指定的位置的所有数组元素。如果只指定一个参数，返回的数组将包含从开始位置到数组结尾的所有元素。如果参数中出现了负数，它表示相对数组中最后一个元素的位置。例如，参数-1指定了最后一个元素，而-3指定了倒数第三个元素。但是`slice()`不会修改调用的数组。例如：\n```\nvar a = [1, 2, 3, 4, 5];\na.slice(0, 3);   // 返回[1, 2, 3]\na.slice(3);      // 返回[4, 5]\na.slice(1, -1);  // 返回[2, 3, 4]\na.slice(-3, -2); // 返回[3]\n```\n    \n##### 6.splice()\n`Array.splice()`方法是在数组中插入或删除元素的通用方法。不同于`slice()`和`concat()`，`splice()`会修改调用的数组。但是，`splice()`和`slice()`拥有非常相似的名字，但它们的功能却有本质的区别。\n`splice()`能够从数组中删除元素、插入元素到数组中或者同时完成这两种操作。在插入或删除点之后的数组元素会根据需要增加或减小它们的索引值，因此数组的其他部分仍然保持连续的。`splice()`的第一个参数指定了插入和（或）删除的起始位置。第二个参数指定了应该从数组中删除的元素个数。如果省略第二个参数，从起始点开始到数组结尾的所有元素都将被删除。`splice()`返回一个由删除元素组成的数组，或者如果没有删除元素就返回一个空数组。例如：\n```\nvar a = [1, 2, 3, 4, 5, 6, 7, 8];\na.splice(4);    // 返回[5, 6, 7, 8];a是[1,2,3,4]\na.splice(1, 2); // 返回[2, 3];a是[1,4]\na.splice(1, 1); // 返回[4];a是[1]\n```\n`splice()`的前两个参数指定了需要删除的数组元素。紧随其后的任意个数的参数指定了需要插入到数组中的元素，从第一个参数指定的位置开始插入。例如：\n```\nvar a = [1, 2, 3, 4, 5];\na.splice(2, 0, 'a', 'b');  // 返回[],a是[1, 2, \"a\", \"b\", 3, 4, 5]\na.splice(2, 2, [1, 2], 3); // 返回[\"a\", \"b\"],a是[1, 2, [1, 2], 3, 3, 4, 5]\n```\n区别于`concat()`，`splice()`会插入数组本身而非数组的元素。\n\n##### 7. push()和pop()\n`push()`和`pop()`方法允许将数组当做栈来调用。`push()` 方法在数组的尾部添加一个或多个元素，并返回数组新的长度。`pop()` 方法则相反：它删除数组的最后一个元素，减小数组长度并返回它删除的值。两个方法都修改并替换原始数组而非生成一个修改版的新数组。组合使用`push()` 和`pop()` 能够用JavaScript数组实现现金后出的栈。例如：\n```\nvar stack = [];     // stack: []\nstack.push(1, 2);   // stack: [1, 2]\nstack.pop();        // stack: [1]\nstack.push(3);      // stack: [1, 3]\nstack.pop();        // stack: [1]\nstack.push([4, 5]); // stack: [1, [4, 5]]\nstack.pop();        // stack: [1]\nstack.pop();        // stack: []\n```\n\n##### 8. unshift()和shift()\n`unshift()`和`shift()`方法的行为非常类似于`push()` 和`pop()`，不一样的是前者是在数组的头部而非尾部进行元素的插入和删除操作。 `unshift()` 在数组的头部添加一个或多个元素，并将已存在的元素移动到更高索引的位置来获得足够的空间，最后返回数组新的长度。`shift()`删除数组的第一个元素并将其返回，然后把所有随后的元素下移一个位置来填补数组头部的空缺。例如：\n```\nvar a = [];            // a:[]\na.unshift(1);          // a:[1] 返回:1\na.unshift(22);         // a:[22, 1] 返回:2\na.shift();             // a:[1] 返回:22\na.unshift(3, [4, 5]);  // a:[3, [4, 5], 1] 返回:3\na.shift();             // a:[[4, 5], 1] 返回:3\na.shift();             // a:[1] 返回:[4, 5]\na.shift();             // a:[] 返回:1\n```\n当使用多个参数调用 `unshift()`时它的行为很奇怪。参数是一次性插入的（就像`splice()`方法）而非一次一个地插入。这意味着最终的数组中插入的元素的顺序和它们在参数列表中的顺序一致。而假如元素是一次一个地插入，它们的顺序应该是反过来的。\n\n##### 8. toString()和toLocaleString()\n数组和其他JavaScript对象一样拥有`toString()`方法。针对数组，该方法将其每个元素转化为字符串（如有必要将调用元素的`toString()`方法）并且输出用逗号分隔的字符串列表。但是要注意输出不包括方括号或其他任何形式的包裹数组值的分隔符。例如：\n```\n[1, 2, 3].toString();       // 生成\"1,2,3\"\n[\"a\", \"b\", \"c\"].toString(); // 生成\"a,b,c\"\n[1, [2, 'c']].toString();   // 生成\"1,2,c\"\n```\n这里于不适用任何参调用`join()`方法返回的字符串是一样的。\n`toLocaleString()`是`toString()`方法的本地化版本。它调用元素的`toLocaleString()`方法将每个数组元素转化为字符串，并且使用本地化（和自定义实现的）分隔符将这些字符串连接起来生成最终的字符串。\n","slug":"JavaScript数组方法","published":1,"updated":"2020-04-01T02:15:52.391Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8gp7rxw0007kb9h8g2t7vb2","content":"<h2 id=\"数组方法\"><a href=\"#数组方法\" class=\"headerlink\" title=\"数组方法\"></a>数组方法</h2><p>&#160; &#160; &#160; &#160;ECMAScript在Array.prototype中定义了一些很有用的操作数组的函数，这意味着这些函数作为任何数组的方法都是可用的。</p>\n<h5 id=\"1-join\"><a href=\"#1-join\" class=\"headerlink\" title=\"1. join()\"></a>1. join()</h5><p><code>Array.join()</code>方法将数组中所有元素都专户为字符串并连接在一起，返回最后生成的字符串。可以指定一个可选的字符串在生在的字符串中来分隔数组的各个元素。如果不指定分隔符，默认使用逗号。代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; [1, 2, 3];     &#x2F;&#x2F; 创建一个包含三个元素的数组</span><br><span class=\"line\">a.join();              &#x2F;&#x2F; &#x3D;&gt; &quot;1,2,3&quot;</span><br><span class=\"line\">a.join(&quot; &quot;);           &#x2F;&#x2F; &#x3D;&gt; &quot;1 2 3&quot;</span><br><span class=\"line\">a.join(&quot;&quot;);            &#x2F;&#x2F; &#x3D;&gt; &quot;123&quot;</span><br></pre></td></tr></table></figure>\n<p><code>Array.join()</code> 方法是String.split()方法的逆向操作，后者是将字符串分割成若干块来创建一个数组。</p>\n<h5 id=\"2-reverse\"><a href=\"#2-reverse\" class=\"headerlink\" title=\"2. reverse()\"></a>2. reverse()</h5><p><code>Array.reverse()</code>方法将数组中的元素颠倒顺序，返回逆向的数组。它采取了替换；换句话说，它不通过重新排列的元素创建新的数组，而是在原先的数组中重新排列他们。例如，下面的代码使用<code>reverse()</code>和<code>join()</code>方法生成字符串“3，2，1”：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; [1,2,3];</span><br><span class=\"line\">a.reverse().join();   &#x2F;&#x2F; &#x3D;&gt; &quot;3,2,1&quot;,并且现在的a是[3,2,1]</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-sort\"><a href=\"#3-sort\" class=\"headerlink\" title=\"3. sort()\"></a>3. sort()</h5><p><code>Array.sort()</code>方法将数组中的元素排序并返回排序后的数组。当不带参数调用<code>sort()</code>时，数组元素以字母表顺序排列（如有必要将临时转化为字符串进行比较）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; new Array(&quot;banana&quot;, &quot;cherry&quot;, &quot;apple&quot;);</span><br><span class=\"line\">a.sort();</span><br><span class=\"line\">var s &#x3D; a.join(&quot;， ”)；  &#x2F;&#x2F;  s &#x3D; &quot;apple, banana, cherry&quot;</span><br></pre></td></tr></table></figure>\n<p>如果参数包含undefined元素，它们会被排到数组的尾部。<br>为了按照其他方式而非字母表顺序进行排序，必须给<code>sort()</code>方法传递一个比较函数。该函数决定了它的两个参数在排好序的数组中的先后顺序。假设第一个参数应该在前，比较函数应该返回一个小鱼0的数值。反之，假设第一个参数应该在后，函数应该返回一个大于0的数值。并且，假设两个值相等（也就是说，他们的顺序无关紧要），函数应该返回0。因此，例如，用数值大小而非字母表顺序进行数组排序，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; [33, 4, 1111, 222];</span><br><span class=\"line\">a.sort();                &#x2F;&#x2F; 字母表顺序: 1111, 222, 33, 4</span><br><span class=\"line\">a.sort(function (a, b) &#123; &#x2F;&#x2F; 数值顺序: 4, 33, 222, 1111</span><br><span class=\"line\">  return a - b;          &#x2F;&#x2F; 根据顺序，返回负数、0、正数</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">a.sort(function (a, b) &#123; &#x2F;&#x2F; 数值大小相反顺序</span><br><span class=\"line\">  return b - a;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>另外一个数组元素排序的例子，也许需要对一个字符串数组执行不区分大小写的字母表排序，比较函数首先将参数都转化为小写字符串（使用<code>toLowerCase()</code>方法），再开始比较：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a &#x3D; [&#39;ant&#39;, &#39;Bug&#39;, &#39;cat&#39;, &#39;Dog&#39;]</span><br><span class=\"line\">a.sort();                &#x2F;&#x2F; 区分大小写的排序: [&#39;Bug&#39;,&#39;Dog&#39;,&#39;ant&#39;,&#39;cat&#39;]</span><br><span class=\"line\">a.sort(function (s, t) &#123; &#x2F;&#x2F; 不区分大小写的排序</span><br><span class=\"line\">  var a &#x3D; s.toLowerCase();</span><br><span class=\"line\">  var b &#x3D; t.toLowerCase();</span><br><span class=\"line\">  if (a &lt; b) &#123;</span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if (a &gt; b) &#123;</span><br><span class=\"line\">    return 1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;);                     &#x2F;&#x2F; &#x3D;&gt; [&#39;ant&#39;,&#39;Bug&#39;,&#39;cat&#39;,&#39;Dog&#39;]</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4-concat\"><a href=\"#4-concat\" class=\"headerlink\" title=\"4. concat()\"></a>4. concat()</h5><p><code>Array.concat()</code>方法创建并返回一个新数组，它的元素包括调用<code>concat()</code>的元时数组的元素和<code>concat()</code>的每个参数。如果这些参数中的任何一个自身是数组，则连接的是数组的元素，而非数组本身。但要注意，<code>concat()</code>不会递归扁平化数组的数组。<code>concat()</code>也不会修改调用的数组。示例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; [1, 2, 3];</span><br><span class=\"line\">a.concat(4, 5);        &#x2F;&#x2F; 返回[1, 2, 3, 4, 5]</span><br><span class=\"line\">a.concat([4, 5]);       &#x2F;&#x2F; 返回[1, 2, 3, 4, 5]</span><br><span class=\"line\">a.concat([4, 5], [6, 7]); &#x2F;&#x2F; 返回[1, 2, 3, 4, 5, 6, 7]</span><br><span class=\"line\">a.concat(4, [5, [6, 7]]); &#x2F;&#x2F; 返回[1, 2, 3, 4, 5, [6, 7]]</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"5-slice\"><a href=\"#5-slice\" class=\"headerlink\" title=\"5. slice()\"></a>5. slice()</h5><p><code>Array.slice()</code>方法返回指定数组的一个片段或子数组。它的两个参数分别指定了片段的开始和结束的位置。返回的数组包含第一个参数指定的位置和所有到但不包含第二参数指定的位置的所有数组元素。如果只指定一个参数，返回的数组将包含从开始位置到数组结尾的所有元素。如果参数中出现了负数，它表示相对数组中最后一个元素的位置。例如，参数-1指定了最后一个元素，而-3指定了倒数第三个元素。但是<code>slice()</code>不会修改调用的数组。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; [1, 2, 3, 4, 5];</span><br><span class=\"line\">a.slice(0, 3);   &#x2F;&#x2F; 返回[1, 2, 3]</span><br><span class=\"line\">a.slice(3);      &#x2F;&#x2F; 返回[4, 5]</span><br><span class=\"line\">a.slice(1, -1);  &#x2F;&#x2F; 返回[2, 3, 4]</span><br><span class=\"line\">a.slice(-3, -2); &#x2F;&#x2F; 返回[3]</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"6-splice\"><a href=\"#6-splice\" class=\"headerlink\" title=\"6.splice()\"></a>6.splice()</h5><p><code>Array.splice()</code>方法是在数组中插入或删除元素的通用方法。不同于<code>slice()</code>和<code>concat()</code>，<code>splice()</code>会修改调用的数组。但是，<code>splice()</code>和<code>slice()</code>拥有非常相似的名字，但它们的功能却有本质的区别。<br><code>splice()</code>能够从数组中删除元素、插入元素到数组中或者同时完成这两种操作。在插入或删除点之后的数组元素会根据需要增加或减小它们的索引值，因此数组的其他部分仍然保持连续的。<code>splice()</code>的第一个参数指定了插入和（或）删除的起始位置。第二个参数指定了应该从数组中删除的元素个数。如果省略第二个参数，从起始点开始到数组结尾的所有元素都将被删除。<code>splice()</code>返回一个由删除元素组成的数组，或者如果没有删除元素就返回一个空数组。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; [1, 2, 3, 4, 5, 6, 7, 8];</span><br><span class=\"line\">a.splice(4);    &#x2F;&#x2F; 返回[5, 6, 7, 8];a是[1,2,3,4]</span><br><span class=\"line\">a.splice(1, 2); &#x2F;&#x2F; 返回[2, 3];a是[1,4]</span><br><span class=\"line\">a.splice(1, 1); &#x2F;&#x2F; 返回[4];a是[1]</span><br></pre></td></tr></table></figure>\n<p><code>splice()</code>的前两个参数指定了需要删除的数组元素。紧随其后的任意个数的参数指定了需要插入到数组中的元素，从第一个参数指定的位置开始插入。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; [1, 2, 3, 4, 5];</span><br><span class=\"line\">a.splice(2, 0, &#39;a&#39;, &#39;b&#39;);  &#x2F;&#x2F; 返回[],a是[1, 2, &quot;a&quot;, &quot;b&quot;, 3, 4, 5]</span><br><span class=\"line\">a.splice(2, 2, [1, 2], 3); &#x2F;&#x2F; 返回[&quot;a&quot;, &quot;b&quot;],a是[1, 2, [1, 2], 3, 3, 4, 5]</span><br></pre></td></tr></table></figure>\n<p>区别于<code>concat()</code>，<code>splice()</code>会插入数组本身而非数组的元素。</p>\n<h5 id=\"7-push-和pop\"><a href=\"#7-push-和pop\" class=\"headerlink\" title=\"7. push()和pop()\"></a>7. push()和pop()</h5><p><code>push()</code>和<code>pop()</code>方法允许将数组当做栈来调用。<code>push()</code> 方法在数组的尾部添加一个或多个元素，并返回数组新的长度。<code>pop()</code> 方法则相反：它删除数组的最后一个元素，减小数组长度并返回它删除的值。两个方法都修改并替换原始数组而非生成一个修改版的新数组。组合使用<code>push()</code> 和<code>pop()</code> 能够用JavaScript数组实现现金后出的栈。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var stack &#x3D; [];     &#x2F;&#x2F; stack: []</span><br><span class=\"line\">stack.push(1, 2);   &#x2F;&#x2F; stack: [1, 2]</span><br><span class=\"line\">stack.pop();        &#x2F;&#x2F; stack: [1]</span><br><span class=\"line\">stack.push(3);      &#x2F;&#x2F; stack: [1, 3]</span><br><span class=\"line\">stack.pop();        &#x2F;&#x2F; stack: [1]</span><br><span class=\"line\">stack.push([4, 5]); &#x2F;&#x2F; stack: [1, [4, 5]]</span><br><span class=\"line\">stack.pop();        &#x2F;&#x2F; stack: [1]</span><br><span class=\"line\">stack.pop();        &#x2F;&#x2F; stack: []</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"8-unshift-和shift\"><a href=\"#8-unshift-和shift\" class=\"headerlink\" title=\"8. unshift()和shift()\"></a>8. unshift()和shift()</h5><p><code>unshift()</code>和<code>shift()</code>方法的行为非常类似于<code>push()</code> 和<code>pop()</code>，不一样的是前者是在数组的头部而非尾部进行元素的插入和删除操作。 <code>unshift()</code> 在数组的头部添加一个或多个元素，并将已存在的元素移动到更高索引的位置来获得足够的空间，最后返回数组新的长度。<code>shift()</code>删除数组的第一个元素并将其返回，然后把所有随后的元素下移一个位置来填补数组头部的空缺。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; [];            &#x2F;&#x2F; a:[]</span><br><span class=\"line\">a.unshift(1);          &#x2F;&#x2F; a:[1] 返回:1</span><br><span class=\"line\">a.unshift(22);         &#x2F;&#x2F; a:[22, 1] 返回:2</span><br><span class=\"line\">a.shift();             &#x2F;&#x2F; a:[1] 返回:22</span><br><span class=\"line\">a.unshift(3, [4, 5]);  &#x2F;&#x2F; a:[3, [4, 5], 1] 返回:3</span><br><span class=\"line\">a.shift();             &#x2F;&#x2F; a:[[4, 5], 1] 返回:3</span><br><span class=\"line\">a.shift();             &#x2F;&#x2F; a:[1] 返回:[4, 5]</span><br><span class=\"line\">a.shift();             &#x2F;&#x2F; a:[] 返回:1</span><br></pre></td></tr></table></figure>\n<p>当使用多个参数调用 <code>unshift()</code>时它的行为很奇怪。参数是一次性插入的（就像<code>splice()</code>方法）而非一次一个地插入。这意味着最终的数组中插入的元素的顺序和它们在参数列表中的顺序一致。而假如元素是一次一个地插入，它们的顺序应该是反过来的。</p>\n<h5 id=\"8-toString-和toLocaleString\"><a href=\"#8-toString-和toLocaleString\" class=\"headerlink\" title=\"8. toString()和toLocaleString()\"></a>8. toString()和toLocaleString()</h5><p>数组和其他JavaScript对象一样拥有<code>toString()</code>方法。针对数组，该方法将其每个元素转化为字符串（如有必要将调用元素的<code>toString()</code>方法）并且输出用逗号分隔的字符串列表。但是要注意输出不包括方括号或其他任何形式的包裹数组值的分隔符。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3].toString();       &#x2F;&#x2F; 生成&quot;1,2,3&quot;</span><br><span class=\"line\">[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].toString(); &#x2F;&#x2F; 生成&quot;a,b,c&quot;</span><br><span class=\"line\">[1, [2, &#39;c&#39;]].toString();   &#x2F;&#x2F; 生成&quot;1,2,c&quot;</span><br></pre></td></tr></table></figure>\n<p>这里于不适用任何参调用<code>join()</code>方法返回的字符串是一样的。<br><code>toLocaleString()</code>是<code>toString()</code>方法的本地化版本。它调用元素的<code>toLocaleString()</code>方法将每个数组元素转化为字符串，并且使用本地化（和自定义实现的）分隔符将这些字符串连接起来生成最终的字符串。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"数组方法\"><a href=\"#数组方法\" class=\"headerlink\" title=\"数组方法\"></a>数组方法</h2><p>&#160; &#160; &#160; &#160;ECMAScript在Array.prototype中定义了一些很有用的操作数组的函数，这意味着这些函数作为任何数组的方法都是可用的。</p>\n<h5 id=\"1-join\"><a href=\"#1-join\" class=\"headerlink\" title=\"1. join()\"></a>1. join()</h5><p><code>Array.join()</code>方法将数组中所有元素都专户为字符串并连接在一起，返回最后生成的字符串。可以指定一个可选的字符串在生在的字符串中来分隔数组的各个元素。如果不指定分隔符，默认使用逗号。代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; [1, 2, 3];     &#x2F;&#x2F; 创建一个包含三个元素的数组</span><br><span class=\"line\">a.join();              &#x2F;&#x2F; &#x3D;&gt; &quot;1,2,3&quot;</span><br><span class=\"line\">a.join(&quot; &quot;);           &#x2F;&#x2F; &#x3D;&gt; &quot;1 2 3&quot;</span><br><span class=\"line\">a.join(&quot;&quot;);            &#x2F;&#x2F; &#x3D;&gt; &quot;123&quot;</span><br></pre></td></tr></table></figure>\n<p><code>Array.join()</code> 方法是String.split()方法的逆向操作，后者是将字符串分割成若干块来创建一个数组。</p>\n<h5 id=\"2-reverse\"><a href=\"#2-reverse\" class=\"headerlink\" title=\"2. reverse()\"></a>2. reverse()</h5><p><code>Array.reverse()</code>方法将数组中的元素颠倒顺序，返回逆向的数组。它采取了替换；换句话说，它不通过重新排列的元素创建新的数组，而是在原先的数组中重新排列他们。例如，下面的代码使用<code>reverse()</code>和<code>join()</code>方法生成字符串“3，2，1”：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; [1,2,3];</span><br><span class=\"line\">a.reverse().join();   &#x2F;&#x2F; &#x3D;&gt; &quot;3,2,1&quot;,并且现在的a是[3,2,1]</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-sort\"><a href=\"#3-sort\" class=\"headerlink\" title=\"3. sort()\"></a>3. sort()</h5><p><code>Array.sort()</code>方法将数组中的元素排序并返回排序后的数组。当不带参数调用<code>sort()</code>时，数组元素以字母表顺序排列（如有必要将临时转化为字符串进行比较）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; new Array(&quot;banana&quot;, &quot;cherry&quot;, &quot;apple&quot;);</span><br><span class=\"line\">a.sort();</span><br><span class=\"line\">var s &#x3D; a.join(&quot;， ”)；  &#x2F;&#x2F;  s &#x3D; &quot;apple, banana, cherry&quot;</span><br></pre></td></tr></table></figure>\n<p>如果参数包含undefined元素，它们会被排到数组的尾部。<br>为了按照其他方式而非字母表顺序进行排序，必须给<code>sort()</code>方法传递一个比较函数。该函数决定了它的两个参数在排好序的数组中的先后顺序。假设第一个参数应该在前，比较函数应该返回一个小鱼0的数值。反之，假设第一个参数应该在后，函数应该返回一个大于0的数值。并且，假设两个值相等（也就是说，他们的顺序无关紧要），函数应该返回0。因此，例如，用数值大小而非字母表顺序进行数组排序，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; [33, 4, 1111, 222];</span><br><span class=\"line\">a.sort();                &#x2F;&#x2F; 字母表顺序: 1111, 222, 33, 4</span><br><span class=\"line\">a.sort(function (a, b) &#123; &#x2F;&#x2F; 数值顺序: 4, 33, 222, 1111</span><br><span class=\"line\">  return a - b;          &#x2F;&#x2F; 根据顺序，返回负数、0、正数</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">a.sort(function (a, b) &#123; &#x2F;&#x2F; 数值大小相反顺序</span><br><span class=\"line\">  return b - a;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>另外一个数组元素排序的例子，也许需要对一个字符串数组执行不区分大小写的字母表排序，比较函数首先将参数都转化为小写字符串（使用<code>toLowerCase()</code>方法），再开始比较：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a &#x3D; [&#39;ant&#39;, &#39;Bug&#39;, &#39;cat&#39;, &#39;Dog&#39;]</span><br><span class=\"line\">a.sort();                &#x2F;&#x2F; 区分大小写的排序: [&#39;Bug&#39;,&#39;Dog&#39;,&#39;ant&#39;,&#39;cat&#39;]</span><br><span class=\"line\">a.sort(function (s, t) &#123; &#x2F;&#x2F; 不区分大小写的排序</span><br><span class=\"line\">  var a &#x3D; s.toLowerCase();</span><br><span class=\"line\">  var b &#x3D; t.toLowerCase();</span><br><span class=\"line\">  if (a &lt; b) &#123;</span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if (a &gt; b) &#123;</span><br><span class=\"line\">    return 1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;);                     &#x2F;&#x2F; &#x3D;&gt; [&#39;ant&#39;,&#39;Bug&#39;,&#39;cat&#39;,&#39;Dog&#39;]</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4-concat\"><a href=\"#4-concat\" class=\"headerlink\" title=\"4. concat()\"></a>4. concat()</h5><p><code>Array.concat()</code>方法创建并返回一个新数组，它的元素包括调用<code>concat()</code>的元时数组的元素和<code>concat()</code>的每个参数。如果这些参数中的任何一个自身是数组，则连接的是数组的元素，而非数组本身。但要注意，<code>concat()</code>不会递归扁平化数组的数组。<code>concat()</code>也不会修改调用的数组。示例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; [1, 2, 3];</span><br><span class=\"line\">a.concat(4, 5);        &#x2F;&#x2F; 返回[1, 2, 3, 4, 5]</span><br><span class=\"line\">a.concat([4, 5]);       &#x2F;&#x2F; 返回[1, 2, 3, 4, 5]</span><br><span class=\"line\">a.concat([4, 5], [6, 7]); &#x2F;&#x2F; 返回[1, 2, 3, 4, 5, 6, 7]</span><br><span class=\"line\">a.concat(4, [5, [6, 7]]); &#x2F;&#x2F; 返回[1, 2, 3, 4, 5, [6, 7]]</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"5-slice\"><a href=\"#5-slice\" class=\"headerlink\" title=\"5. slice()\"></a>5. slice()</h5><p><code>Array.slice()</code>方法返回指定数组的一个片段或子数组。它的两个参数分别指定了片段的开始和结束的位置。返回的数组包含第一个参数指定的位置和所有到但不包含第二参数指定的位置的所有数组元素。如果只指定一个参数，返回的数组将包含从开始位置到数组结尾的所有元素。如果参数中出现了负数，它表示相对数组中最后一个元素的位置。例如，参数-1指定了最后一个元素，而-3指定了倒数第三个元素。但是<code>slice()</code>不会修改调用的数组。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; [1, 2, 3, 4, 5];</span><br><span class=\"line\">a.slice(0, 3);   &#x2F;&#x2F; 返回[1, 2, 3]</span><br><span class=\"line\">a.slice(3);      &#x2F;&#x2F; 返回[4, 5]</span><br><span class=\"line\">a.slice(1, -1);  &#x2F;&#x2F; 返回[2, 3, 4]</span><br><span class=\"line\">a.slice(-3, -2); &#x2F;&#x2F; 返回[3]</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"6-splice\"><a href=\"#6-splice\" class=\"headerlink\" title=\"6.splice()\"></a>6.splice()</h5><p><code>Array.splice()</code>方法是在数组中插入或删除元素的通用方法。不同于<code>slice()</code>和<code>concat()</code>，<code>splice()</code>会修改调用的数组。但是，<code>splice()</code>和<code>slice()</code>拥有非常相似的名字，但它们的功能却有本质的区别。<br><code>splice()</code>能够从数组中删除元素、插入元素到数组中或者同时完成这两种操作。在插入或删除点之后的数组元素会根据需要增加或减小它们的索引值，因此数组的其他部分仍然保持连续的。<code>splice()</code>的第一个参数指定了插入和（或）删除的起始位置。第二个参数指定了应该从数组中删除的元素个数。如果省略第二个参数，从起始点开始到数组结尾的所有元素都将被删除。<code>splice()</code>返回一个由删除元素组成的数组，或者如果没有删除元素就返回一个空数组。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; [1, 2, 3, 4, 5, 6, 7, 8];</span><br><span class=\"line\">a.splice(4);    &#x2F;&#x2F; 返回[5, 6, 7, 8];a是[1,2,3,4]</span><br><span class=\"line\">a.splice(1, 2); &#x2F;&#x2F; 返回[2, 3];a是[1,4]</span><br><span class=\"line\">a.splice(1, 1); &#x2F;&#x2F; 返回[4];a是[1]</span><br></pre></td></tr></table></figure>\n<p><code>splice()</code>的前两个参数指定了需要删除的数组元素。紧随其后的任意个数的参数指定了需要插入到数组中的元素，从第一个参数指定的位置开始插入。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; [1, 2, 3, 4, 5];</span><br><span class=\"line\">a.splice(2, 0, &#39;a&#39;, &#39;b&#39;);  &#x2F;&#x2F; 返回[],a是[1, 2, &quot;a&quot;, &quot;b&quot;, 3, 4, 5]</span><br><span class=\"line\">a.splice(2, 2, [1, 2], 3); &#x2F;&#x2F; 返回[&quot;a&quot;, &quot;b&quot;],a是[1, 2, [1, 2], 3, 3, 4, 5]</span><br></pre></td></tr></table></figure>\n<p>区别于<code>concat()</code>，<code>splice()</code>会插入数组本身而非数组的元素。</p>\n<h5 id=\"7-push-和pop\"><a href=\"#7-push-和pop\" class=\"headerlink\" title=\"7. push()和pop()\"></a>7. push()和pop()</h5><p><code>push()</code>和<code>pop()</code>方法允许将数组当做栈来调用。<code>push()</code> 方法在数组的尾部添加一个或多个元素，并返回数组新的长度。<code>pop()</code> 方法则相反：它删除数组的最后一个元素，减小数组长度并返回它删除的值。两个方法都修改并替换原始数组而非生成一个修改版的新数组。组合使用<code>push()</code> 和<code>pop()</code> 能够用JavaScript数组实现现金后出的栈。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var stack &#x3D; [];     &#x2F;&#x2F; stack: []</span><br><span class=\"line\">stack.push(1, 2);   &#x2F;&#x2F; stack: [1, 2]</span><br><span class=\"line\">stack.pop();        &#x2F;&#x2F; stack: [1]</span><br><span class=\"line\">stack.push(3);      &#x2F;&#x2F; stack: [1, 3]</span><br><span class=\"line\">stack.pop();        &#x2F;&#x2F; stack: [1]</span><br><span class=\"line\">stack.push([4, 5]); &#x2F;&#x2F; stack: [1, [4, 5]]</span><br><span class=\"line\">stack.pop();        &#x2F;&#x2F; stack: [1]</span><br><span class=\"line\">stack.pop();        &#x2F;&#x2F; stack: []</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"8-unshift-和shift\"><a href=\"#8-unshift-和shift\" class=\"headerlink\" title=\"8. unshift()和shift()\"></a>8. unshift()和shift()</h5><p><code>unshift()</code>和<code>shift()</code>方法的行为非常类似于<code>push()</code> 和<code>pop()</code>，不一样的是前者是在数组的头部而非尾部进行元素的插入和删除操作。 <code>unshift()</code> 在数组的头部添加一个或多个元素，并将已存在的元素移动到更高索引的位置来获得足够的空间，最后返回数组新的长度。<code>shift()</code>删除数组的第一个元素并将其返回，然后把所有随后的元素下移一个位置来填补数组头部的空缺。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; [];            &#x2F;&#x2F; a:[]</span><br><span class=\"line\">a.unshift(1);          &#x2F;&#x2F; a:[1] 返回:1</span><br><span class=\"line\">a.unshift(22);         &#x2F;&#x2F; a:[22, 1] 返回:2</span><br><span class=\"line\">a.shift();             &#x2F;&#x2F; a:[1] 返回:22</span><br><span class=\"line\">a.unshift(3, [4, 5]);  &#x2F;&#x2F; a:[3, [4, 5], 1] 返回:3</span><br><span class=\"line\">a.shift();             &#x2F;&#x2F; a:[[4, 5], 1] 返回:3</span><br><span class=\"line\">a.shift();             &#x2F;&#x2F; a:[1] 返回:[4, 5]</span><br><span class=\"line\">a.shift();             &#x2F;&#x2F; a:[] 返回:1</span><br></pre></td></tr></table></figure>\n<p>当使用多个参数调用 <code>unshift()</code>时它的行为很奇怪。参数是一次性插入的（就像<code>splice()</code>方法）而非一次一个地插入。这意味着最终的数组中插入的元素的顺序和它们在参数列表中的顺序一致。而假如元素是一次一个地插入，它们的顺序应该是反过来的。</p>\n<h5 id=\"8-toString-和toLocaleString\"><a href=\"#8-toString-和toLocaleString\" class=\"headerlink\" title=\"8. toString()和toLocaleString()\"></a>8. toString()和toLocaleString()</h5><p>数组和其他JavaScript对象一样拥有<code>toString()</code>方法。针对数组，该方法将其每个元素转化为字符串（如有必要将调用元素的<code>toString()</code>方法）并且输出用逗号分隔的字符串列表。但是要注意输出不包括方括号或其他任何形式的包裹数组值的分隔符。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3].toString();       &#x2F;&#x2F; 生成&quot;1,2,3&quot;</span><br><span class=\"line\">[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].toString(); &#x2F;&#x2F; 生成&quot;a,b,c&quot;</span><br><span class=\"line\">[1, [2, &#39;c&#39;]].toString();   &#x2F;&#x2F; 生成&quot;1,2,c&quot;</span><br></pre></td></tr></table></figure>\n<p>这里于不适用任何参调用<code>join()</code>方法返回的字符串是一样的。<br><code>toLocaleString()</code>是<code>toString()</code>方法的本地化版本。它调用元素的<code>toLocaleString()</code>方法将每个数组元素转化为字符串，并且使用本地化（和自定义实现的）分隔符将这些字符串连接起来生成最终的字符串。</p>\n"},{"title":"NodeJs学习笔记1","date":"2017-12-03T10:21:08.000Z","_content":"\n# 一、Node.js简介\n\n## 1.1 简介  \n\n&emsp; V8引擎本身就是用于Chrome浏览器的JS解释部分，但是RyanDahl把V8搬到了服务器上，用于做服务器的软件。  \n&emsp; Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。  \n&emsp; 与Node不同：  \n<table><td bgcolor=#FFFF00><font color=red>&emsp; Node.js不是一种独立的语言</font>，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的<font color=red>使用JavaScript进行编程</font>，运行在JavaScript引擎上（V8）。</td>\n</table>\n<table><td bgcolor=#FFFF00>&emsp; 与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），<font color=red>Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上</font>。Node.js的许多设计理念与经典架构(LAMP = Linux + Apache + MySQL + PHP)有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。</td></table>\n\n* **Node.js是花最小的硬件成本，追求更高的并发，更高的处理性能。**\n\n## 1.2 特点\n\n&emsp; 所谓的特点，就是Node.js是如何解决服务器高性能瓶颈问题的。\n<table><td bgcolor=#FF99CC>单线程</td><table>\n&emsp; 在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程。而每个线程需要耗费大约2MB内存。也就是说，理论上，一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。\n&emsp; Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。\n&emsp; 另外，带线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。\n&emsp; 坏处就是一个用户造成了线程的崩溃，整个服务都崩溃了，其他人也崩溃了。\n\n![多线程](http://img.blog.csdn.net/20171202214112906?) &emsp; &emsp; &emsp; ![单线程](http://img.blog.csdn.net/20171202214322932?)\n\n&emsp; 多线程、单线程的一个对比。\n&emsp; 也就是说，单线程也能造成宏观上的“并发”。\n<table><td bgcolor=#FF99CC>非阻塞I/O   non-blocking I/O </td><table>\n&emsp; 例如，当在访问数据库取得数据的时候，需要一段时间。在传统的单线程处理机制中，在执行了访问数据库代码之后，整个线程都将暂停下来，等待数据库返回结果，才能执行后面的代码。<font color=red>也就是说，I/O阻塞了代码的执行，极大地降低了程序的执行效率。</font>\n&emsp; 由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。\n&emsp; 当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。\n&emsp; 阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。<font color=red>而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%</font>。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。\n\n<table><td bgcolor=#FF99CC>&emsp; 事件驱动event-driven </td><table>\n&emsp; 在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件（比如，又有新用户连接了），然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。\n&emsp; Node.js底层是C++（V8也是C++写的）。<font color=red>底层代码中，近半数都用于事件队列、回调函数队列的构建</font>。用事件驱动来完成服务器的任务调度。用一个线程，担负起了处理非常多的任务的使命。\n\n![调度](http://img.blog.csdn.net/20171202214716848?)\n\n<table><td bgcolor=#CCFFFF>&emsp; <font color=red>单线程</font>，单线程的好处，减少了内存开销，操作系统的内存换页。\n&emsp; 如果某一个事情，进入了，但是被I/O阻塞了，所以这个线程就阻塞了。\n&emsp; <font color=red> 非阻塞I/O</font>，不会傻等I/O语句结束，而会执行后面的语句。\n&emsp; 非阻塞就能解决问题了么？比如执行着小红的业务，执行过程中，小刚的I/O回调完成了，此时怎么办？？\n&emsp; <font color=red>事件机制，事件环</font>，不管是新用户的请求，还是老用户的I/O完成，都将以事件方式加入事件环，等待调度。 </td><table>\n&emsp; 说是三个特点，实际上是一个特点，离开谁都不行，都玩儿不转了。\n&emsp; Node.js很像抠门的餐厅老板，只聘请1个服务员，服务很多人。结果，比很多服务员效率还高。\n&emsp; Node.js中所有的I/O都是异步的，回调函数，套回调函数。\n\n## 1.3 适合开发什么？\n\n&emsp; Node.js适合用来开发什么样的应用程序呢？\n&emsp; 善于I/O，不善于计算。因为Node.js最擅长的就是任务调度，如果你的业务有很多的CPU计算，实际上也相当于这个计算阻塞了这个单线程，就不适合Node开发。\n&emsp; <font color=red>当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与websocket配合，开发长连接的实时交互应用程序。</font>\n比如：\n\n 1. 用户表单手机\n 2.  考试系统\n 3. 聊天室\n 4. 图文直播\n 5. 提供JSON的API（为前台Angular使用）\n\n## 1.4 Node.js无法挑战老牌3P（php、jsp、asp）\n\n![对比图](http://img.blog.csdn.net/20171203141158354?)\n\n# 二、Node.js安装\n\n&emsp; Node.js和Java非常像，跨平台的。不管是Linux还是windows编程是完全一致的（有一些不一样，比如路径的表述）。Linux版本的Node.js环境和windows环境是不一样的，但是编程语言一样。很像Java虚拟机。\n&emsp; 安装版本6.9.4。\n&emsp; 装完之后，在环境变量中查看\n&emsp; \n\n![环境变量](http://img.blog.csdn.net/20171203141527438?)\n\n&emsp; 环境变量，就已经自动的填写进去了，就是我们node安装的目录。\n<table><td bgcolor=#FFFF99>&emsp; 什么叫做环境变量？就是在系统的任何目录下，都能运行c:\\program files\\nodejs里面的程序。 </td><table>\n&emsp; 在cmd中，输入node -v就能够查看nodejs的版本。我们现在的盘符，不在安装目录下，但是也能够运行，这就是因为有系统环境变量。系统的环境变量已经有了c:\\program files\\nodejs了，所以，这个文件夹中的node.exe就能够在任何盘符运行。\n&emsp; \n\n![安装后的node](http://img.blog.csdn.net/20171203141739359?)\n\n \n&emsp; 运行文件，就要用node命令来运行(进入node代码所在文件夹，使用node 相对地址)：\n&emsp; \n\n![挂起状态](http://img.blog.csdn.net/20171203141937348?)\n\n&emsp; Node.js是服务器的程序，写的js语句，都将运行在服务器上。返回给客户的，都是已经处理好的纯html。\n\n01_HelloWorld.js\n\n``` \n//require表示引包，引包就是引用自己的一个特殊功能\nvar http = require(\"http\");\n//创建服务器，参数是一个回调函数，表示如果有请求进来，要做什么\nvar server = http.createServer(function(req,res){\n\t//req表示请求，request;  res表示响应，response\n\t//设置HTTP头部，状态码是200，文件类型是html，字符集是utf8\n\tres.writeHead(200,{\"Content-type\":\"text/html;charset=UTF-8\"});\n\tres.end(\"哈哈哈哈，我买了五个iPhone\" + (1+2+3) + \"s\");\n});\n\n//运行服务器，监听3000端口（端口号可以任改）\nserver.listen(3000,\"127.0.0.1\");\n```\n\n&emsp; 如果想修改程序，必须中断当前运行的服务器，重新node一次，刷新，才行。\n&emsp; <font color=red>ctrl+c，就可以打断挂起的服务器程序</font>。此时按上箭头，能够快速调用最近的node命令。\n&emsp; 本地的一个js，无法直接拖入浏览器运行，但是node可以让任何一个js文件，都可以通过它来运行。也就是说，<font color=red>node就是一个js的执行环境</font>。\n&emsp; 要跑起来一个服务器，这个服务器的脚本，要以.js存储，是一个js文件。用node命令运行这个js文件即可。\n<table><td bgcolor=#FFFF99> Node.js没有根目录的概念，因为它根本没有任何的web容器。 </td><table>\n&emsp; 让node.js提供一个静态服务，是非常难的。\n&emsp; 也就是说，node.js中，如果看见一个网址是 `127.0.0.1:3000/fang` ，那么一定有一个文件夹，叫做fang，可能/fang的物理文件。\n&emsp; URL和真实物理文件，是没有关系的。URL是通过了Node的顶层路由设计，呈递某一个静态文件的。\n\n# 三、HTTP模块\n\n&emsp; Node.js中，将很多的功能划分为了一个个mudule，大陆的书翻译为模块；台湾的书翻译为模组。\n&emsp; 这是因为，有一些程序需要使用fs功能（文件读取功能），有一些不用，所以为了效率，需要使用什么东西就require来引用什么东西。\n\n``` \n//这个案例简单讲解http模块\n//引用模块\nvar http = require(\"http\");\n\n//创建一个服务器，回调函数表示接收到请求之后做的事情\nvar server = http.createServer(function(req,res){\n\t//req参数表示请求，res表示响应\n\tconsole.log(\"服务器接收到了请求\" + req.url);\n\tres.end();\n});\n//监听端口\nserver.listen(3000,\"127.0.0.1\");\n```\n\n![](http://img.blog.csdn.net/20171203142036283?)\n\n&emsp; 设置一个响应头：\n\n``` \nres.writeHead(200,{\"Content-Type\":\"text/plain;charset=UTF8\"});\n```\n\n![返回头部内容](http://img.blog.csdn.net/20171203142128175?)\n\n&emsp; req里面能够使用的东西：最关键的就是req.url属性，表示用户的请求URL地址。所有的路由设计，都是通过req.url来实现的。\n&emsp; 我们比较关心的不是拿到URL，而是识别这个URL。\n&emsp; <font color=#008000>识别URL，用到两个新模块，第一个就是url模块，第二个就是querystring模块</font>\n\n&emsp; 字符串查询，用querystring处理\n\n``` \nquerystring.parse('foo=bar&baz=qux&baz=quux&corge') // returns { foo: 'bar', baz: ['qux', 'quux'], corge: '' }\n// Suppose gbkDecodeURIComponent function already exists,\n// it can decode `gbk` encoding string\nquerystring.parse('w=%D6%D0%CE%C4&foo=bar', null, null, { decodeURIComponent: gbkDecodeURIComponent }) // returns { w: '中文', foo: 'bar' }\n```\n","source":"_posts/NodeJs学习笔记1.md","raw":"---\ntitle: NodeJs学习笔记1  \ndate: 2017-12-03 18:21:08  \ncategories: node  \ntags:\n---\n\n# 一、Node.js简介\n\n## 1.1 简介  \n\n&emsp; V8引擎本身就是用于Chrome浏览器的JS解释部分，但是RyanDahl把V8搬到了服务器上，用于做服务器的软件。  \n&emsp; Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。  \n&emsp; 与Node不同：  \n<table><td bgcolor=#FFFF00><font color=red>&emsp; Node.js不是一种独立的语言</font>，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的<font color=red>使用JavaScript进行编程</font>，运行在JavaScript引擎上（V8）。</td>\n</table>\n<table><td bgcolor=#FFFF00>&emsp; 与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），<font color=red>Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上</font>。Node.js的许多设计理念与经典架构(LAMP = Linux + Apache + MySQL + PHP)有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。</td></table>\n\n* **Node.js是花最小的硬件成本，追求更高的并发，更高的处理性能。**\n\n## 1.2 特点\n\n&emsp; 所谓的特点，就是Node.js是如何解决服务器高性能瓶颈问题的。\n<table><td bgcolor=#FF99CC>单线程</td><table>\n&emsp; 在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程。而每个线程需要耗费大约2MB内存。也就是说，理论上，一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。\n&emsp; Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。\n&emsp; 另外，带线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。\n&emsp; 坏处就是一个用户造成了线程的崩溃，整个服务都崩溃了，其他人也崩溃了。\n\n![多线程](http://img.blog.csdn.net/20171202214112906?) &emsp; &emsp; &emsp; ![单线程](http://img.blog.csdn.net/20171202214322932?)\n\n&emsp; 多线程、单线程的一个对比。\n&emsp; 也就是说，单线程也能造成宏观上的“并发”。\n<table><td bgcolor=#FF99CC>非阻塞I/O   non-blocking I/O </td><table>\n&emsp; 例如，当在访问数据库取得数据的时候，需要一段时间。在传统的单线程处理机制中，在执行了访问数据库代码之后，整个线程都将暂停下来，等待数据库返回结果，才能执行后面的代码。<font color=red>也就是说，I/O阻塞了代码的执行，极大地降低了程序的执行效率。</font>\n&emsp; 由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。\n&emsp; 当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。\n&emsp; 阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。<font color=red>而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%</font>。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。\n\n<table><td bgcolor=#FF99CC>&emsp; 事件驱动event-driven </td><table>\n&emsp; 在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件（比如，又有新用户连接了），然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。\n&emsp; Node.js底层是C++（V8也是C++写的）。<font color=red>底层代码中，近半数都用于事件队列、回调函数队列的构建</font>。用事件驱动来完成服务器的任务调度。用一个线程，担负起了处理非常多的任务的使命。\n\n![调度](http://img.blog.csdn.net/20171202214716848?)\n\n<table><td bgcolor=#CCFFFF>&emsp; <font color=red>单线程</font>，单线程的好处，减少了内存开销，操作系统的内存换页。\n&emsp; 如果某一个事情，进入了，但是被I/O阻塞了，所以这个线程就阻塞了。\n&emsp; <font color=red> 非阻塞I/O</font>，不会傻等I/O语句结束，而会执行后面的语句。\n&emsp; 非阻塞就能解决问题了么？比如执行着小红的业务，执行过程中，小刚的I/O回调完成了，此时怎么办？？\n&emsp; <font color=red>事件机制，事件环</font>，不管是新用户的请求，还是老用户的I/O完成，都将以事件方式加入事件环，等待调度。 </td><table>\n&emsp; 说是三个特点，实际上是一个特点，离开谁都不行，都玩儿不转了。\n&emsp; Node.js很像抠门的餐厅老板，只聘请1个服务员，服务很多人。结果，比很多服务员效率还高。\n&emsp; Node.js中所有的I/O都是异步的，回调函数，套回调函数。\n\n## 1.3 适合开发什么？\n\n&emsp; Node.js适合用来开发什么样的应用程序呢？\n&emsp; 善于I/O，不善于计算。因为Node.js最擅长的就是任务调度，如果你的业务有很多的CPU计算，实际上也相当于这个计算阻塞了这个单线程，就不适合Node开发。\n&emsp; <font color=red>当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与websocket配合，开发长连接的实时交互应用程序。</font>\n比如：\n\n 1. 用户表单手机\n 2.  考试系统\n 3. 聊天室\n 4. 图文直播\n 5. 提供JSON的API（为前台Angular使用）\n\n## 1.4 Node.js无法挑战老牌3P（php、jsp、asp）\n\n![对比图](http://img.blog.csdn.net/20171203141158354?)\n\n# 二、Node.js安装\n\n&emsp; Node.js和Java非常像，跨平台的。不管是Linux还是windows编程是完全一致的（有一些不一样，比如路径的表述）。Linux版本的Node.js环境和windows环境是不一样的，但是编程语言一样。很像Java虚拟机。\n&emsp; 安装版本6.9.4。\n&emsp; 装完之后，在环境变量中查看\n&emsp; \n\n![环境变量](http://img.blog.csdn.net/20171203141527438?)\n\n&emsp; 环境变量，就已经自动的填写进去了，就是我们node安装的目录。\n<table><td bgcolor=#FFFF99>&emsp; 什么叫做环境变量？就是在系统的任何目录下，都能运行c:\\program files\\nodejs里面的程序。 </td><table>\n&emsp; 在cmd中，输入node -v就能够查看nodejs的版本。我们现在的盘符，不在安装目录下，但是也能够运行，这就是因为有系统环境变量。系统的环境变量已经有了c:\\program files\\nodejs了，所以，这个文件夹中的node.exe就能够在任何盘符运行。\n&emsp; \n\n![安装后的node](http://img.blog.csdn.net/20171203141739359?)\n\n \n&emsp; 运行文件，就要用node命令来运行(进入node代码所在文件夹，使用node 相对地址)：\n&emsp; \n\n![挂起状态](http://img.blog.csdn.net/20171203141937348?)\n\n&emsp; Node.js是服务器的程序，写的js语句，都将运行在服务器上。返回给客户的，都是已经处理好的纯html。\n\n01_HelloWorld.js\n\n``` \n//require表示引包，引包就是引用自己的一个特殊功能\nvar http = require(\"http\");\n//创建服务器，参数是一个回调函数，表示如果有请求进来，要做什么\nvar server = http.createServer(function(req,res){\n\t//req表示请求，request;  res表示响应，response\n\t//设置HTTP头部，状态码是200，文件类型是html，字符集是utf8\n\tres.writeHead(200,{\"Content-type\":\"text/html;charset=UTF-8\"});\n\tres.end(\"哈哈哈哈，我买了五个iPhone\" + (1+2+3) + \"s\");\n});\n\n//运行服务器，监听3000端口（端口号可以任改）\nserver.listen(3000,\"127.0.0.1\");\n```\n\n&emsp; 如果想修改程序，必须中断当前运行的服务器，重新node一次，刷新，才行。\n&emsp; <font color=red>ctrl+c，就可以打断挂起的服务器程序</font>。此时按上箭头，能够快速调用最近的node命令。\n&emsp; 本地的一个js，无法直接拖入浏览器运行，但是node可以让任何一个js文件，都可以通过它来运行。也就是说，<font color=red>node就是一个js的执行环境</font>。\n&emsp; 要跑起来一个服务器，这个服务器的脚本，要以.js存储，是一个js文件。用node命令运行这个js文件即可。\n<table><td bgcolor=#FFFF99> Node.js没有根目录的概念，因为它根本没有任何的web容器。 </td><table>\n&emsp; 让node.js提供一个静态服务，是非常难的。\n&emsp; 也就是说，node.js中，如果看见一个网址是 `127.0.0.1:3000/fang` ，那么一定有一个文件夹，叫做fang，可能/fang的物理文件。\n&emsp; URL和真实物理文件，是没有关系的。URL是通过了Node的顶层路由设计，呈递某一个静态文件的。\n\n# 三、HTTP模块\n\n&emsp; Node.js中，将很多的功能划分为了一个个mudule，大陆的书翻译为模块；台湾的书翻译为模组。\n&emsp; 这是因为，有一些程序需要使用fs功能（文件读取功能），有一些不用，所以为了效率，需要使用什么东西就require来引用什么东西。\n\n``` \n//这个案例简单讲解http模块\n//引用模块\nvar http = require(\"http\");\n\n//创建一个服务器，回调函数表示接收到请求之后做的事情\nvar server = http.createServer(function(req,res){\n\t//req参数表示请求，res表示响应\n\tconsole.log(\"服务器接收到了请求\" + req.url);\n\tres.end();\n});\n//监听端口\nserver.listen(3000,\"127.0.0.1\");\n```\n\n![](http://img.blog.csdn.net/20171203142036283?)\n\n&emsp; 设置一个响应头：\n\n``` \nres.writeHead(200,{\"Content-Type\":\"text/plain;charset=UTF8\"});\n```\n\n![返回头部内容](http://img.blog.csdn.net/20171203142128175?)\n\n&emsp; req里面能够使用的东西：最关键的就是req.url属性，表示用户的请求URL地址。所有的路由设计，都是通过req.url来实现的。\n&emsp; 我们比较关心的不是拿到URL，而是识别这个URL。\n&emsp; <font color=#008000>识别URL，用到两个新模块，第一个就是url模块，第二个就是querystring模块</font>\n\n&emsp; 字符串查询，用querystring处理\n\n``` \nquerystring.parse('foo=bar&baz=qux&baz=quux&corge') // returns { foo: 'bar', baz: ['qux', 'quux'], corge: '' }\n// Suppose gbkDecodeURIComponent function already exists,\n// it can decode `gbk` encoding string\nquerystring.parse('w=%D6%D0%CE%C4&foo=bar', null, null, { decodeURIComponent: gbkDecodeURIComponent }) // returns { w: '中文', foo: 'bar' }\n```\n","slug":"NodeJs学习笔记1","published":1,"updated":"2020-06-03T07:23:24.912Z","_id":"ck8gp7rxw0009kb9h9dxh393w","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"一、Node-js简介\"><a href=\"#一、Node-js简介\" class=\"headerlink\" title=\"一、Node.js简介\"></a>一、Node.js简介</h1><h2 id=\"1-1-简介\"><a href=\"#1-1-简介\" class=\"headerlink\" title=\"1.1 简介\"></a>1.1 简介</h2><p>&emsp; V8引擎本身就是用于Chrome浏览器的JS解释部分，但是RyanDahl把V8搬到了服务器上，用于做服务器的软件。<br>&emsp; Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。<br>&emsp; 与Node不同：  </p>\n<table><td bgcolor=#FFFF00><font color=red>&emsp; Node.js不是一种独立的语言</font>，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的<font color=red>使用JavaScript进行编程</font>，运行在JavaScript引擎上（V8）。</td>\n</table>\n<table><td bgcolor=#FFFF00>&emsp; 与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），<font color=red>Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上</font>。Node.js的许多设计理念与经典架构(LAMP = Linux + Apache + MySQL + PHP)有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。</td></table>\n\n<ul>\n<li><strong>Node.js是花最小的硬件成本，追求更高的并发，更高的处理性能。</strong></li>\n</ul>\n<h2 id=\"1-2-特点\"><a href=\"#1-2-特点\" class=\"headerlink\" title=\"1.2 特点\"></a>1.2 特点</h2><p>&emsp; 所谓的特点，就是Node.js是如何解决服务器高性能瓶颈问题的。</p>\n<table><td bgcolor=#FF99CC>单线程</td><table>\n&emsp; 在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程。而每个线程需要耗费大约2MB内存。也就是说，理论上，一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。\n&emsp; Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。\n&emsp; 另外，带线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。\n&emsp; 坏处就是一个用户造成了线程的崩溃，整个服务都崩溃了，其他人也崩溃了。\n\n<p><img src=\"http://img.blog.csdn.net/20171202214112906?\" alt=\"多线程\"> &emsp; &emsp; &emsp; <img src=\"http://img.blog.csdn.net/20171202214322932?\" alt=\"单线程\"></p>\n<p>&emsp; 多线程、单线程的一个对比。<br>&emsp; 也就是说，单线程也能造成宏观上的“并发”。</p>\n<table><td bgcolor=#FF99CC>非阻塞I/O   non-blocking I/O </td><table>\n&emsp; 例如，当在访问数据库取得数据的时候，需要一段时间。在传统的单线程处理机制中，在执行了访问数据库代码之后，整个线程都将暂停下来，等待数据库返回结果，才能执行后面的代码。<font color=red>也就是说，I/O阻塞了代码的执行，极大地降低了程序的执行效率。</font>\n&emsp; 由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。\n&emsp; 当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。\n&emsp; 阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。<font color=red>而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%</font>。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。\n\n<table><td bgcolor=#FF99CC>&emsp; 事件驱动event-driven </td><table>\n&emsp; 在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件（比如，又有新用户连接了），然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。\n&emsp; Node.js底层是C++（V8也是C++写的）。<font color=red>底层代码中，近半数都用于事件队列、回调函数队列的构建</font>。用事件驱动来完成服务器的任务调度。用一个线程，担负起了处理非常多的任务的使命。\n\n<p><img src=\"http://img.blog.csdn.net/20171202214716848?\" alt=\"调度\"></p>\n<table><td bgcolor=#CCFFFF>&emsp; <font color=red>单线程</font>，单线程的好处，减少了内存开销，操作系统的内存换页。\n&emsp; 如果某一个事情，进入了，但是被I/O阻塞了，所以这个线程就阻塞了。\n&emsp; <font color=red> 非阻塞I/O</font>，不会傻等I/O语句结束，而会执行后面的语句。\n&emsp; 非阻塞就能解决问题了么？比如执行着小红的业务，执行过程中，小刚的I/O回调完成了，此时怎么办？？\n&emsp; <font color=red>事件机制，事件环</font>，不管是新用户的请求，还是老用户的I/O完成，都将以事件方式加入事件环，等待调度。 </td><table>\n&emsp; 说是三个特点，实际上是一个特点，离开谁都不行，都玩儿不转了。\n&emsp; Node.js很像抠门的餐厅老板，只聘请1个服务员，服务很多人。结果，比很多服务员效率还高。\n&emsp; Node.js中所有的I/O都是异步的，回调函数，套回调函数。\n\n<h2 id=\"1-3-适合开发什么？\"><a href=\"#1-3-适合开发什么？\" class=\"headerlink\" title=\"1.3 适合开发什么？\"></a>1.3 适合开发什么？</h2><p>&emsp; Node.js适合用来开发什么样的应用程序呢？<br>&emsp; 善于I/O，不善于计算。因为Node.js最擅长的就是任务调度，如果你的业务有很多的CPU计算，实际上也相当于这个计算阻塞了这个单线程，就不适合Node开发。<br>&emsp; <font color=red>当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与websocket配合，开发长连接的实时交互应用程序。</font><br>比如：</p>\n<ol>\n<li>用户表单手机</li>\n<li>考试系统</li>\n<li>聊天室</li>\n<li>图文直播</li>\n<li>提供JSON的API（为前台Angular使用）</li>\n</ol>\n<h2 id=\"1-4-Node-js无法挑战老牌3P（php、jsp、asp）\"><a href=\"#1-4-Node-js无法挑战老牌3P（php、jsp、asp）\" class=\"headerlink\" title=\"1.4 Node.js无法挑战老牌3P（php、jsp、asp）\"></a>1.4 Node.js无法挑战老牌3P（php、jsp、asp）</h2><p><img src=\"http://img.blog.csdn.net/20171203141158354?\" alt=\"对比图\"></p>\n<h1 id=\"二、Node-js安装\"><a href=\"#二、Node-js安装\" class=\"headerlink\" title=\"二、Node.js安装\"></a>二、Node.js安装</h1><p>&emsp; Node.js和Java非常像，跨平台的。不管是Linux还是windows编程是完全一致的（有一些不一样，比如路径的表述）。Linux版本的Node.js环境和windows环境是不一样的，但是编程语言一样。很像Java虚拟机。<br>&emsp; 安装版本6.9.4。<br>&emsp; 装完之后，在环境变量中查看<br>&emsp; </p>\n<p><img src=\"http://img.blog.csdn.net/20171203141527438?\" alt=\"环境变量\"></p>\n<p>&emsp; 环境变量，就已经自动的填写进去了，就是我们node安装的目录。</p>\n<table><td bgcolor=#FFFF99>&emsp; 什么叫做环境变量？就是在系统的任何目录下，都能运行c:\\program files\\nodejs里面的程序。 </td><table>\n&emsp; 在cmd中，输入node -v就能够查看nodejs的版本。我们现在的盘符，不在安装目录下，但是也能够运行，这就是因为有系统环境变量。系统的环境变量已经有了c:\\program files\\nodejs了，所以，这个文件夹中的node.exe就能够在任何盘符运行。\n&emsp; \n\n<p><img src=\"http://img.blog.csdn.net/20171203141739359?\" alt=\"安装后的node\"></p>\n<p>&emsp; 运行文件，就要用node命令来运行(进入node代码所在文件夹，使用node 相对地址)：<br>&emsp; </p>\n<p><img src=\"http://img.blog.csdn.net/20171203141937348?\" alt=\"挂起状态\"></p>\n<p>&emsp; Node.js是服务器的程序，写的js语句，都将运行在服务器上。返回给客户的，都是已经处理好的纯html。</p>\n<p>01_HelloWorld.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;require表示引包，引包就是引用自己的一个特殊功能</span><br><span class=\"line\">var http &#x3D; require(&quot;http&quot;);</span><br><span class=\"line\">&#x2F;&#x2F;创建服务器，参数是一个回调函数，表示如果有请求进来，要做什么</span><br><span class=\"line\">var server &#x3D; http.createServer(function(req,res)&#123;</span><br><span class=\"line\">\t&#x2F;&#x2F;req表示请求，request;  res表示响应，response</span><br><span class=\"line\">\t&#x2F;&#x2F;设置HTTP头部，状态码是200，文件类型是html，字符集是utf8</span><br><span class=\"line\">\tres.writeHead(200,&#123;&quot;Content-type&quot;:&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;&#125;);</span><br><span class=\"line\">\tres.end(&quot;哈哈哈哈，我买了五个iPhone&quot; + (1+2+3) + &quot;s&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;运行服务器，监听3000端口（端口号可以任改）</span><br><span class=\"line\">server.listen(3000,&quot;127.0.0.1&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>&emsp; 如果想修改程序，必须中断当前运行的服务器，重新node一次，刷新，才行。<br>&emsp; <font color=red>ctrl+c，就可以打断挂起的服务器程序</font>。此时按上箭头，能够快速调用最近的node命令。<br>&emsp; 本地的一个js，无法直接拖入浏览器运行，但是node可以让任何一个js文件，都可以通过它来运行。也就是说，<font color=red>node就是一个js的执行环境</font>。<br>&emsp; 要跑起来一个服务器，这个服务器的脚本，要以.js存储，是一个js文件。用node命令运行这个js文件即可。</p>\n<table><td bgcolor=#FFFF99> Node.js没有根目录的概念，因为它根本没有任何的web容器。 </td><table>\n&emsp; 让node.js提供一个静态服务，是非常难的。\n&emsp; 也就是说，node.js中，如果看见一个网址是 `127.0.0.1:3000/fang` ，那么一定有一个文件夹，叫做fang，可能/fang的物理文件。\n&emsp; URL和真实物理文件，是没有关系的。URL是通过了Node的顶层路由设计，呈递某一个静态文件的。\n\n<h1 id=\"三、HTTP模块\"><a href=\"#三、HTTP模块\" class=\"headerlink\" title=\"三、HTTP模块\"></a>三、HTTP模块</h1><p>&emsp; Node.js中，将很多的功能划分为了一个个mudule，大陆的书翻译为模块；台湾的书翻译为模组。<br>&emsp; 这是因为，有一些程序需要使用fs功能（文件读取功能），有一些不用，所以为了效率，需要使用什么东西就require来引用什么东西。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;这个案例简单讲解http模块</span><br><span class=\"line\">&#x2F;&#x2F;引用模块</span><br><span class=\"line\">var http &#x3D; require(&quot;http&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;创建一个服务器，回调函数表示接收到请求之后做的事情</span><br><span class=\"line\">var server &#x3D; http.createServer(function(req,res)&#123;</span><br><span class=\"line\">\t&#x2F;&#x2F;req参数表示请求，res表示响应</span><br><span class=\"line\">\tconsole.log(&quot;服务器接收到了请求&quot; + req.url);</span><br><span class=\"line\">\tres.end();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#x2F;&#x2F;监听端口</span><br><span class=\"line\">server.listen(3000,&quot;127.0.0.1&quot;);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"http://img.blog.csdn.net/20171203142036283?\" alt=\"\"></p>\n<p>&emsp; 设置一个响应头：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res.writeHead(200,&#123;&quot;Content-Type&quot;:&quot;text&#x2F;plain;charset&#x3D;UTF8&quot;&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"http://img.blog.csdn.net/20171203142128175?\" alt=\"返回头部内容\"></p>\n<p>&emsp; req里面能够使用的东西：最关键的就是req.url属性，表示用户的请求URL地址。所有的路由设计，都是通过req.url来实现的。<br>&emsp; 我们比较关心的不是拿到URL，而是识别这个URL。<br>&emsp; <font color=#008000>识别URL，用到两个新模块，第一个就是url模块，第二个就是querystring模块</font></p>\n<p>&emsp; 字符串查询，用querystring处理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">querystring.parse(&#39;foo&#x3D;bar&amp;baz&#x3D;qux&amp;baz&#x3D;quux&amp;corge&#39;) &#x2F;&#x2F; returns &#123; foo: &#39;bar&#39;, baz: [&#39;qux&#39;, &#39;quux&#39;], corge: &#39;&#39; &#125;</span><br><span class=\"line\">&#x2F;&#x2F; Suppose gbkDecodeURIComponent function already exists,</span><br><span class=\"line\">&#x2F;&#x2F; it can decode &#96;gbk&#96; encoding string</span><br><span class=\"line\">querystring.parse(&#39;w&#x3D;%D6%D0%CE%C4&amp;foo&#x3D;bar&#39;, null, null, &#123; decodeURIComponent: gbkDecodeURIComponent &#125;) &#x2F;&#x2F; returns &#123; w: &#39;中文&#39;, foo: &#39;bar&#39; &#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、Node-js简介\"><a href=\"#一、Node-js简介\" class=\"headerlink\" title=\"一、Node.js简介\"></a>一、Node.js简介</h1><h2 id=\"1-1-简介\"><a href=\"#1-1-简介\" class=\"headerlink\" title=\"1.1 简介\"></a>1.1 简介</h2><p>&emsp; V8引擎本身就是用于Chrome浏览器的JS解释部分，但是RyanDahl把V8搬到了服务器上，用于做服务器的软件。<br>&emsp; Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。<br>&emsp; 与Node不同：  </p>\n<table><td bgcolor=#FFFF00><font color=red>&emsp; Node.js不是一种独立的语言</font>，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的<font color=red>使用JavaScript进行编程</font>，运行在JavaScript引擎上（V8）。</td>\n</table>\n<table><td bgcolor=#FFFF00>&emsp; 与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），<font color=red>Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上</font>。Node.js的许多设计理念与经典架构(LAMP = Linux + Apache + MySQL + PHP)有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。</td></table>\n\n<ul>\n<li><strong>Node.js是花最小的硬件成本，追求更高的并发，更高的处理性能。</strong></li>\n</ul>\n<h2 id=\"1-2-特点\"><a href=\"#1-2-特点\" class=\"headerlink\" title=\"1.2 特点\"></a>1.2 特点</h2><p>&emsp; 所谓的特点，就是Node.js是如何解决服务器高性能瓶颈问题的。</p>\n<table><td bgcolor=#FF99CC>单线程</td><table>\n&emsp; 在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程。而每个线程需要耗费大约2MB内存。也就是说，理论上，一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。\n&emsp; Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。\n&emsp; 另外，带线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。\n&emsp; 坏处就是一个用户造成了线程的崩溃，整个服务都崩溃了，其他人也崩溃了。\n\n<p><img src=\"http://img.blog.csdn.net/20171202214112906?\" alt=\"多线程\"> &emsp; &emsp; &emsp; <img src=\"http://img.blog.csdn.net/20171202214322932?\" alt=\"单线程\"></p>\n<p>&emsp; 多线程、单线程的一个对比。<br>&emsp; 也就是说，单线程也能造成宏观上的“并发”。</p>\n<table><td bgcolor=#FF99CC>非阻塞I/O   non-blocking I/O </td><table>\n&emsp; 例如，当在访问数据库取得数据的时候，需要一段时间。在传统的单线程处理机制中，在执行了访问数据库代码之后，整个线程都将暂停下来，等待数据库返回结果，才能执行后面的代码。<font color=red>也就是说，I/O阻塞了代码的执行，极大地降低了程序的执行效率。</font>\n&emsp; 由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。\n&emsp; 当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。\n&emsp; 阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。<font color=red>而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%</font>。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。\n\n<table><td bgcolor=#FF99CC>&emsp; 事件驱动event-driven </td><table>\n&emsp; 在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件（比如，又有新用户连接了），然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。\n&emsp; Node.js底层是C++（V8也是C++写的）。<font color=red>底层代码中，近半数都用于事件队列、回调函数队列的构建</font>。用事件驱动来完成服务器的任务调度。用一个线程，担负起了处理非常多的任务的使命。\n\n<p><img src=\"http://img.blog.csdn.net/20171202214716848?\" alt=\"调度\"></p>\n<table><td bgcolor=#CCFFFF>&emsp; <font color=red>单线程</font>，单线程的好处，减少了内存开销，操作系统的内存换页。\n&emsp; 如果某一个事情，进入了，但是被I/O阻塞了，所以这个线程就阻塞了。\n&emsp; <font color=red> 非阻塞I/O</font>，不会傻等I/O语句结束，而会执行后面的语句。\n&emsp; 非阻塞就能解决问题了么？比如执行着小红的业务，执行过程中，小刚的I/O回调完成了，此时怎么办？？\n&emsp; <font color=red>事件机制，事件环</font>，不管是新用户的请求，还是老用户的I/O完成，都将以事件方式加入事件环，等待调度。 </td><table>\n&emsp; 说是三个特点，实际上是一个特点，离开谁都不行，都玩儿不转了。\n&emsp; Node.js很像抠门的餐厅老板，只聘请1个服务员，服务很多人。结果，比很多服务员效率还高。\n&emsp; Node.js中所有的I/O都是异步的，回调函数，套回调函数。\n\n<h2 id=\"1-3-适合开发什么？\"><a href=\"#1-3-适合开发什么？\" class=\"headerlink\" title=\"1.3 适合开发什么？\"></a>1.3 适合开发什么？</h2><p>&emsp; Node.js适合用来开发什么样的应用程序呢？<br>&emsp; 善于I/O，不善于计算。因为Node.js最擅长的就是任务调度，如果你的业务有很多的CPU计算，实际上也相当于这个计算阻塞了这个单线程，就不适合Node开发。<br>&emsp; <font color=red>当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与websocket配合，开发长连接的实时交互应用程序。</font><br>比如：</p>\n<ol>\n<li>用户表单手机</li>\n<li>考试系统</li>\n<li>聊天室</li>\n<li>图文直播</li>\n<li>提供JSON的API（为前台Angular使用）</li>\n</ol>\n<h2 id=\"1-4-Node-js无法挑战老牌3P（php、jsp、asp）\"><a href=\"#1-4-Node-js无法挑战老牌3P（php、jsp、asp）\" class=\"headerlink\" title=\"1.4 Node.js无法挑战老牌3P（php、jsp、asp）\"></a>1.4 Node.js无法挑战老牌3P（php、jsp、asp）</h2><p><img src=\"http://img.blog.csdn.net/20171203141158354?\" alt=\"对比图\"></p>\n<h1 id=\"二、Node-js安装\"><a href=\"#二、Node-js安装\" class=\"headerlink\" title=\"二、Node.js安装\"></a>二、Node.js安装</h1><p>&emsp; Node.js和Java非常像，跨平台的。不管是Linux还是windows编程是完全一致的（有一些不一样，比如路径的表述）。Linux版本的Node.js环境和windows环境是不一样的，但是编程语言一样。很像Java虚拟机。<br>&emsp; 安装版本6.9.4。<br>&emsp; 装完之后，在环境变量中查看<br>&emsp; </p>\n<p><img src=\"http://img.blog.csdn.net/20171203141527438?\" alt=\"环境变量\"></p>\n<p>&emsp; 环境变量，就已经自动的填写进去了，就是我们node安装的目录。</p>\n<table><td bgcolor=#FFFF99>&emsp; 什么叫做环境变量？就是在系统的任何目录下，都能运行c:\\program files\\nodejs里面的程序。 </td><table>\n&emsp; 在cmd中，输入node -v就能够查看nodejs的版本。我们现在的盘符，不在安装目录下，但是也能够运行，这就是因为有系统环境变量。系统的环境变量已经有了c:\\program files\\nodejs了，所以，这个文件夹中的node.exe就能够在任何盘符运行。\n&emsp; \n\n<p><img src=\"http://img.blog.csdn.net/20171203141739359?\" alt=\"安装后的node\"></p>\n<p>&emsp; 运行文件，就要用node命令来运行(进入node代码所在文件夹，使用node 相对地址)：<br>&emsp; </p>\n<p><img src=\"http://img.blog.csdn.net/20171203141937348?\" alt=\"挂起状态\"></p>\n<p>&emsp; Node.js是服务器的程序，写的js语句，都将运行在服务器上。返回给客户的，都是已经处理好的纯html。</p>\n<p>01_HelloWorld.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;require表示引包，引包就是引用自己的一个特殊功能</span><br><span class=\"line\">var http &#x3D; require(&quot;http&quot;);</span><br><span class=\"line\">&#x2F;&#x2F;创建服务器，参数是一个回调函数，表示如果有请求进来，要做什么</span><br><span class=\"line\">var server &#x3D; http.createServer(function(req,res)&#123;</span><br><span class=\"line\">\t&#x2F;&#x2F;req表示请求，request;  res表示响应，response</span><br><span class=\"line\">\t&#x2F;&#x2F;设置HTTP头部，状态码是200，文件类型是html，字符集是utf8</span><br><span class=\"line\">\tres.writeHead(200,&#123;&quot;Content-type&quot;:&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;&#125;);</span><br><span class=\"line\">\tres.end(&quot;哈哈哈哈，我买了五个iPhone&quot; + (1+2+3) + &quot;s&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;运行服务器，监听3000端口（端口号可以任改）</span><br><span class=\"line\">server.listen(3000,&quot;127.0.0.1&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>&emsp; 如果想修改程序，必须中断当前运行的服务器，重新node一次，刷新，才行。<br>&emsp; <font color=red>ctrl+c，就可以打断挂起的服务器程序</font>。此时按上箭头，能够快速调用最近的node命令。<br>&emsp; 本地的一个js，无法直接拖入浏览器运行，但是node可以让任何一个js文件，都可以通过它来运行。也就是说，<font color=red>node就是一个js的执行环境</font>。<br>&emsp; 要跑起来一个服务器，这个服务器的脚本，要以.js存储，是一个js文件。用node命令运行这个js文件即可。</p>\n<table><td bgcolor=#FFFF99> Node.js没有根目录的概念，因为它根本没有任何的web容器。 </td><table>\n&emsp; 让node.js提供一个静态服务，是非常难的。\n&emsp; 也就是说，node.js中，如果看见一个网址是 `127.0.0.1:3000/fang` ，那么一定有一个文件夹，叫做fang，可能/fang的物理文件。\n&emsp; URL和真实物理文件，是没有关系的。URL是通过了Node的顶层路由设计，呈递某一个静态文件的。\n\n<h1 id=\"三、HTTP模块\"><a href=\"#三、HTTP模块\" class=\"headerlink\" title=\"三、HTTP模块\"></a>三、HTTP模块</h1><p>&emsp; Node.js中，将很多的功能划分为了一个个mudule，大陆的书翻译为模块；台湾的书翻译为模组。<br>&emsp; 这是因为，有一些程序需要使用fs功能（文件读取功能），有一些不用，所以为了效率，需要使用什么东西就require来引用什么东西。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;这个案例简单讲解http模块</span><br><span class=\"line\">&#x2F;&#x2F;引用模块</span><br><span class=\"line\">var http &#x3D; require(&quot;http&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;创建一个服务器，回调函数表示接收到请求之后做的事情</span><br><span class=\"line\">var server &#x3D; http.createServer(function(req,res)&#123;</span><br><span class=\"line\">\t&#x2F;&#x2F;req参数表示请求，res表示响应</span><br><span class=\"line\">\tconsole.log(&quot;服务器接收到了请求&quot; + req.url);</span><br><span class=\"line\">\tres.end();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#x2F;&#x2F;监听端口</span><br><span class=\"line\">server.listen(3000,&quot;127.0.0.1&quot;);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"http://img.blog.csdn.net/20171203142036283?\" alt=\"\"></p>\n<p>&emsp; 设置一个响应头：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res.writeHead(200,&#123;&quot;Content-Type&quot;:&quot;text&#x2F;plain;charset&#x3D;UTF8&quot;&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"http://img.blog.csdn.net/20171203142128175?\" alt=\"返回头部内容\"></p>\n<p>&emsp; req里面能够使用的东西：最关键的就是req.url属性，表示用户的请求URL地址。所有的路由设计，都是通过req.url来实现的。<br>&emsp; 我们比较关心的不是拿到URL，而是识别这个URL。<br>&emsp; <font color=#008000>识别URL，用到两个新模块，第一个就是url模块，第二个就是querystring模块</font></p>\n<p>&emsp; 字符串查询，用querystring处理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">querystring.parse(&#39;foo&#x3D;bar&amp;baz&#x3D;qux&amp;baz&#x3D;quux&amp;corge&#39;) &#x2F;&#x2F; returns &#123; foo: &#39;bar&#39;, baz: [&#39;qux&#39;, &#39;quux&#39;], corge: &#39;&#39; &#125;</span><br><span class=\"line\">&#x2F;&#x2F; Suppose gbkDecodeURIComponent function already exists,</span><br><span class=\"line\">&#x2F;&#x2F; it can decode &#96;gbk&#96; encoding string</span><br><span class=\"line\">querystring.parse(&#39;w&#x3D;%D6%D0%CE%C4&amp;foo&#x3D;bar&#39;, null, null, &#123; decodeURIComponent: gbkDecodeURIComponent &#125;) &#x2F;&#x2F; returns &#123; w: &#39;中文&#39;, foo: &#39;bar&#39; &#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"webpack(一)","date":"2018-03-01T07:40:08.000Z","_content":"\n> 目录\n>\n> 1. webpack作用简介\n>\n> 2. webpack安装\n>\n> 3. webpack配置文件：入口与出口\n>\n> 4. webpack配置文件：热更新服务\n\n## 1.webpack作用简介\n\n1. 打包：把多个JS打包成一个文件，减少服务器压力和下载宽带 。当然，也可以压缩html/css/图片等资源。\n2. 转换：把扩展语言(ES6/ES7/less/sass)转换为普通的js/css，让浏览器顺利运行。\n3. 优化：优化css前缀、去除未使用的css和库，优化和提升前端页面的性能。\n\n\n## 2.webpack安装\n\n前提是安装好了`node/npm`，(默认大家配置好了`npm`的淘宝镜像`cnpm`)。安装之前，我们在文件根目录先使用`npm init`生成`package.json`文件。\n\n然后我们使用`cnpm`安装`webpack`，不推荐全局安装，==推荐局部安装==：\n\n    // 全局安装\n    cnpm install -g webpack\n    \n    // 局部安装\n    cnpm install webpack --sava-dev\n\n安装完毕后，使用`webpack -v`检测你的`webpack`版本。\n\n全局安装在文件根目录的终端直接使用`webpack`就进行打包，局部安装在文件根目录的`package.json`里配置一下:\n\n    \"scripts\": {\n        \"start\": \"webpack\"\n    }\n\n然后在文件根目录的终端使用`npm start`或者`npm run start`就可以打包你的文件了。虽然可以使用下面命令进行打包:\n\n    npm webpack {entry file} {destination for bundled file}\n    // {entry file}:入口文件的路径。\n    // {destination for bundled file}:填写打包后存放的路径。\n\n但是最好还是使用配置文件来进行项目打包。\n\n## 3.webpack配置文件：入口与出口\n\n关于配置文件，如果是中型或者大型项目最好采用模块化的配置文件【我们将在webpack(附)中提到】，这里我们在根目录创建一个 `webpack.config.js` 作为配置文件，一般配置文件中包含以下项:\n\n    module.exports={\n        \n        // 入口文件的配置项\n        entry:{},\n        \n        // 出口文件的配置项\n        output:{},\n        \n        // 模块, 比如解读打包js/CSS, 转换压缩图片\n        module:{},\n        \n        //插件\n        plugins:[],\n        \n        // 开发调试工具\n        devtool:'',\n        \n        //配置webpack开发服务\n        devServer:{}\n    }\n\n### 一个例子(后续也会用到此例)：\n我们先局部安装`webpack`，并且建好相应文件夹和文件(记得在`package.json`配置好相应 `npm` 运行命令)，目录如下：\n\n    - webpack\n        + dist // 文件输出目录\n        + node_modules // node包依赖\n        - src // 源码文件目录\n            entry.js // webpack的入口文件\n        package.json\n        webpack.config.js // webpack配置文件\n\nwebpack.config.js 内容如下：\n\n    // 头部引入path路径包\n    const path = require('path');\n    \n    module.exports={\n        \n        // 入口文件的配置项\n        entry:{\n            // 这里的entry可以随意命名，使用相对路径引入相应js\n            entry: './src/entry.js'\n            // 如果需要引入多个js\n            // entry: ['./src/entry.js', './src/myjs.js']\n        },\n        \n        // 出口文件的配置项\n        output:{\n            // 打包的路径输出位置，resolve(解析),这里指定一个本机绝对路径\n            // __dirname是指项目目录下，是node的一种语法，可以直接定位到本机的项目目录中\n            path: path.resolve(__dirname, 'dist'),\n            // 打包的文件输出名称\n            filename: 'output.js'\n        },\n        \n        // 模块, 比如解读打包js/CSS, 转换压缩图片\n        module:{},\n        \n        //插件\n        plugins:[],\n        \n        // 开发调试工具\n        devtool:'',\n        \n        //配置webpack开发服务\n        devServer:{}\n    }\n    \n我们在`entry.js`里随意写点js代码，然后在根目录使用终端执行 `npm run start`（`start`是在`package.json`自定义的启用`webpack`的命令，在前面我们也有提到过）。\n \n关于多js文件打包为多个相对应js文件，修改一下`entry`和`output`即可。\n\n    entry:{\n        entry: './src/entry.js', \n        entry2: './src/entry2.js'\n    },\n    \n    output:{\n        // 打包的路径输出位置\n        path: path.resolve(__dirname, 'dist'),\n        // 打包的文件输出名称——相对应js文件名称\n        filename: '[name].js'\n    },\n    \n## 4.webpack配置文件：热更新服务\n\n关于热更新服务，该功能的目的是使用`webpack`打包后，启动服务看打包后的文件的效果。下载：\n\n    cnpm install webpack-dev-server –save-dev\n    \n因为这里也是局部安装，所以我们也要在`package.json`里配置 `scripts`:\n\n    // --open是在启动服务后自动打开浏览器，也可以不需要，然后手动输入地址和端口\n    \"server\": \"webpack-dev-server --open\",\n\n然后我们主要在`webpack.config.js` 里的 `devServer` 里配置:\n\n    devServer:{\n        // 设置关联的基本运行路径，这里因为例子是dist，所以我们写的dist\n        contentBase:path.resolve(__dirname,'dist'),\n        // 服务器的IP地址，可以使用IP也可以使用localhost。可以使用ipconfig获取本机ipv4地址在这里使用。\n        host:'localhost',\n        // 服务端压缩是否开启，一般为开启\n        compress:true,\n        //配置服务端口号，这里使用1010\n        port:1010\n    }\n\n关于热更新：因为`webpack`存在`watch`监控机制，所以我们一旦修改源码并保存，浏览器便会自动为我们更新。 ==但是，webpack并不能根据我们的修改而自动打包！！== 如果需要更新后自动打包，可以使用`watch`：\n\n    // 启用观察\n    watch: true, // boolean\n\n    watchOptions: {\n        \n        // 检测修改的时间，以毫秒为单位\n        poll:1000,\n    \n        // 防止重复保存而发生重复编译错误。这里设置的500是半秒内重复保存，不进行打包操作\n        aggregateTimeout: 1000,\n    \n        // 不监听的目录(监听大量文件系统会导致大量的 CPU 或内存占用)\n        ignored:/node_modules/,\n    }\n    \n![分割线](https://thumbnail0.baidupcs.com/thumbnail/9c0f8419c448613afe5e9ce4e03c42dd?fid=1737706044-250528-418203039170764&time=1517058000&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Qkr71fUc1rIISl3r2mSINMehzCM%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=624108863495940664&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video)","source":"_posts/webpack3(一).md","raw":"---\ntitle: webpack(一)  \ndate: 2018-03-01 15:40:08  \ncategories: webpack  \ntags:\n---\n\n> 目录\n>\n> 1. webpack作用简介\n>\n> 2. webpack安装\n>\n> 3. webpack配置文件：入口与出口\n>\n> 4. webpack配置文件：热更新服务\n\n## 1.webpack作用简介\n\n1. 打包：把多个JS打包成一个文件，减少服务器压力和下载宽带 。当然，也可以压缩html/css/图片等资源。\n2. 转换：把扩展语言(ES6/ES7/less/sass)转换为普通的js/css，让浏览器顺利运行。\n3. 优化：优化css前缀、去除未使用的css和库，优化和提升前端页面的性能。\n\n\n## 2.webpack安装\n\n前提是安装好了`node/npm`，(默认大家配置好了`npm`的淘宝镜像`cnpm`)。安装之前，我们在文件根目录先使用`npm init`生成`package.json`文件。\n\n然后我们使用`cnpm`安装`webpack`，不推荐全局安装，==推荐局部安装==：\n\n    // 全局安装\n    cnpm install -g webpack\n    \n    // 局部安装\n    cnpm install webpack --sava-dev\n\n安装完毕后，使用`webpack -v`检测你的`webpack`版本。\n\n全局安装在文件根目录的终端直接使用`webpack`就进行打包，局部安装在文件根目录的`package.json`里配置一下:\n\n    \"scripts\": {\n        \"start\": \"webpack\"\n    }\n\n然后在文件根目录的终端使用`npm start`或者`npm run start`就可以打包你的文件了。虽然可以使用下面命令进行打包:\n\n    npm webpack {entry file} {destination for bundled file}\n    // {entry file}:入口文件的路径。\n    // {destination for bundled file}:填写打包后存放的路径。\n\n但是最好还是使用配置文件来进行项目打包。\n\n## 3.webpack配置文件：入口与出口\n\n关于配置文件，如果是中型或者大型项目最好采用模块化的配置文件【我们将在webpack(附)中提到】，这里我们在根目录创建一个 `webpack.config.js` 作为配置文件，一般配置文件中包含以下项:\n\n    module.exports={\n        \n        // 入口文件的配置项\n        entry:{},\n        \n        // 出口文件的配置项\n        output:{},\n        \n        // 模块, 比如解读打包js/CSS, 转换压缩图片\n        module:{},\n        \n        //插件\n        plugins:[],\n        \n        // 开发调试工具\n        devtool:'',\n        \n        //配置webpack开发服务\n        devServer:{}\n    }\n\n### 一个例子(后续也会用到此例)：\n我们先局部安装`webpack`，并且建好相应文件夹和文件(记得在`package.json`配置好相应 `npm` 运行命令)，目录如下：\n\n    - webpack\n        + dist // 文件输出目录\n        + node_modules // node包依赖\n        - src // 源码文件目录\n            entry.js // webpack的入口文件\n        package.json\n        webpack.config.js // webpack配置文件\n\nwebpack.config.js 内容如下：\n\n    // 头部引入path路径包\n    const path = require('path');\n    \n    module.exports={\n        \n        // 入口文件的配置项\n        entry:{\n            // 这里的entry可以随意命名，使用相对路径引入相应js\n            entry: './src/entry.js'\n            // 如果需要引入多个js\n            // entry: ['./src/entry.js', './src/myjs.js']\n        },\n        \n        // 出口文件的配置项\n        output:{\n            // 打包的路径输出位置，resolve(解析),这里指定一个本机绝对路径\n            // __dirname是指项目目录下，是node的一种语法，可以直接定位到本机的项目目录中\n            path: path.resolve(__dirname, 'dist'),\n            // 打包的文件输出名称\n            filename: 'output.js'\n        },\n        \n        // 模块, 比如解读打包js/CSS, 转换压缩图片\n        module:{},\n        \n        //插件\n        plugins:[],\n        \n        // 开发调试工具\n        devtool:'',\n        \n        //配置webpack开发服务\n        devServer:{}\n    }\n    \n我们在`entry.js`里随意写点js代码，然后在根目录使用终端执行 `npm run start`（`start`是在`package.json`自定义的启用`webpack`的命令，在前面我们也有提到过）。\n \n关于多js文件打包为多个相对应js文件，修改一下`entry`和`output`即可。\n\n    entry:{\n        entry: './src/entry.js', \n        entry2: './src/entry2.js'\n    },\n    \n    output:{\n        // 打包的路径输出位置\n        path: path.resolve(__dirname, 'dist'),\n        // 打包的文件输出名称——相对应js文件名称\n        filename: '[name].js'\n    },\n    \n## 4.webpack配置文件：热更新服务\n\n关于热更新服务，该功能的目的是使用`webpack`打包后，启动服务看打包后的文件的效果。下载：\n\n    cnpm install webpack-dev-server –save-dev\n    \n因为这里也是局部安装，所以我们也要在`package.json`里配置 `scripts`:\n\n    // --open是在启动服务后自动打开浏览器，也可以不需要，然后手动输入地址和端口\n    \"server\": \"webpack-dev-server --open\",\n\n然后我们主要在`webpack.config.js` 里的 `devServer` 里配置:\n\n    devServer:{\n        // 设置关联的基本运行路径，这里因为例子是dist，所以我们写的dist\n        contentBase:path.resolve(__dirname,'dist'),\n        // 服务器的IP地址，可以使用IP也可以使用localhost。可以使用ipconfig获取本机ipv4地址在这里使用。\n        host:'localhost',\n        // 服务端压缩是否开启，一般为开启\n        compress:true,\n        //配置服务端口号，这里使用1010\n        port:1010\n    }\n\n关于热更新：因为`webpack`存在`watch`监控机制，所以我们一旦修改源码并保存，浏览器便会自动为我们更新。 ==但是，webpack并不能根据我们的修改而自动打包！！== 如果需要更新后自动打包，可以使用`watch`：\n\n    // 启用观察\n    watch: true, // boolean\n\n    watchOptions: {\n        \n        // 检测修改的时间，以毫秒为单位\n        poll:1000,\n    \n        // 防止重复保存而发生重复编译错误。这里设置的500是半秒内重复保存，不进行打包操作\n        aggregateTimeout: 1000,\n    \n        // 不监听的目录(监听大量文件系统会导致大量的 CPU 或内存占用)\n        ignored:/node_modules/,\n    }\n    \n![分割线](https://thumbnail0.baidupcs.com/thumbnail/9c0f8419c448613afe5e9ce4e03c42dd?fid=1737706044-250528-418203039170764&time=1517058000&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Qkr71fUc1rIISl3r2mSINMehzCM%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=624108863495940664&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video)","slug":"webpack3(一)","published":1,"updated":"2020-04-01T02:15:52.392Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8gp7rxx000bkb9h6gpl08wf","content":"<blockquote>\n<p>目录</p>\n<ol>\n<li><p>webpack作用简介</p>\n</li>\n<li><p>webpack安装</p>\n</li>\n<li><p>webpack配置文件：入口与出口</p>\n</li>\n<li><p>webpack配置文件：热更新服务</p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"1-webpack作用简介\"><a href=\"#1-webpack作用简介\" class=\"headerlink\" title=\"1.webpack作用简介\"></a>1.webpack作用简介</h2><ol>\n<li>打包：把多个JS打包成一个文件，减少服务器压力和下载宽带 。当然，也可以压缩html/css/图片等资源。</li>\n<li>转换：把扩展语言(ES6/ES7/less/sass)转换为普通的js/css，让浏览器顺利运行。</li>\n<li>优化：优化css前缀、去除未使用的css和库，优化和提升前端页面的性能。</li>\n</ol>\n<h2 id=\"2-webpack安装\"><a href=\"#2-webpack安装\" class=\"headerlink\" title=\"2.webpack安装\"></a>2.webpack安装</h2><p>前提是安装好了<code>node/npm</code>，(默认大家配置好了<code>npm</code>的淘宝镜像<code>cnpm</code>)。安装之前，我们在文件根目录先使用<code>npm init</code>生成<code>package.json</code>文件。</p>\n<p>然后我们使用<code>cnpm</code>安装<code>webpack</code>，不推荐全局安装，==推荐局部安装==：</p>\n<pre><code>// 全局安装\ncnpm install -g webpack\n\n// 局部安装\ncnpm install webpack --sava-dev</code></pre><p>安装完毕后，使用<code>webpack -v</code>检测你的<code>webpack</code>版本。</p>\n<p>全局安装在文件根目录的终端直接使用<code>webpack</code>就进行打包，局部安装在文件根目录的<code>package.json</code>里配置一下:</p>\n<pre><code>&quot;scripts&quot;: {\n    &quot;start&quot;: &quot;webpack&quot;\n}</code></pre><p>然后在文件根目录的终端使用<code>npm start</code>或者<code>npm run start</code>就可以打包你的文件了。虽然可以使用下面命令进行打包:</p>\n<pre><code>npm webpack {entry file} {destination for bundled file}\n// {entry file}:入口文件的路径。\n// {destination for bundled file}:填写打包后存放的路径。</code></pre><p>但是最好还是使用配置文件来进行项目打包。</p>\n<h2 id=\"3-webpack配置文件：入口与出口\"><a href=\"#3-webpack配置文件：入口与出口\" class=\"headerlink\" title=\"3.webpack配置文件：入口与出口\"></a>3.webpack配置文件：入口与出口</h2><p>关于配置文件，如果是中型或者大型项目最好采用模块化的配置文件【我们将在webpack(附)中提到】，这里我们在根目录创建一个 <code>webpack.config.js</code> 作为配置文件，一般配置文件中包含以下项:</p>\n<pre><code>module.exports={\n\n    // 入口文件的配置项\n    entry:{},\n\n    // 出口文件的配置项\n    output:{},\n\n    // 模块, 比如解读打包js/CSS, 转换压缩图片\n    module:{},\n\n    //插件\n    plugins:[],\n\n    // 开发调试工具\n    devtool:&apos;&apos;,\n\n    //配置webpack开发服务\n    devServer:{}\n}</code></pre><h3 id=\"一个例子-后续也会用到此例-：\"><a href=\"#一个例子-后续也会用到此例-：\" class=\"headerlink\" title=\"一个例子(后续也会用到此例)：\"></a>一个例子(后续也会用到此例)：</h3><p>我们先局部安装<code>webpack</code>，并且建好相应文件夹和文件(记得在<code>package.json</code>配置好相应 <code>npm</code> 运行命令)，目录如下：</p>\n<pre><code>- webpack\n    + dist // 文件输出目录\n    + node_modules // node包依赖\n    - src // 源码文件目录\n        entry.js // webpack的入口文件\n    package.json\n    webpack.config.js // webpack配置文件</code></pre><p>webpack.config.js 内容如下：</p>\n<pre><code>// 头部引入path路径包\nconst path = require(&apos;path&apos;);\n\nmodule.exports={\n\n    // 入口文件的配置项\n    entry:{\n        // 这里的entry可以随意命名，使用相对路径引入相应js\n        entry: &apos;./src/entry.js&apos;\n        // 如果需要引入多个js\n        // entry: [&apos;./src/entry.js&apos;, &apos;./src/myjs.js&apos;]\n    },\n\n    // 出口文件的配置项\n    output:{\n        // 打包的路径输出位置，resolve(解析),这里指定一个本机绝对路径\n        // __dirname是指项目目录下，是node的一种语法，可以直接定位到本机的项目目录中\n        path: path.resolve(__dirname, &apos;dist&apos;),\n        // 打包的文件输出名称\n        filename: &apos;output.js&apos;\n    },\n\n    // 模块, 比如解读打包js/CSS, 转换压缩图片\n    module:{},\n\n    //插件\n    plugins:[],\n\n    // 开发调试工具\n    devtool:&apos;&apos;,\n\n    //配置webpack开发服务\n    devServer:{}\n}</code></pre><p>我们在<code>entry.js</code>里随意写点js代码，然后在根目录使用终端执行 <code>npm run start</code>（<code>start</code>是在<code>package.json</code>自定义的启用<code>webpack</code>的命令，在前面我们也有提到过）。</p>\n<p>关于多js文件打包为多个相对应js文件，修改一下<code>entry</code>和<code>output</code>即可。</p>\n<pre><code>entry:{\n    entry: &apos;./src/entry.js&apos;, \n    entry2: &apos;./src/entry2.js&apos;\n},\n\noutput:{\n    // 打包的路径输出位置\n    path: path.resolve(__dirname, &apos;dist&apos;),\n    // 打包的文件输出名称——相对应js文件名称\n    filename: &apos;[name].js&apos;\n},</code></pre><h2 id=\"4-webpack配置文件：热更新服务\"><a href=\"#4-webpack配置文件：热更新服务\" class=\"headerlink\" title=\"4.webpack配置文件：热更新服务\"></a>4.webpack配置文件：热更新服务</h2><p>关于热更新服务，该功能的目的是使用<code>webpack</code>打包后，启动服务看打包后的文件的效果。下载：</p>\n<pre><code>cnpm install webpack-dev-server –save-dev</code></pre><p>因为这里也是局部安装，所以我们也要在<code>package.json</code>里配置 <code>scripts</code>:</p>\n<pre><code>// --open是在启动服务后自动打开浏览器，也可以不需要，然后手动输入地址和端口\n&quot;server&quot;: &quot;webpack-dev-server --open&quot;,</code></pre><p>然后我们主要在<code>webpack.config.js</code> 里的 <code>devServer</code> 里配置:</p>\n<pre><code>devServer:{\n    // 设置关联的基本运行路径，这里因为例子是dist，所以我们写的dist\n    contentBase:path.resolve(__dirname,&apos;dist&apos;),\n    // 服务器的IP地址，可以使用IP也可以使用localhost。可以使用ipconfig获取本机ipv4地址在这里使用。\n    host:&apos;localhost&apos;,\n    // 服务端压缩是否开启，一般为开启\n    compress:true,\n    //配置服务端口号，这里使用1010\n    port:1010\n}</code></pre><p>关于热更新：因为<code>webpack</code>存在<code>watch</code>监控机制，所以我们一旦修改源码并保存，浏览器便会自动为我们更新。 ==但是，webpack并不能根据我们的修改而自动打包！！== 如果需要更新后自动打包，可以使用<code>watch</code>：</p>\n<pre><code>// 启用观察\nwatch: true, // boolean\n\nwatchOptions: {\n\n    // 检测修改的时间，以毫秒为单位\n    poll:1000,\n\n    // 防止重复保存而发生重复编译错误。这里设置的500是半秒内重复保存，不进行打包操作\n    aggregateTimeout: 1000,\n\n    // 不监听的目录(监听大量文件系统会导致大量的 CPU 或内存占用)\n    ignored:/node_modules/,\n}</code></pre><p><img src=\"https://thumbnail0.baidupcs.com/thumbnail/9c0f8419c448613afe5e9ce4e03c42dd?fid=1737706044-250528-418203039170764&time=1517058000&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Qkr71fUc1rIISl3r2mSINMehzCM%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=624108863495940664&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video\" alt=\"分割线\"></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>目录</p>\n<ol>\n<li><p>webpack作用简介</p>\n</li>\n<li><p>webpack安装</p>\n</li>\n<li><p>webpack配置文件：入口与出口</p>\n</li>\n<li><p>webpack配置文件：热更新服务</p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"1-webpack作用简介\"><a href=\"#1-webpack作用简介\" class=\"headerlink\" title=\"1.webpack作用简介\"></a>1.webpack作用简介</h2><ol>\n<li>打包：把多个JS打包成一个文件，减少服务器压力和下载宽带 。当然，也可以压缩html/css/图片等资源。</li>\n<li>转换：把扩展语言(ES6/ES7/less/sass)转换为普通的js/css，让浏览器顺利运行。</li>\n<li>优化：优化css前缀、去除未使用的css和库，优化和提升前端页面的性能。</li>\n</ol>\n<h2 id=\"2-webpack安装\"><a href=\"#2-webpack安装\" class=\"headerlink\" title=\"2.webpack安装\"></a>2.webpack安装</h2><p>前提是安装好了<code>node/npm</code>，(默认大家配置好了<code>npm</code>的淘宝镜像<code>cnpm</code>)。安装之前，我们在文件根目录先使用<code>npm init</code>生成<code>package.json</code>文件。</p>\n<p>然后我们使用<code>cnpm</code>安装<code>webpack</code>，不推荐全局安装，==推荐局部安装==：</p>\n<pre><code>// 全局安装\ncnpm install -g webpack\n\n// 局部安装\ncnpm install webpack --sava-dev</code></pre><p>安装完毕后，使用<code>webpack -v</code>检测你的<code>webpack</code>版本。</p>\n<p>全局安装在文件根目录的终端直接使用<code>webpack</code>就进行打包，局部安装在文件根目录的<code>package.json</code>里配置一下:</p>\n<pre><code>&quot;scripts&quot;: {\n    &quot;start&quot;: &quot;webpack&quot;\n}</code></pre><p>然后在文件根目录的终端使用<code>npm start</code>或者<code>npm run start</code>就可以打包你的文件了。虽然可以使用下面命令进行打包:</p>\n<pre><code>npm webpack {entry file} {destination for bundled file}\n// {entry file}:入口文件的路径。\n// {destination for bundled file}:填写打包后存放的路径。</code></pre><p>但是最好还是使用配置文件来进行项目打包。</p>\n<h2 id=\"3-webpack配置文件：入口与出口\"><a href=\"#3-webpack配置文件：入口与出口\" class=\"headerlink\" title=\"3.webpack配置文件：入口与出口\"></a>3.webpack配置文件：入口与出口</h2><p>关于配置文件，如果是中型或者大型项目最好采用模块化的配置文件【我们将在webpack(附)中提到】，这里我们在根目录创建一个 <code>webpack.config.js</code> 作为配置文件，一般配置文件中包含以下项:</p>\n<pre><code>module.exports={\n\n    // 入口文件的配置项\n    entry:{},\n\n    // 出口文件的配置项\n    output:{},\n\n    // 模块, 比如解读打包js/CSS, 转换压缩图片\n    module:{},\n\n    //插件\n    plugins:[],\n\n    // 开发调试工具\n    devtool:&apos;&apos;,\n\n    //配置webpack开发服务\n    devServer:{}\n}</code></pre><h3 id=\"一个例子-后续也会用到此例-：\"><a href=\"#一个例子-后续也会用到此例-：\" class=\"headerlink\" title=\"一个例子(后续也会用到此例)：\"></a>一个例子(后续也会用到此例)：</h3><p>我们先局部安装<code>webpack</code>，并且建好相应文件夹和文件(记得在<code>package.json</code>配置好相应 <code>npm</code> 运行命令)，目录如下：</p>\n<pre><code>- webpack\n    + dist // 文件输出目录\n    + node_modules // node包依赖\n    - src // 源码文件目录\n        entry.js // webpack的入口文件\n    package.json\n    webpack.config.js // webpack配置文件</code></pre><p>webpack.config.js 内容如下：</p>\n<pre><code>// 头部引入path路径包\nconst path = require(&apos;path&apos;);\n\nmodule.exports={\n\n    // 入口文件的配置项\n    entry:{\n        // 这里的entry可以随意命名，使用相对路径引入相应js\n        entry: &apos;./src/entry.js&apos;\n        // 如果需要引入多个js\n        // entry: [&apos;./src/entry.js&apos;, &apos;./src/myjs.js&apos;]\n    },\n\n    // 出口文件的配置项\n    output:{\n        // 打包的路径输出位置，resolve(解析),这里指定一个本机绝对路径\n        // __dirname是指项目目录下，是node的一种语法，可以直接定位到本机的项目目录中\n        path: path.resolve(__dirname, &apos;dist&apos;),\n        // 打包的文件输出名称\n        filename: &apos;output.js&apos;\n    },\n\n    // 模块, 比如解读打包js/CSS, 转换压缩图片\n    module:{},\n\n    //插件\n    plugins:[],\n\n    // 开发调试工具\n    devtool:&apos;&apos;,\n\n    //配置webpack开发服务\n    devServer:{}\n}</code></pre><p>我们在<code>entry.js</code>里随意写点js代码，然后在根目录使用终端执行 <code>npm run start</code>（<code>start</code>是在<code>package.json</code>自定义的启用<code>webpack</code>的命令，在前面我们也有提到过）。</p>\n<p>关于多js文件打包为多个相对应js文件，修改一下<code>entry</code>和<code>output</code>即可。</p>\n<pre><code>entry:{\n    entry: &apos;./src/entry.js&apos;, \n    entry2: &apos;./src/entry2.js&apos;\n},\n\noutput:{\n    // 打包的路径输出位置\n    path: path.resolve(__dirname, &apos;dist&apos;),\n    // 打包的文件输出名称——相对应js文件名称\n    filename: &apos;[name].js&apos;\n},</code></pre><h2 id=\"4-webpack配置文件：热更新服务\"><a href=\"#4-webpack配置文件：热更新服务\" class=\"headerlink\" title=\"4.webpack配置文件：热更新服务\"></a>4.webpack配置文件：热更新服务</h2><p>关于热更新服务，该功能的目的是使用<code>webpack</code>打包后，启动服务看打包后的文件的效果。下载：</p>\n<pre><code>cnpm install webpack-dev-server –save-dev</code></pre><p>因为这里也是局部安装，所以我们也要在<code>package.json</code>里配置 <code>scripts</code>:</p>\n<pre><code>// --open是在启动服务后自动打开浏览器，也可以不需要，然后手动输入地址和端口\n&quot;server&quot;: &quot;webpack-dev-server --open&quot;,</code></pre><p>然后我们主要在<code>webpack.config.js</code> 里的 <code>devServer</code> 里配置:</p>\n<pre><code>devServer:{\n    // 设置关联的基本运行路径，这里因为例子是dist，所以我们写的dist\n    contentBase:path.resolve(__dirname,&apos;dist&apos;),\n    // 服务器的IP地址，可以使用IP也可以使用localhost。可以使用ipconfig获取本机ipv4地址在这里使用。\n    host:&apos;localhost&apos;,\n    // 服务端压缩是否开启，一般为开启\n    compress:true,\n    //配置服务端口号，这里使用1010\n    port:1010\n}</code></pre><p>关于热更新：因为<code>webpack</code>存在<code>watch</code>监控机制，所以我们一旦修改源码并保存，浏览器便会自动为我们更新。 ==但是，webpack并不能根据我们的修改而自动打包！！== 如果需要更新后自动打包，可以使用<code>watch</code>：</p>\n<pre><code>// 启用观察\nwatch: true, // boolean\n\nwatchOptions: {\n\n    // 检测修改的时间，以毫秒为单位\n    poll:1000,\n\n    // 防止重复保存而发生重复编译错误。这里设置的500是半秒内重复保存，不进行打包操作\n    aggregateTimeout: 1000,\n\n    // 不监听的目录(监听大量文件系统会导致大量的 CPU 或内存占用)\n    ignored:/node_modules/,\n}</code></pre><p><img src=\"https://thumbnail0.baidupcs.com/thumbnail/9c0f8419c448613afe5e9ce4e03c42dd?fid=1737706044-250528-418203039170764&time=1517058000&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Qkr71fUc1rIISl3r2mSINMehzCM%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=624108863495940664&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video\" alt=\"分割线\"></p>\n"},{"title":"webpack(三)","date":"2018-07-12T02:45:08.000Z","_content":"\n> 目录\n> >\n> > 5.3 JS打包\n> >\n> > > 5.3.1 JS压缩/hash命名\n> > > \n> > > 5.3.2 babel转码ES6/ES7/JSX\n> >\n> > 5.4 图片打包与路径坑\n> >\n> > > 5.4.1 图片在CSS中\n> > >\n> > > 5.4.2 图片路径问题(包括分离后的CSS路径问题)\n> > >\n> > > 5.4.3 关于HTML中的图片\n> >\n> 6. 打包后的调试\n\n### 5.3 JS打包\n\n#### 5.3.1 JS压缩/hash命名\n`uglifyjs-webpack-plugin`压缩插件是`webpack`版本里默认已经集成，不需再次安装。在`webpack.config.js`中引入即可：\n\n    const uglify = require('uglifyjs-webpack-plugin');\n    \n引入后，在`plugins`配置一下就可以了：\n\n    plugins:[\n        // 压缩js\n        new uglify()\n    ],\n    \n然后使用`npm run start`打包即可。\n\n**js文件的hash命名**\n\n如果需要给js文件一个`hash`命名，可以在`output`中的`filename`进行配置:\n\n    filename: '[hash].js'\n    // filename: '[chunkhash].js'\n\n[关于hash和chunkhash的区别](http://blog.csdn.net/Scarlett_Dream/article/details/78856240)\n\n**清除重复不同hash名的js**\n\n使用`clean-webpack-plugin`，不过也可以通过直接删除`dist`文件夹，然后再次打包的方式来更新，此处请查阅官方文档。\n\n#### 5.3.2 babel转码ES6/ES7/JSX\n`Babel`是一个编译`JavaScript`的平台，它可以帮你使用`ES6/ES7/JSX`等js扩展语言。我们需要下载`babel-core`、`babel-loader`，扩展`es6/7/8`，下载`babel-preset-env`，扩展`JSX`(使用`react`的话)下载`babel-preset-react`。\n\n    \t\n    cnpm install --save-dev babel-core babel-loader babel-preset-react babel-preset-env\n    \n下载后在项目根目录新建`.babelrc`文件，并把配置写到文件里。\n\n    {\n        \"presets\":[\"react\",\"env\"]\n    }\n    \n在`webpack.config.js`中`module`进行配置：\n\n    {\n        test:/\\.(jsx|js)$/,\n        use:{\n            loader:'babel-loader',\n        },\n        exclude:/node_modules/\n    }\n\n**继续前面的例子**\n\n配置完毕，我们可以在`entry.js`添加代码：\n\n    let xushao = \"shuai\";\n    \n然后打包试试看，是不是成功了，哈哈。\n\n### 5.4 图片打包与路径坑\n\n#### 5.4.1 图片在CSS中\n**例如：**\n在`src`下创建`images`文件夹，放入图片`1.png`,编辑`HTML文件`和`css文件`：\n\n    html中添加：\n    <div id=\"tupian\"></div>\n    \n    css中添加：\n    #tupian{\n       background-image: url(../images/1.png);\n       width:466px;\n       height:453px;\n    }\n    \n我们需要安装`file-loader`和`url-loader`两个`loader`(其实`url-loader`内置了`file-loader`，但是为了保险起见和解决一些路径问题，所以建议同时单独安装`file-loader`):\n\n    cnpm install --save-dev file-loader url-loader\n    \n`file-loader`: 解决引用路径的问题,可以解析项目中的url引入（图片和ccss文件等）。\n\n`url-loader`: 将引入的图片编码。为了避免图片较大导致编码消耗性能，可以通过`limit`参数限制，小于`limit`的文件被转化为`DataURL`。\n\n**在`module`中配置url-loader：**\n\n    {\n        // test:/\\.(png|jpg|gif)/是匹配图片文件后缀名称\n        test:/\\.(png|jpg|gif)/ ,\n        // use：是指定使用的loader和loader的配置参数\n        use:[{\n                loader:'url-loader',\n                options:{\n                    // 是把小于8192的文件转换成成Base64的格式\n                    limit: 8192,\n                    // 打包输出到images文件夹下\n                    outputPath:'images/'\n                }\n            }]\n    }\n\n配置完毕后可以开始打包试试了。\n\n#### 5.4.2 图片路径问题(包括分离后的CSS路径问题)\n如果你的`css`分离后或者你的图片引入发现路径有问题，可以使用`publicPath`解决，它主要在`webpack`配置文件的`output`选项中处理静态文件路径。\n\n我们可以声明一个对象：\n\n    var website ={\n        // 这里的IP和端口，是你本机的ip或者是你devServer配置的IP和端口。\n        publicPath:\"http://113.250.159.94:1010\"\n    }\n    \n然后在output选项中引用这个对象的publicPath属性：\n\n    //出口文件的配置项\n    output:{\n        //输出的路径，用了Node语法\n        path:path.resolve(__dirname,'dist'),\n        //输出的文件名称\n        filename:'[name].js',\n        publicPath:website.publicPath\n    },\n    \n配置后进行打包，相对路径改为了绝对路径，速度稍微也变快了些。\n\n#### 5.4.3 关于HTML中的图片\n标签`<img>`引入的图片怎么办呢？你可以使用一个不是很火但是很实用的`loader`——`html-withimg-loader`:\n\n    cnpm install html-withimg-loader --save-dev\n\n再配置一下`module`:\n\n    {\n        test: /\\.(htm|html)$/i,\n        use:[ 'html-withimg-loader'] \n    }\n\n然后就可以开始打包了。\n\n## 6. 打包后的调试\n我们可以通过配置`devtool`进行开发调试，但要记得上线前修改这些调试。\n\n    devtool: 'eval-source-map',\n\n常用四种选项：\n\n`source-map`:在一个单独文件中产生一个完整且功能完全的文件。打包速度比较慢。\n \n`cheap-module-source-map`:在一个单独的文件中产生一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号）,会对调试造成不便。\n\n `eval-source-map`:使用`eval`打包源文件模块，在同一个文件中生产干净的完整版的`sourcemap`，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定要不开启这个选项。\n \n `cheap-module-eval-source-map`:这是在打包文件时最快的生产`source map`的方法，生产的 `Source map` 会和打包后的`JavaScript`文件同行显示，没有影射列，和`eval-source-map`选项具有相似的缺点。\n \n【建议：大型项目可以使用source-map；中小型项目使用eval-source-map就完全可以应对。这些调试只适用于开发阶段，上线前记得修改这些调试设置】\n\n![分割线](https://thumbnail0.baidupcs.com/thumbnail/9c0f8419c448613afe5e9ce4e03c42dd?fid=1737706044-250528-418203039170764&time=1517058000&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Qkr71fUc1rIISl3r2mSINMehzCM%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=624108863495940664&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video)","source":"_posts/webpack3(三).md","raw":"---\ntitle: webpack(三)  \ndate: 2018-07-12 10:45:08  \ncategories: webpack  \ntags:\n---\n\n> 目录\n> >\n> > 5.3 JS打包\n> >\n> > > 5.3.1 JS压缩/hash命名\n> > > \n> > > 5.3.2 babel转码ES6/ES7/JSX\n> >\n> > 5.4 图片打包与路径坑\n> >\n> > > 5.4.1 图片在CSS中\n> > >\n> > > 5.4.2 图片路径问题(包括分离后的CSS路径问题)\n> > >\n> > > 5.4.3 关于HTML中的图片\n> >\n> 6. 打包后的调试\n\n### 5.3 JS打包\n\n#### 5.3.1 JS压缩/hash命名\n`uglifyjs-webpack-plugin`压缩插件是`webpack`版本里默认已经集成，不需再次安装。在`webpack.config.js`中引入即可：\n\n    const uglify = require('uglifyjs-webpack-plugin');\n    \n引入后，在`plugins`配置一下就可以了：\n\n    plugins:[\n        // 压缩js\n        new uglify()\n    ],\n    \n然后使用`npm run start`打包即可。\n\n**js文件的hash命名**\n\n如果需要给js文件一个`hash`命名，可以在`output`中的`filename`进行配置:\n\n    filename: '[hash].js'\n    // filename: '[chunkhash].js'\n\n[关于hash和chunkhash的区别](http://blog.csdn.net/Scarlett_Dream/article/details/78856240)\n\n**清除重复不同hash名的js**\n\n使用`clean-webpack-plugin`，不过也可以通过直接删除`dist`文件夹，然后再次打包的方式来更新，此处请查阅官方文档。\n\n#### 5.3.2 babel转码ES6/ES7/JSX\n`Babel`是一个编译`JavaScript`的平台，它可以帮你使用`ES6/ES7/JSX`等js扩展语言。我们需要下载`babel-core`、`babel-loader`，扩展`es6/7/8`，下载`babel-preset-env`，扩展`JSX`(使用`react`的话)下载`babel-preset-react`。\n\n    \t\n    cnpm install --save-dev babel-core babel-loader babel-preset-react babel-preset-env\n    \n下载后在项目根目录新建`.babelrc`文件，并把配置写到文件里。\n\n    {\n        \"presets\":[\"react\",\"env\"]\n    }\n    \n在`webpack.config.js`中`module`进行配置：\n\n    {\n        test:/\\.(jsx|js)$/,\n        use:{\n            loader:'babel-loader',\n        },\n        exclude:/node_modules/\n    }\n\n**继续前面的例子**\n\n配置完毕，我们可以在`entry.js`添加代码：\n\n    let xushao = \"shuai\";\n    \n然后打包试试看，是不是成功了，哈哈。\n\n### 5.4 图片打包与路径坑\n\n#### 5.4.1 图片在CSS中\n**例如：**\n在`src`下创建`images`文件夹，放入图片`1.png`,编辑`HTML文件`和`css文件`：\n\n    html中添加：\n    <div id=\"tupian\"></div>\n    \n    css中添加：\n    #tupian{\n       background-image: url(../images/1.png);\n       width:466px;\n       height:453px;\n    }\n    \n我们需要安装`file-loader`和`url-loader`两个`loader`(其实`url-loader`内置了`file-loader`，但是为了保险起见和解决一些路径问题，所以建议同时单独安装`file-loader`):\n\n    cnpm install --save-dev file-loader url-loader\n    \n`file-loader`: 解决引用路径的问题,可以解析项目中的url引入（图片和ccss文件等）。\n\n`url-loader`: 将引入的图片编码。为了避免图片较大导致编码消耗性能，可以通过`limit`参数限制，小于`limit`的文件被转化为`DataURL`。\n\n**在`module`中配置url-loader：**\n\n    {\n        // test:/\\.(png|jpg|gif)/是匹配图片文件后缀名称\n        test:/\\.(png|jpg|gif)/ ,\n        // use：是指定使用的loader和loader的配置参数\n        use:[{\n                loader:'url-loader',\n                options:{\n                    // 是把小于8192的文件转换成成Base64的格式\n                    limit: 8192,\n                    // 打包输出到images文件夹下\n                    outputPath:'images/'\n                }\n            }]\n    }\n\n配置完毕后可以开始打包试试了。\n\n#### 5.4.2 图片路径问题(包括分离后的CSS路径问题)\n如果你的`css`分离后或者你的图片引入发现路径有问题，可以使用`publicPath`解决，它主要在`webpack`配置文件的`output`选项中处理静态文件路径。\n\n我们可以声明一个对象：\n\n    var website ={\n        // 这里的IP和端口，是你本机的ip或者是你devServer配置的IP和端口。\n        publicPath:\"http://113.250.159.94:1010\"\n    }\n    \n然后在output选项中引用这个对象的publicPath属性：\n\n    //出口文件的配置项\n    output:{\n        //输出的路径，用了Node语法\n        path:path.resolve(__dirname,'dist'),\n        //输出的文件名称\n        filename:'[name].js',\n        publicPath:website.publicPath\n    },\n    \n配置后进行打包，相对路径改为了绝对路径，速度稍微也变快了些。\n\n#### 5.4.3 关于HTML中的图片\n标签`<img>`引入的图片怎么办呢？你可以使用一个不是很火但是很实用的`loader`——`html-withimg-loader`:\n\n    cnpm install html-withimg-loader --save-dev\n\n再配置一下`module`:\n\n    {\n        test: /\\.(htm|html)$/i,\n        use:[ 'html-withimg-loader'] \n    }\n\n然后就可以开始打包了。\n\n## 6. 打包后的调试\n我们可以通过配置`devtool`进行开发调试，但要记得上线前修改这些调试。\n\n    devtool: 'eval-source-map',\n\n常用四种选项：\n\n`source-map`:在一个单独文件中产生一个完整且功能完全的文件。打包速度比较慢。\n \n`cheap-module-source-map`:在一个单独的文件中产生一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号）,会对调试造成不便。\n\n `eval-source-map`:使用`eval`打包源文件模块，在同一个文件中生产干净的完整版的`sourcemap`，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定要不开启这个选项。\n \n `cheap-module-eval-source-map`:这是在打包文件时最快的生产`source map`的方法，生产的 `Source map` 会和打包后的`JavaScript`文件同行显示，没有影射列，和`eval-source-map`选项具有相似的缺点。\n \n【建议：大型项目可以使用source-map；中小型项目使用eval-source-map就完全可以应对。这些调试只适用于开发阶段，上线前记得修改这些调试设置】\n\n![分割线](https://thumbnail0.baidupcs.com/thumbnail/9c0f8419c448613afe5e9ce4e03c42dd?fid=1737706044-250528-418203039170764&time=1517058000&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Qkr71fUc1rIISl3r2mSINMehzCM%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=624108863495940664&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video)","slug":"webpack3(三)","published":1,"updated":"2020-04-01T02:15:52.392Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8gp7rxy000dkb9he6vg91nh","content":"<blockquote>\n<p>目录</p>\n<blockquote>\n<p>5.3 JS打包</p>\n<blockquote>\n<p>5.3.1 JS压缩/hash命名</p>\n<p>5.3.2 babel转码ES6/ES7/JSX</p>\n</blockquote>\n<p>5.4 图片打包与路径坑</p>\n<blockquote>\n<p>5.4.1 图片在CSS中</p>\n<p>5.4.2 图片路径问题(包括分离后的CSS路径问题)</p>\n<p>5.4.3 关于HTML中的图片</p>\n</blockquote>\n</blockquote>\n<ol start=\"6\">\n<li>打包后的调试</li>\n</ol>\n</blockquote>\n<h3 id=\"5-3-JS打包\"><a href=\"#5-3-JS打包\" class=\"headerlink\" title=\"5.3 JS打包\"></a>5.3 JS打包</h3><h4 id=\"5-3-1-JS压缩-hash命名\"><a href=\"#5-3-1-JS压缩-hash命名\" class=\"headerlink\" title=\"5.3.1 JS压缩/hash命名\"></a>5.3.1 JS压缩/hash命名</h4><p><code>uglifyjs-webpack-plugin</code>压缩插件是<code>webpack</code>版本里默认已经集成，不需再次安装。在<code>webpack.config.js</code>中引入即可：</p>\n<pre><code>const uglify = require(&apos;uglifyjs-webpack-plugin&apos;);</code></pre><p>引入后，在<code>plugins</code>配置一下就可以了：</p>\n<pre><code>plugins:[\n    // 压缩js\n    new uglify()\n],</code></pre><p>然后使用<code>npm run start</code>打包即可。</p>\n<p><strong>js文件的hash命名</strong></p>\n<p>如果需要给js文件一个<code>hash</code>命名，可以在<code>output</code>中的<code>filename</code>进行配置:</p>\n<pre><code>filename: &apos;[hash].js&apos;\n// filename: &apos;[chunkhash].js&apos;</code></pre><p><a href=\"http://blog.csdn.net/Scarlett_Dream/article/details/78856240\" target=\"_blank\" rel=\"noopener\">关于hash和chunkhash的区别</a></p>\n<p><strong>清除重复不同hash名的js</strong></p>\n<p>使用<code>clean-webpack-plugin</code>，不过也可以通过直接删除<code>dist</code>文件夹，然后再次打包的方式来更新，此处请查阅官方文档。</p>\n<h4 id=\"5-3-2-babel转码ES6-ES7-JSX\"><a href=\"#5-3-2-babel转码ES6-ES7-JSX\" class=\"headerlink\" title=\"5.3.2 babel转码ES6/ES7/JSX\"></a>5.3.2 babel转码ES6/ES7/JSX</h4><p><code>Babel</code>是一个编译<code>JavaScript</code>的平台，它可以帮你使用<code>ES6/ES7/JSX</code>等js扩展语言。我们需要下载<code>babel-core</code>、<code>babel-loader</code>，扩展<code>es6/7/8</code>，下载<code>babel-preset-env</code>，扩展<code>JSX</code>(使用<code>react</code>的话)下载<code>babel-preset-react</code>。</p>\n<pre><code>cnpm install --save-dev babel-core babel-loader babel-preset-react babel-preset-env</code></pre><p>下载后在项目根目录新建<code>.babelrc</code>文件，并把配置写到文件里。</p>\n<pre><code>{\n    &quot;presets&quot;:[&quot;react&quot;,&quot;env&quot;]\n}</code></pre><p>在<code>webpack.config.js</code>中<code>module</code>进行配置：</p>\n<pre><code>{\n    test:/\\.(jsx|js)$/,\n    use:{\n        loader:&apos;babel-loader&apos;,\n    },\n    exclude:/node_modules/\n}</code></pre><p><strong>继续前面的例子</strong></p>\n<p>配置完毕，我们可以在<code>entry.js</code>添加代码：</p>\n<pre><code>let xushao = &quot;shuai&quot;;</code></pre><p>然后打包试试看，是不是成功了，哈哈。</p>\n<h3 id=\"5-4-图片打包与路径坑\"><a href=\"#5-4-图片打包与路径坑\" class=\"headerlink\" title=\"5.4 图片打包与路径坑\"></a>5.4 图片打包与路径坑</h3><h4 id=\"5-4-1-图片在CSS中\"><a href=\"#5-4-1-图片在CSS中\" class=\"headerlink\" title=\"5.4.1 图片在CSS中\"></a>5.4.1 图片在CSS中</h4><p><strong>例如：</strong><br>在<code>src</code>下创建<code>images</code>文件夹，放入图片<code>1.png</code>,编辑<code>HTML文件</code>和<code>css文件</code>：</p>\n<pre><code>html中添加：\n&lt;div id=&quot;tupian&quot;&gt;&lt;/div&gt;\n\ncss中添加：\n#tupian{\n   background-image: url(../images/1.png);\n   width:466px;\n   height:453px;\n}</code></pre><p>我们需要安装<code>file-loader</code>和<code>url-loader</code>两个<code>loader</code>(其实<code>url-loader</code>内置了<code>file-loader</code>，但是为了保险起见和解决一些路径问题，所以建议同时单独安装<code>file-loader</code>):</p>\n<pre><code>cnpm install --save-dev file-loader url-loader</code></pre><p><code>file-loader</code>: 解决引用路径的问题,可以解析项目中的url引入（图片和ccss文件等）。</p>\n<p><code>url-loader</code>: 将引入的图片编码。为了避免图片较大导致编码消耗性能，可以通过<code>limit</code>参数限制，小于<code>limit</code>的文件被转化为<code>DataURL</code>。</p>\n<p><strong>在<code>module</code>中配置url-loader：</strong></p>\n<pre><code>{\n    // test:/\\.(png|jpg|gif)/是匹配图片文件后缀名称\n    test:/\\.(png|jpg|gif)/ ,\n    // use：是指定使用的loader和loader的配置参数\n    use:[{\n            loader:&apos;url-loader&apos;,\n            options:{\n                // 是把小于8192的文件转换成成Base64的格式\n                limit: 8192,\n                // 打包输出到images文件夹下\n                outputPath:&apos;images/&apos;\n            }\n        }]\n}</code></pre><p>配置完毕后可以开始打包试试了。</p>\n<h4 id=\"5-4-2-图片路径问题-包括分离后的CSS路径问题\"><a href=\"#5-4-2-图片路径问题-包括分离后的CSS路径问题\" class=\"headerlink\" title=\"5.4.2 图片路径问题(包括分离后的CSS路径问题)\"></a>5.4.2 图片路径问题(包括分离后的CSS路径问题)</h4><p>如果你的<code>css</code>分离后或者你的图片引入发现路径有问题，可以使用<code>publicPath</code>解决，它主要在<code>webpack</code>配置文件的<code>output</code>选项中处理静态文件路径。</p>\n<p>我们可以声明一个对象：</p>\n<pre><code>var website ={\n    // 这里的IP和端口，是你本机的ip或者是你devServer配置的IP和端口。\n    publicPath:&quot;http://113.250.159.94:1010&quot;\n}</code></pre><p>然后在output选项中引用这个对象的publicPath属性：</p>\n<pre><code>//出口文件的配置项\noutput:{\n    //输出的路径，用了Node语法\n    path:path.resolve(__dirname,&apos;dist&apos;),\n    //输出的文件名称\n    filename:&apos;[name].js&apos;,\n    publicPath:website.publicPath\n},</code></pre><p>配置后进行打包，相对路径改为了绝对路径，速度稍微也变快了些。</p>\n<h4 id=\"5-4-3-关于HTML中的图片\"><a href=\"#5-4-3-关于HTML中的图片\" class=\"headerlink\" title=\"5.4.3 关于HTML中的图片\"></a>5.4.3 关于HTML中的图片</h4><p>标签<code>&lt;img&gt;</code>引入的图片怎么办呢？你可以使用一个不是很火但是很实用的<code>loader</code>——<code>html-withimg-loader</code>:</p>\n<pre><code>cnpm install html-withimg-loader --save-dev</code></pre><p>再配置一下<code>module</code>:</p>\n<pre><code>{\n    test: /\\.(htm|html)$/i,\n    use:[ &apos;html-withimg-loader&apos;] \n}</code></pre><p>然后就可以开始打包了。</p>\n<h2 id=\"6-打包后的调试\"><a href=\"#6-打包后的调试\" class=\"headerlink\" title=\"6. 打包后的调试\"></a>6. 打包后的调试</h2><p>我们可以通过配置<code>devtool</code>进行开发调试，但要记得上线前修改这些调试。</p>\n<pre><code>devtool: &apos;eval-source-map&apos;,</code></pre><p>常用四种选项：</p>\n<p><code>source-map</code>:在一个单独文件中产生一个完整且功能完全的文件。打包速度比较慢。</p>\n<p><code>cheap-module-source-map</code>:在一个单独的文件中产生一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号）,会对调试造成不便。</p>\n<p> <code>eval-source-map</code>:使用<code>eval</code>打包源文件模块，在同一个文件中生产干净的完整版的<code>sourcemap</code>，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定要不开启这个选项。</p>\n<p> <code>cheap-module-eval-source-map</code>:这是在打包文件时最快的生产<code>source map</code>的方法，生产的 <code>Source map</code> 会和打包后的<code>JavaScript</code>文件同行显示，没有影射列，和<code>eval-source-map</code>选项具有相似的缺点。</p>\n<p>【建议：大型项目可以使用source-map；中小型项目使用eval-source-map就完全可以应对。这些调试只适用于开发阶段，上线前记得修改这些调试设置】</p>\n<p><img src=\"https://thumbnail0.baidupcs.com/thumbnail/9c0f8419c448613afe5e9ce4e03c42dd?fid=1737706044-250528-418203039170764&time=1517058000&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Qkr71fUc1rIISl3r2mSINMehzCM%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=624108863495940664&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video\" alt=\"分割线\"></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>目录</p>\n<blockquote>\n<p>5.3 JS打包</p>\n<blockquote>\n<p>5.3.1 JS压缩/hash命名</p>\n<p>5.3.2 babel转码ES6/ES7/JSX</p>\n</blockquote>\n<p>5.4 图片打包与路径坑</p>\n<blockquote>\n<p>5.4.1 图片在CSS中</p>\n<p>5.4.2 图片路径问题(包括分离后的CSS路径问题)</p>\n<p>5.4.3 关于HTML中的图片</p>\n</blockquote>\n</blockquote>\n<ol start=\"6\">\n<li>打包后的调试</li>\n</ol>\n</blockquote>\n<h3 id=\"5-3-JS打包\"><a href=\"#5-3-JS打包\" class=\"headerlink\" title=\"5.3 JS打包\"></a>5.3 JS打包</h3><h4 id=\"5-3-1-JS压缩-hash命名\"><a href=\"#5-3-1-JS压缩-hash命名\" class=\"headerlink\" title=\"5.3.1 JS压缩/hash命名\"></a>5.3.1 JS压缩/hash命名</h4><p><code>uglifyjs-webpack-plugin</code>压缩插件是<code>webpack</code>版本里默认已经集成，不需再次安装。在<code>webpack.config.js</code>中引入即可：</p>\n<pre><code>const uglify = require(&apos;uglifyjs-webpack-plugin&apos;);</code></pre><p>引入后，在<code>plugins</code>配置一下就可以了：</p>\n<pre><code>plugins:[\n    // 压缩js\n    new uglify()\n],</code></pre><p>然后使用<code>npm run start</code>打包即可。</p>\n<p><strong>js文件的hash命名</strong></p>\n<p>如果需要给js文件一个<code>hash</code>命名，可以在<code>output</code>中的<code>filename</code>进行配置:</p>\n<pre><code>filename: &apos;[hash].js&apos;\n// filename: &apos;[chunkhash].js&apos;</code></pre><p><a href=\"http://blog.csdn.net/Scarlett_Dream/article/details/78856240\" target=\"_blank\" rel=\"noopener\">关于hash和chunkhash的区别</a></p>\n<p><strong>清除重复不同hash名的js</strong></p>\n<p>使用<code>clean-webpack-plugin</code>，不过也可以通过直接删除<code>dist</code>文件夹，然后再次打包的方式来更新，此处请查阅官方文档。</p>\n<h4 id=\"5-3-2-babel转码ES6-ES7-JSX\"><a href=\"#5-3-2-babel转码ES6-ES7-JSX\" class=\"headerlink\" title=\"5.3.2 babel转码ES6/ES7/JSX\"></a>5.3.2 babel转码ES6/ES7/JSX</h4><p><code>Babel</code>是一个编译<code>JavaScript</code>的平台，它可以帮你使用<code>ES6/ES7/JSX</code>等js扩展语言。我们需要下载<code>babel-core</code>、<code>babel-loader</code>，扩展<code>es6/7/8</code>，下载<code>babel-preset-env</code>，扩展<code>JSX</code>(使用<code>react</code>的话)下载<code>babel-preset-react</code>。</p>\n<pre><code>cnpm install --save-dev babel-core babel-loader babel-preset-react babel-preset-env</code></pre><p>下载后在项目根目录新建<code>.babelrc</code>文件，并把配置写到文件里。</p>\n<pre><code>{\n    &quot;presets&quot;:[&quot;react&quot;,&quot;env&quot;]\n}</code></pre><p>在<code>webpack.config.js</code>中<code>module</code>进行配置：</p>\n<pre><code>{\n    test:/\\.(jsx|js)$/,\n    use:{\n        loader:&apos;babel-loader&apos;,\n    },\n    exclude:/node_modules/\n}</code></pre><p><strong>继续前面的例子</strong></p>\n<p>配置完毕，我们可以在<code>entry.js</code>添加代码：</p>\n<pre><code>let xushao = &quot;shuai&quot;;</code></pre><p>然后打包试试看，是不是成功了，哈哈。</p>\n<h3 id=\"5-4-图片打包与路径坑\"><a href=\"#5-4-图片打包与路径坑\" class=\"headerlink\" title=\"5.4 图片打包与路径坑\"></a>5.4 图片打包与路径坑</h3><h4 id=\"5-4-1-图片在CSS中\"><a href=\"#5-4-1-图片在CSS中\" class=\"headerlink\" title=\"5.4.1 图片在CSS中\"></a>5.4.1 图片在CSS中</h4><p><strong>例如：</strong><br>在<code>src</code>下创建<code>images</code>文件夹，放入图片<code>1.png</code>,编辑<code>HTML文件</code>和<code>css文件</code>：</p>\n<pre><code>html中添加：\n&lt;div id=&quot;tupian&quot;&gt;&lt;/div&gt;\n\ncss中添加：\n#tupian{\n   background-image: url(../images/1.png);\n   width:466px;\n   height:453px;\n}</code></pre><p>我们需要安装<code>file-loader</code>和<code>url-loader</code>两个<code>loader</code>(其实<code>url-loader</code>内置了<code>file-loader</code>，但是为了保险起见和解决一些路径问题，所以建议同时单独安装<code>file-loader</code>):</p>\n<pre><code>cnpm install --save-dev file-loader url-loader</code></pre><p><code>file-loader</code>: 解决引用路径的问题,可以解析项目中的url引入（图片和ccss文件等）。</p>\n<p><code>url-loader</code>: 将引入的图片编码。为了避免图片较大导致编码消耗性能，可以通过<code>limit</code>参数限制，小于<code>limit</code>的文件被转化为<code>DataURL</code>。</p>\n<p><strong>在<code>module</code>中配置url-loader：</strong></p>\n<pre><code>{\n    // test:/\\.(png|jpg|gif)/是匹配图片文件后缀名称\n    test:/\\.(png|jpg|gif)/ ,\n    // use：是指定使用的loader和loader的配置参数\n    use:[{\n            loader:&apos;url-loader&apos;,\n            options:{\n                // 是把小于8192的文件转换成成Base64的格式\n                limit: 8192,\n                // 打包输出到images文件夹下\n                outputPath:&apos;images/&apos;\n            }\n        }]\n}</code></pre><p>配置完毕后可以开始打包试试了。</p>\n<h4 id=\"5-4-2-图片路径问题-包括分离后的CSS路径问题\"><a href=\"#5-4-2-图片路径问题-包括分离后的CSS路径问题\" class=\"headerlink\" title=\"5.4.2 图片路径问题(包括分离后的CSS路径问题)\"></a>5.4.2 图片路径问题(包括分离后的CSS路径问题)</h4><p>如果你的<code>css</code>分离后或者你的图片引入发现路径有问题，可以使用<code>publicPath</code>解决，它主要在<code>webpack</code>配置文件的<code>output</code>选项中处理静态文件路径。</p>\n<p>我们可以声明一个对象：</p>\n<pre><code>var website ={\n    // 这里的IP和端口，是你本机的ip或者是你devServer配置的IP和端口。\n    publicPath:&quot;http://113.250.159.94:1010&quot;\n}</code></pre><p>然后在output选项中引用这个对象的publicPath属性：</p>\n<pre><code>//出口文件的配置项\noutput:{\n    //输出的路径，用了Node语法\n    path:path.resolve(__dirname,&apos;dist&apos;),\n    //输出的文件名称\n    filename:&apos;[name].js&apos;,\n    publicPath:website.publicPath\n},</code></pre><p>配置后进行打包，相对路径改为了绝对路径，速度稍微也变快了些。</p>\n<h4 id=\"5-4-3-关于HTML中的图片\"><a href=\"#5-4-3-关于HTML中的图片\" class=\"headerlink\" title=\"5.4.3 关于HTML中的图片\"></a>5.4.3 关于HTML中的图片</h4><p>标签<code>&lt;img&gt;</code>引入的图片怎么办呢？你可以使用一个不是很火但是很实用的<code>loader</code>——<code>html-withimg-loader</code>:</p>\n<pre><code>cnpm install html-withimg-loader --save-dev</code></pre><p>再配置一下<code>module</code>:</p>\n<pre><code>{\n    test: /\\.(htm|html)$/i,\n    use:[ &apos;html-withimg-loader&apos;] \n}</code></pre><p>然后就可以开始打包了。</p>\n<h2 id=\"6-打包后的调试\"><a href=\"#6-打包后的调试\" class=\"headerlink\" title=\"6. 打包后的调试\"></a>6. 打包后的调试</h2><p>我们可以通过配置<code>devtool</code>进行开发调试，但要记得上线前修改这些调试。</p>\n<pre><code>devtool: &apos;eval-source-map&apos;,</code></pre><p>常用四种选项：</p>\n<p><code>source-map</code>:在一个单独文件中产生一个完整且功能完全的文件。打包速度比较慢。</p>\n<p><code>cheap-module-source-map</code>:在一个单独的文件中产生一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号）,会对调试造成不便。</p>\n<p> <code>eval-source-map</code>:使用<code>eval</code>打包源文件模块，在同一个文件中生产干净的完整版的<code>sourcemap</code>，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定要不开启这个选项。</p>\n<p> <code>cheap-module-eval-source-map</code>:这是在打包文件时最快的生产<code>source map</code>的方法，生产的 <code>Source map</code> 会和打包后的<code>JavaScript</code>文件同行显示，没有影射列，和<code>eval-source-map</code>选项具有相似的缺点。</p>\n<p>【建议：大型项目可以使用source-map；中小型项目使用eval-source-map就完全可以应对。这些调试只适用于开发阶段，上线前记得修改这些调试设置】</p>\n<p><img src=\"https://thumbnail0.baidupcs.com/thumbnail/9c0f8419c448613afe5e9ce4e03c42dd?fid=1737706044-250528-418203039170764&time=1517058000&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Qkr71fUc1rIISl3r2mSINMehzCM%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=624108863495940664&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video\" alt=\"分割线\"></p>\n"},{"title":"webpack(二)","date":"2018-04-01T10:43:08.000Z","_content":"\n> 目录\n>\n> 5. 模块与插件配置\n>\n> > 5.1 发布HTML\n> >\n> > 5.2  CSS打包\n> >\n> > > 5.2.1  分离CSS\n> > >\n> > > 5.2.2 压缩(丑化)css代码\n> > >\n> > > 5.2.3 自动处理CSS3属性前缀\n> > >\n> > > 5.2.4 消除未使用的CSS\n> > >\n> > > 5.2.5 less打包\n\n## 5. 模块与插件配置\n什么是`Loaders`? `loader` 用于对模块的源代码进行转换。是`webpack`最重要的功能，它有如下配置项：\n\n    test: 用于匹配处理文件的扩展名的正则表达式，必须配置\n    \n    use: loader名称(就是你要使用的模块的名称)，必须配置\n    \n    include/exclude: 手动添加的'必须处理的文件(文件夹)/屏蔽不需要处理的文件(文件夹)'，可选配置\n    \n    query: 为loaders提供额外的设置选项（可选）\n\n### 5.1 发布HTML\n我们在src下创建一个`index.html`文件：\n\n    - webpack\n        + dist // 文件输出目录\n        + node_modules // node包依赖\n        - src // 源码文件目录\n            entry.js // webpack的入口文件\n            index.html \n        package.json\n        webpack.config.js // webpack配置文件\n\n`index.html`:\n\n    <!doctype html>\n    <html lang=\"en\">\n    <head>\n    \t<meta charset=\"UTF-8\">\n    \t<!-- 手机页面中加入这句话，可以让页面适应设备的宽度。initial-scale - 初始的缩放比例 -->\n    \t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    \t<!-- Edge 模式通知 Windows Internet Explorer 以最高级别的可用模式显示内容 -->\n    \t<meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\">\n    \t<title>XQF webpack test</title>\n    </head>\n    <body>\n    \t<div id=\"gogo\"></div>\n    \t<div id=\"title\"></div>\n    \t<p>我是小段落123</p>\n    </body>\n    </html>\n    \n▲ 这份`index.html`文件没有js引入，`webpack`会为我们自动引入`js`。它还能够通过入口js文件帮我们自动引入`css`文件。\n\n我们先安装`html-webpack-plugin`，它简化了HTML文件的创建，以便为你的webpack包提供服务：\n\n    cnpm install --save-dev html-webpack-plugin\n\n然后在`webpack.config.js`中引入插件：\n\n    // 头部require\n    const htmlPlugin = require('html-webpack-plugin');\n    \n    // 在plugins中插入\n    new htmlPlugin({\n        // minify：是对html文件进行压缩，removeAttrubuteQuotes是却掉属性的双引号。\n        minify:{\n            removeAttributeQuotes:true\n        },\n        // hash：为了开发中js有缓存效果，所以加入hash，这样可以有效避免缓存JS。\n        hash:true,\n        // template：是要打包的html模版路径和文件名称。\n        template:'./src/index.html'\n    })\n\n### 5.2 CSS打包\n在`src`创建文件夹`css`，在`css`里创建`index.css`:\n\n    - src\n        - css\n            index.css\n\n`index.css`:\n\n    body {\n        background-color: #D5B740;\n        color: black;\n    }\n    #gogo {\n    \twidth: 466px;\n    \theight: 453px;\n    \ttransform: rotate(45deg);\n    \tbox-shadow: 1px 1px 0 rgba(0,0,0,.25);\n    }\n    #meiyong {\n    \twidth: 100%;\n    }\n    #meiyong2 {\n    \twidth: 50%;\n    }\n\ncss打包需要`style-loader`、`css-loader`两个`loader`。 ==一般这两个`loader`结合使用，顺序是`style-loader`在前== ：\n\n    // 使用npm下载两个`loader`:\n    cnpm install --save-dev style-loader css-loader\n\n`style-loader`: 让js解析css。\n\n`css-loader`: `css-loader` 解释(`interpret`) `@import` 和 `url()` ，会 `import/require()` 后再解析`(resolve)`它们。\n\n在入口文件`entry.js`里引入`css`：\n\n    import css from './css/index.css';\n\n在`webpack.config.js`的配置:\n\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,\n                use: [ 'style-loader', 'css-loader' ]\n                // use可以换作loader\n                // loader: [ 'style-loader', 'css-loader' ]\n            }\n        ]\n    },\n\n执行`npm start`打包一下，我们发现打包成功了。我们可以执行`npm run server`在服务端查看一下。\n\n#### 5.2.1 分离CSS\n    \n但是我们发现`css`是打包在`js`里的，因为`webpack`官方认为CSS就应该打包到`JavasScript`当中以减少`http`的请求数，但现实需求有时候需要分离`css`。那么我们需要一个插件`extract-text-webpack-plugin`：\n\n    cnpm install --save-dev extract-text-webpack-plugin\n    \n安装完成后在`webpack.config.js`中引用\n\n    // 顶部require引入\n    const extractTextPlugin = require(\"extract-text-webpack-plugin\");\n    \n    // 在module中进行配置\n    {\n        test: /\\.css$/,\n        use: extractTextPlugin.extract({\n\t        fallback: \"style-loader\",\n\t\t\tuse: 'css-loader'\n\t\t})\t\t\t\t\n    },\n    \n    // 在plugins中进行配置\n    plugins:[\n        new extractTextPlugin(\"./css/index.css\")\n    ],\n    \n#### 5.2.2 压缩(丑化)css代码\n\n设置 `minimize:true` ,就可以压缩`css`了。\n\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,\n                use: extractTextPlugin.extract({\n                    fallback: \"style-loader\",\n                    use: [\n                        { loader: 'css-loader', options: { minimize: true } }\n                    ]\n                })\n            }\n        ]\n    },\n\n#### 5.2.3 自动处理CSS3属性前缀\n\n下载 `postcss-loader` 和`autoprefixer`（自动添加前缀的插件）。\n\n    cnpm install --save-dev postcss-loader autoprefixer\n\n在`src`下建立`postcss.config.js`:\n\n    - webpack\n        + dist // 文件输出目录\n        + node_modules // node包依赖\n        - src // 源码文件目录\n            - css\n                index.css\n            entry.js // webpack的入口文件\n            index.html \n        package.json\n        postcss.config.js // postcss配置文件\n        webpack.config.js // webpack配置文件\n\n`postcss.config.js`:\n\n    module.exports = {\n        plugins: [\n            require('autoprefixer')\n        ]\n    }\n    \n没有配置外部css导出，在`module`这样配置`postcss`:\n\n    {\n          test: /\\.css$/,\n          use: [\n                {\n                  loader: \"style-loader\"\n                }, {\n                  loader: \"css-loader\",\n                  options: {\n                     modules: true\n                  }\n                }, {\n                  loader: \"postcss-loader\"\n                }\n          ]\n    }\n\n配置了`extractTextPlugin`，在`module`这样配置`postcss`:\n\n    {\n        test: /\\.css$/,\n        use: extractTextPlugin.extract({\n            fallback: 'style-loader',\n            use: [\n                { loader: 'css-loader', options: { importLoaders: 1 } },\n                'postcss-loader'\n            ]\n        })\n        \n    }\n    \n执行打包处理，自动加上css前缀。\n\n#### 5.2.4 消除未使用的CSS\n对于框架(比如`bootstrap`)或者自己修改后没有使用的css，可以使用`PurifyCSS-webpack`：\n\n    // -D代表的是–save-dev ,只是一个简写\n    //  需要安装purifyCSS-webpack、purify-css这两个包\n    cnpm i -D purifycss-webpack purify-css\n    \n因为我们需要同步检查html模板，所以我们需要引入node的glob对象使用。同时，引入purifycss-webpack。\n\n    const glob = require('glob');\n    const PurifyCSSPlugin = require(\"purifycss-webpack\");\n\n我们在`plugins`中配置:\n\n    // PurifyCSSPlugin 要在 extractTextPlugin 之前，不然 extractTextPlugin 里的压缩和自动前缀可能被影响\n    new PurifyCSSPlugin({\n        // 配置了一个paths，主要是需找html模板，purifycss根据这个配置会遍历你的文件，查找哪些css被使用了\n        paths: glob.sync(path.join(__dirname, 'src/*.html')),\n    }),\n\n#### 5.2.5 less打包\n确定你的生产环境中配了`less`服务：\n\n    cnpm install --save-dev less\n    \n然后安装`less-loader`:\n\n    cnpm install --save-dev less-loader\n    \n在`src/css`下创建 `myless.less`：\n\n    @base :#000;\n    #gogo{\n        width:300px;\n        height:300px;\n        background-color:@base;\n    }\n    \n配置了`extractTextPlugin`，在`module`里这样配置`less-loader`:\n\n    {\n        test: /\\.less$/,\n        use: extractTextPlugin.extract({\n            use: [{\n                loader: \"css-loader\",\n                options: { minimize: true }\n            }, {\n                loader: \"less-loader\"\n            },{\n                loader: 'postcss-loader'\n            }],\n            fallback: \"style-loader\"\n        })\n    }\n    \n在`entry.js`中配置：\n\n    import less from './css/black.less';\n    \n【sass亦同 : 需要在项目目录下用npm安装两个包。node-sass和sass-loader】\n    \n![分割线](https://thumbnail0.baidupcs.com/thumbnail/9c0f8419c448613afe5e9ce4e03c42dd?fid=1737706044-250528-418203039170764&time=1517058000&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Qkr71fUc1rIISl3r2mSINMehzCM%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=624108863495940664&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video)\n\n当前的`webpack.config.js`\n\n    const path = require('path');\n    const htmlPlugin= require('html-webpack-plugin');\n    const extractTextPlugin = require(\"extract-text-webpack-plugin\");\n    const glob = require('glob');\n    const PurifyCSSPlugin = require(\"purifycss-webpack\");\n    \n    module.exports={\n        \n        // 入口文件的配置项\n        entry:{\n            // 这里的entry可以随意命名，使用相对路径引入相应js\n            entry: './src/entry.js'\n            // 如果需要引入多个js\n            // entry: ['./src/entry.js', './src/myjs.js']\n        },\n        \n        // 出口文件的配置项\n        output:{\n            // 打包的路径输出位置，resolve(解析),这里指定一个本机绝对路径\n            path: path.resolve(__dirname, 'dist'),\n            // 打包的文件输出名称\n            filename: 'output.js'\n        },\n        \n        // 模块, 比如解读打包js/CSS, 转换压缩图片\n        module: {\n            rules: [\n                {\n                    test: /\\.css$/,\n                    use: extractTextPlugin.extract({\n                        fallback: \"style-loader\",\n                        use: [\n                            { loader: 'css-loader', options: { minimize: true } },\n                            'postcss-loader'\n                        ]\n                    })\n                },{\n                    test: /\\.less$/,\n                    use: extractTextPlugin.extract({\n                        use: [{\n                            loader: \"css-loader\",\n                            options: { minimize: true }\n                        }, {\n                            loader: \"less-loader\"\n                        },{\n                            loader: 'postcss-loader'\n                        }],\n                        fallback: \"style-loader\"\n                    })\n                }\n            ]\n        },\n        \n        //插件\n        plugins:[\n            new htmlPlugin({\n                // minify：是对html文件进行压缩，removeAttrubuteQuotes是却掉属性的双引号。\n                minify:{\n                    removeAttributeQuotes:true\n                },\n                // hash：为了开发中js有缓存效果，所以加入hash，这样可以有效避免缓存JS。\n                hash:true,\n                // template：是要打包的html模版路径和文件名称。\n                template:'./src/index.html'\n            }),\n    \n            // PurifyCSSPlugin 要在 extractTextPlugin 之前，不然 extractTextPlugin 里的压缩和自动前缀可能被影响\n            new PurifyCSSPlugin({\n                // 配置了一个paths，主要是需找html模板，purifycss根据这个配置会遍历你的文件，查找哪些css被使用了\n                paths: glob.sync(path.join(__dirname, 'src/*.html')),\n            }),\n    \n            new extractTextPlugin(\"/css/index.css\"),\n        ],\n        \n        // 开发调试工具\n        devtool:'',\n        \n        //配置webpack开发服务\n        devServer:{\n            // 设置关联的基本运行路径，这里因为例子是dist，所以我们写的dist\n            contentBase:path.resolve(__dirname,'dist'),\n            // 服务器的IP地址，可以使用IP也可以使用localhost。可以使用ipconfig获取本机ipv4地址在这里使用。\n            host:'localhost',\n            // 服务端压缩是否开启，一般为开启\n            compress:true,\n            //配置服务端口号，这里使用1010\n            port:1010\n        }\n    }\n    \n当前的`entry.js`:\n\n    import css from './css/index.css';\n    import less from './css/myless.less';\n    \n    console.log(\"123\");\n    var xuqingfeng = \"asd2333\";\n\n![分割线](https://thumbnail0.baidupcs.com/thumbnail/9c0f8419c448613afe5e9ce4e03c42dd?fid=1737706044-250528-418203039170764&time=1517058000&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Qkr71fUc1rIISl3r2mSINMehzCM%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=624108863495940664&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video)","source":"_posts/webpack3(二).md","raw":"---\ntitle: webpack(二)  \ndate: 2018-04-01 18:43:08  \ncategories: webpack  \ntags:\n---\n\n> 目录\n>\n> 5. 模块与插件配置\n>\n> > 5.1 发布HTML\n> >\n> > 5.2  CSS打包\n> >\n> > > 5.2.1  分离CSS\n> > >\n> > > 5.2.2 压缩(丑化)css代码\n> > >\n> > > 5.2.3 自动处理CSS3属性前缀\n> > >\n> > > 5.2.4 消除未使用的CSS\n> > >\n> > > 5.2.5 less打包\n\n## 5. 模块与插件配置\n什么是`Loaders`? `loader` 用于对模块的源代码进行转换。是`webpack`最重要的功能，它有如下配置项：\n\n    test: 用于匹配处理文件的扩展名的正则表达式，必须配置\n    \n    use: loader名称(就是你要使用的模块的名称)，必须配置\n    \n    include/exclude: 手动添加的'必须处理的文件(文件夹)/屏蔽不需要处理的文件(文件夹)'，可选配置\n    \n    query: 为loaders提供额外的设置选项（可选）\n\n### 5.1 发布HTML\n我们在src下创建一个`index.html`文件：\n\n    - webpack\n        + dist // 文件输出目录\n        + node_modules // node包依赖\n        - src // 源码文件目录\n            entry.js // webpack的入口文件\n            index.html \n        package.json\n        webpack.config.js // webpack配置文件\n\n`index.html`:\n\n    <!doctype html>\n    <html lang=\"en\">\n    <head>\n    \t<meta charset=\"UTF-8\">\n    \t<!-- 手机页面中加入这句话，可以让页面适应设备的宽度。initial-scale - 初始的缩放比例 -->\n    \t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    \t<!-- Edge 模式通知 Windows Internet Explorer 以最高级别的可用模式显示内容 -->\n    \t<meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\">\n    \t<title>XQF webpack test</title>\n    </head>\n    <body>\n    \t<div id=\"gogo\"></div>\n    \t<div id=\"title\"></div>\n    \t<p>我是小段落123</p>\n    </body>\n    </html>\n    \n▲ 这份`index.html`文件没有js引入，`webpack`会为我们自动引入`js`。它还能够通过入口js文件帮我们自动引入`css`文件。\n\n我们先安装`html-webpack-plugin`，它简化了HTML文件的创建，以便为你的webpack包提供服务：\n\n    cnpm install --save-dev html-webpack-plugin\n\n然后在`webpack.config.js`中引入插件：\n\n    // 头部require\n    const htmlPlugin = require('html-webpack-plugin');\n    \n    // 在plugins中插入\n    new htmlPlugin({\n        // minify：是对html文件进行压缩，removeAttrubuteQuotes是却掉属性的双引号。\n        minify:{\n            removeAttributeQuotes:true\n        },\n        // hash：为了开发中js有缓存效果，所以加入hash，这样可以有效避免缓存JS。\n        hash:true,\n        // template：是要打包的html模版路径和文件名称。\n        template:'./src/index.html'\n    })\n\n### 5.2 CSS打包\n在`src`创建文件夹`css`，在`css`里创建`index.css`:\n\n    - src\n        - css\n            index.css\n\n`index.css`:\n\n    body {\n        background-color: #D5B740;\n        color: black;\n    }\n    #gogo {\n    \twidth: 466px;\n    \theight: 453px;\n    \ttransform: rotate(45deg);\n    \tbox-shadow: 1px 1px 0 rgba(0,0,0,.25);\n    }\n    #meiyong {\n    \twidth: 100%;\n    }\n    #meiyong2 {\n    \twidth: 50%;\n    }\n\ncss打包需要`style-loader`、`css-loader`两个`loader`。 ==一般这两个`loader`结合使用，顺序是`style-loader`在前== ：\n\n    // 使用npm下载两个`loader`:\n    cnpm install --save-dev style-loader css-loader\n\n`style-loader`: 让js解析css。\n\n`css-loader`: `css-loader` 解释(`interpret`) `@import` 和 `url()` ，会 `import/require()` 后再解析`(resolve)`它们。\n\n在入口文件`entry.js`里引入`css`：\n\n    import css from './css/index.css';\n\n在`webpack.config.js`的配置:\n\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,\n                use: [ 'style-loader', 'css-loader' ]\n                // use可以换作loader\n                // loader: [ 'style-loader', 'css-loader' ]\n            }\n        ]\n    },\n\n执行`npm start`打包一下，我们发现打包成功了。我们可以执行`npm run server`在服务端查看一下。\n\n#### 5.2.1 分离CSS\n    \n但是我们发现`css`是打包在`js`里的，因为`webpack`官方认为CSS就应该打包到`JavasScript`当中以减少`http`的请求数，但现实需求有时候需要分离`css`。那么我们需要一个插件`extract-text-webpack-plugin`：\n\n    cnpm install --save-dev extract-text-webpack-plugin\n    \n安装完成后在`webpack.config.js`中引用\n\n    // 顶部require引入\n    const extractTextPlugin = require(\"extract-text-webpack-plugin\");\n    \n    // 在module中进行配置\n    {\n        test: /\\.css$/,\n        use: extractTextPlugin.extract({\n\t        fallback: \"style-loader\",\n\t\t\tuse: 'css-loader'\n\t\t})\t\t\t\t\n    },\n    \n    // 在plugins中进行配置\n    plugins:[\n        new extractTextPlugin(\"./css/index.css\")\n    ],\n    \n#### 5.2.2 压缩(丑化)css代码\n\n设置 `minimize:true` ,就可以压缩`css`了。\n\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,\n                use: extractTextPlugin.extract({\n                    fallback: \"style-loader\",\n                    use: [\n                        { loader: 'css-loader', options: { minimize: true } }\n                    ]\n                })\n            }\n        ]\n    },\n\n#### 5.2.3 自动处理CSS3属性前缀\n\n下载 `postcss-loader` 和`autoprefixer`（自动添加前缀的插件）。\n\n    cnpm install --save-dev postcss-loader autoprefixer\n\n在`src`下建立`postcss.config.js`:\n\n    - webpack\n        + dist // 文件输出目录\n        + node_modules // node包依赖\n        - src // 源码文件目录\n            - css\n                index.css\n            entry.js // webpack的入口文件\n            index.html \n        package.json\n        postcss.config.js // postcss配置文件\n        webpack.config.js // webpack配置文件\n\n`postcss.config.js`:\n\n    module.exports = {\n        plugins: [\n            require('autoprefixer')\n        ]\n    }\n    \n没有配置外部css导出，在`module`这样配置`postcss`:\n\n    {\n          test: /\\.css$/,\n          use: [\n                {\n                  loader: \"style-loader\"\n                }, {\n                  loader: \"css-loader\",\n                  options: {\n                     modules: true\n                  }\n                }, {\n                  loader: \"postcss-loader\"\n                }\n          ]\n    }\n\n配置了`extractTextPlugin`，在`module`这样配置`postcss`:\n\n    {\n        test: /\\.css$/,\n        use: extractTextPlugin.extract({\n            fallback: 'style-loader',\n            use: [\n                { loader: 'css-loader', options: { importLoaders: 1 } },\n                'postcss-loader'\n            ]\n        })\n        \n    }\n    \n执行打包处理，自动加上css前缀。\n\n#### 5.2.4 消除未使用的CSS\n对于框架(比如`bootstrap`)或者自己修改后没有使用的css，可以使用`PurifyCSS-webpack`：\n\n    // -D代表的是–save-dev ,只是一个简写\n    //  需要安装purifyCSS-webpack、purify-css这两个包\n    cnpm i -D purifycss-webpack purify-css\n    \n因为我们需要同步检查html模板，所以我们需要引入node的glob对象使用。同时，引入purifycss-webpack。\n\n    const glob = require('glob');\n    const PurifyCSSPlugin = require(\"purifycss-webpack\");\n\n我们在`plugins`中配置:\n\n    // PurifyCSSPlugin 要在 extractTextPlugin 之前，不然 extractTextPlugin 里的压缩和自动前缀可能被影响\n    new PurifyCSSPlugin({\n        // 配置了一个paths，主要是需找html模板，purifycss根据这个配置会遍历你的文件，查找哪些css被使用了\n        paths: glob.sync(path.join(__dirname, 'src/*.html')),\n    }),\n\n#### 5.2.5 less打包\n确定你的生产环境中配了`less`服务：\n\n    cnpm install --save-dev less\n    \n然后安装`less-loader`:\n\n    cnpm install --save-dev less-loader\n    \n在`src/css`下创建 `myless.less`：\n\n    @base :#000;\n    #gogo{\n        width:300px;\n        height:300px;\n        background-color:@base;\n    }\n    \n配置了`extractTextPlugin`，在`module`里这样配置`less-loader`:\n\n    {\n        test: /\\.less$/,\n        use: extractTextPlugin.extract({\n            use: [{\n                loader: \"css-loader\",\n                options: { minimize: true }\n            }, {\n                loader: \"less-loader\"\n            },{\n                loader: 'postcss-loader'\n            }],\n            fallback: \"style-loader\"\n        })\n    }\n    \n在`entry.js`中配置：\n\n    import less from './css/black.less';\n    \n【sass亦同 : 需要在项目目录下用npm安装两个包。node-sass和sass-loader】\n    \n![分割线](https://thumbnail0.baidupcs.com/thumbnail/9c0f8419c448613afe5e9ce4e03c42dd?fid=1737706044-250528-418203039170764&time=1517058000&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Qkr71fUc1rIISl3r2mSINMehzCM%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=624108863495940664&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video)\n\n当前的`webpack.config.js`\n\n    const path = require('path');\n    const htmlPlugin= require('html-webpack-plugin');\n    const extractTextPlugin = require(\"extract-text-webpack-plugin\");\n    const glob = require('glob');\n    const PurifyCSSPlugin = require(\"purifycss-webpack\");\n    \n    module.exports={\n        \n        // 入口文件的配置项\n        entry:{\n            // 这里的entry可以随意命名，使用相对路径引入相应js\n            entry: './src/entry.js'\n            // 如果需要引入多个js\n            // entry: ['./src/entry.js', './src/myjs.js']\n        },\n        \n        // 出口文件的配置项\n        output:{\n            // 打包的路径输出位置，resolve(解析),这里指定一个本机绝对路径\n            path: path.resolve(__dirname, 'dist'),\n            // 打包的文件输出名称\n            filename: 'output.js'\n        },\n        \n        // 模块, 比如解读打包js/CSS, 转换压缩图片\n        module: {\n            rules: [\n                {\n                    test: /\\.css$/,\n                    use: extractTextPlugin.extract({\n                        fallback: \"style-loader\",\n                        use: [\n                            { loader: 'css-loader', options: { minimize: true } },\n                            'postcss-loader'\n                        ]\n                    })\n                },{\n                    test: /\\.less$/,\n                    use: extractTextPlugin.extract({\n                        use: [{\n                            loader: \"css-loader\",\n                            options: { minimize: true }\n                        }, {\n                            loader: \"less-loader\"\n                        },{\n                            loader: 'postcss-loader'\n                        }],\n                        fallback: \"style-loader\"\n                    })\n                }\n            ]\n        },\n        \n        //插件\n        plugins:[\n            new htmlPlugin({\n                // minify：是对html文件进行压缩，removeAttrubuteQuotes是却掉属性的双引号。\n                minify:{\n                    removeAttributeQuotes:true\n                },\n                // hash：为了开发中js有缓存效果，所以加入hash，这样可以有效避免缓存JS。\n                hash:true,\n                // template：是要打包的html模版路径和文件名称。\n                template:'./src/index.html'\n            }),\n    \n            // PurifyCSSPlugin 要在 extractTextPlugin 之前，不然 extractTextPlugin 里的压缩和自动前缀可能被影响\n            new PurifyCSSPlugin({\n                // 配置了一个paths，主要是需找html模板，purifycss根据这个配置会遍历你的文件，查找哪些css被使用了\n                paths: glob.sync(path.join(__dirname, 'src/*.html')),\n            }),\n    \n            new extractTextPlugin(\"/css/index.css\"),\n        ],\n        \n        // 开发调试工具\n        devtool:'',\n        \n        //配置webpack开发服务\n        devServer:{\n            // 设置关联的基本运行路径，这里因为例子是dist，所以我们写的dist\n            contentBase:path.resolve(__dirname,'dist'),\n            // 服务器的IP地址，可以使用IP也可以使用localhost。可以使用ipconfig获取本机ipv4地址在这里使用。\n            host:'localhost',\n            // 服务端压缩是否开启，一般为开启\n            compress:true,\n            //配置服务端口号，这里使用1010\n            port:1010\n        }\n    }\n    \n当前的`entry.js`:\n\n    import css from './css/index.css';\n    import less from './css/myless.less';\n    \n    console.log(\"123\");\n    var xuqingfeng = \"asd2333\";\n\n![分割线](https://thumbnail0.baidupcs.com/thumbnail/9c0f8419c448613afe5e9ce4e03c42dd?fid=1737706044-250528-418203039170764&time=1517058000&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Qkr71fUc1rIISl3r2mSINMehzCM%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=624108863495940664&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video)","slug":"webpack3(二)","published":1,"updated":"2020-04-01T02:15:52.392Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8gp7rxz000fkb9h3zyq8a4f","content":"<blockquote>\n<p>目录</p>\n<ol start=\"5\">\n<li>模块与插件配置</li>\n</ol>\n<blockquote>\n<p>5.1 发布HTML</p>\n<p>5.2  CSS打包</p>\n<blockquote>\n<p>5.2.1  分离CSS</p>\n<p>5.2.2 压缩(丑化)css代码</p>\n<p>5.2.3 自动处理CSS3属性前缀</p>\n<p>5.2.4 消除未使用的CSS</p>\n<p>5.2.5 less打包</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2 id=\"5-模块与插件配置\"><a href=\"#5-模块与插件配置\" class=\"headerlink\" title=\"5. 模块与插件配置\"></a>5. 模块与插件配置</h2><p>什么是<code>Loaders</code>? <code>loader</code> 用于对模块的源代码进行转换。是<code>webpack</code>最重要的功能，它有如下配置项：</p>\n<pre><code>test: 用于匹配处理文件的扩展名的正则表达式，必须配置\n\nuse: loader名称(就是你要使用的模块的名称)，必须配置\n\ninclude/exclude: 手动添加的&apos;必须处理的文件(文件夹)/屏蔽不需要处理的文件(文件夹)&apos;，可选配置\n\nquery: 为loaders提供额外的设置选项（可选）</code></pre><h3 id=\"5-1-发布HTML\"><a href=\"#5-1-发布HTML\" class=\"headerlink\" title=\"5.1 发布HTML\"></a>5.1 发布HTML</h3><p>我们在src下创建一个<code>index.html</code>文件：</p>\n<pre><code>- webpack\n    + dist // 文件输出目录\n    + node_modules // node包依赖\n    - src // 源码文件目录\n        entry.js // webpack的入口文件\n        index.html \n    package.json\n    webpack.config.js // webpack配置文件</code></pre><p><code>index.html</code>:</p>\n<pre><code>&lt;!doctype html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;!-- 手机页面中加入这句话，可以让页面适应设备的宽度。initial-scale - 初始的缩放比例 --&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;!-- Edge 模式通知 Windows Internet Explorer 以最高级别的可用模式显示内容 --&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt;\n    &lt;title&gt;XQF webpack test&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=&quot;gogo&quot;&gt;&lt;/div&gt;\n    &lt;div id=&quot;title&quot;&gt;&lt;/div&gt;\n    &lt;p&gt;我是小段落123&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><p>▲ 这份<code>index.html</code>文件没有js引入，<code>webpack</code>会为我们自动引入<code>js</code>。它还能够通过入口js文件帮我们自动引入<code>css</code>文件。</p>\n<p>我们先安装<code>html-webpack-plugin</code>，它简化了HTML文件的创建，以便为你的webpack包提供服务：</p>\n<pre><code>cnpm install --save-dev html-webpack-plugin</code></pre><p>然后在<code>webpack.config.js</code>中引入插件：</p>\n<pre><code>// 头部require\nconst htmlPlugin = require(&apos;html-webpack-plugin&apos;);\n\n// 在plugins中插入\nnew htmlPlugin({\n    // minify：是对html文件进行压缩，removeAttrubuteQuotes是却掉属性的双引号。\n    minify:{\n        removeAttributeQuotes:true\n    },\n    // hash：为了开发中js有缓存效果，所以加入hash，这样可以有效避免缓存JS。\n    hash:true,\n    // template：是要打包的html模版路径和文件名称。\n    template:&apos;./src/index.html&apos;\n})</code></pre><h3 id=\"5-2-CSS打包\"><a href=\"#5-2-CSS打包\" class=\"headerlink\" title=\"5.2 CSS打包\"></a>5.2 CSS打包</h3><p>在<code>src</code>创建文件夹<code>css</code>，在<code>css</code>里创建<code>index.css</code>:</p>\n<pre><code>- src\n    - css\n        index.css</code></pre><p><code>index.css</code>:</p>\n<pre><code>body {\n    background-color: #D5B740;\n    color: black;\n}\n#gogo {\n    width: 466px;\n    height: 453px;\n    transform: rotate(45deg);\n    box-shadow: 1px 1px 0 rgba(0,0,0,.25);\n}\n#meiyong {\n    width: 100%;\n}\n#meiyong2 {\n    width: 50%;\n}</code></pre><p>css打包需要<code>style-loader</code>、<code>css-loader</code>两个<code>loader</code>。 ==一般这两个<code>loader</code>结合使用，顺序是<code>style-loader</code>在前== ：</p>\n<pre><code>// 使用npm下载两个`loader`:\ncnpm install --save-dev style-loader css-loader</code></pre><p><code>style-loader</code>: 让js解析css。</p>\n<p><code>css-loader</code>: <code>css-loader</code> 解释(<code>interpret</code>) <code>@import</code> 和 <code>url()</code> ，会 <code>import/require()</code> 后再解析<code>(resolve)</code>它们。</p>\n<p>在入口文件<code>entry.js</code>里引入<code>css</code>：</p>\n<pre><code>import css from &apos;./css/index.css&apos;;</code></pre><p>在<code>webpack.config.js</code>的配置:</p>\n<pre><code>module: {\n    rules: [\n        {\n            test: /\\.css$/,\n            use: [ &apos;style-loader&apos;, &apos;css-loader&apos; ]\n            // use可以换作loader\n            // loader: [ &apos;style-loader&apos;, &apos;css-loader&apos; ]\n        }\n    ]\n},</code></pre><p>执行<code>npm start</code>打包一下，我们发现打包成功了。我们可以执行<code>npm run server</code>在服务端查看一下。</p>\n<h4 id=\"5-2-1-分离CSS\"><a href=\"#5-2-1-分离CSS\" class=\"headerlink\" title=\"5.2.1 分离CSS\"></a>5.2.1 分离CSS</h4><p>但是我们发现<code>css</code>是打包在<code>js</code>里的，因为<code>webpack</code>官方认为CSS就应该打包到<code>JavasScript</code>当中以减少<code>http</code>的请求数，但现实需求有时候需要分离<code>css</code>。那么我们需要一个插件<code>extract-text-webpack-plugin</code>：</p>\n<pre><code>cnpm install --save-dev extract-text-webpack-plugin</code></pre><p>安装完成后在<code>webpack.config.js</code>中引用</p>\n<pre><code>// 顶部require引入\nconst extractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);\n\n// 在module中进行配置\n{\n    test: /\\.css$/,\n    use: extractTextPlugin.extract({\n        fallback: &quot;style-loader&quot;,\n        use: &apos;css-loader&apos;\n    })                \n},\n\n// 在plugins中进行配置\nplugins:[\n    new extractTextPlugin(&quot;./css/index.css&quot;)\n],</code></pre><h4 id=\"5-2-2-压缩-丑化-css代码\"><a href=\"#5-2-2-压缩-丑化-css代码\" class=\"headerlink\" title=\"5.2.2 压缩(丑化)css代码\"></a>5.2.2 压缩(丑化)css代码</h4><p>设置 <code>minimize:true</code> ,就可以压缩<code>css</code>了。</p>\n<pre><code>module: {\n    rules: [\n        {\n            test: /\\.css$/,\n            use: extractTextPlugin.extract({\n                fallback: &quot;style-loader&quot;,\n                use: [\n                    { loader: &apos;css-loader&apos;, options: { minimize: true } }\n                ]\n            })\n        }\n    ]\n},</code></pre><h4 id=\"5-2-3-自动处理CSS3属性前缀\"><a href=\"#5-2-3-自动处理CSS3属性前缀\" class=\"headerlink\" title=\"5.2.3 自动处理CSS3属性前缀\"></a>5.2.3 自动处理CSS3属性前缀</h4><p>下载 <code>postcss-loader</code> 和<code>autoprefixer</code>（自动添加前缀的插件）。</p>\n<pre><code>cnpm install --save-dev postcss-loader autoprefixer</code></pre><p>在<code>src</code>下建立<code>postcss.config.js</code>:</p>\n<pre><code>- webpack\n    + dist // 文件输出目录\n    + node_modules // node包依赖\n    - src // 源码文件目录\n        - css\n            index.css\n        entry.js // webpack的入口文件\n        index.html \n    package.json\n    postcss.config.js // postcss配置文件\n    webpack.config.js // webpack配置文件</code></pre><p><code>postcss.config.js</code>:</p>\n<pre><code>module.exports = {\n    plugins: [\n        require(&apos;autoprefixer&apos;)\n    ]\n}</code></pre><p>没有配置外部css导出，在<code>module</code>这样配置<code>postcss</code>:</p>\n<pre><code>{\n      test: /\\.css$/,\n      use: [\n            {\n              loader: &quot;style-loader&quot;\n            }, {\n              loader: &quot;css-loader&quot;,\n              options: {\n                 modules: true\n              }\n            }, {\n              loader: &quot;postcss-loader&quot;\n            }\n      ]\n}</code></pre><p>配置了<code>extractTextPlugin</code>，在<code>module</code>这样配置<code>postcss</code>:</p>\n<pre><code>{\n    test: /\\.css$/,\n    use: extractTextPlugin.extract({\n        fallback: &apos;style-loader&apos;,\n        use: [\n            { loader: &apos;css-loader&apos;, options: { importLoaders: 1 } },\n            &apos;postcss-loader&apos;\n        ]\n    })\n\n}</code></pre><p>执行打包处理，自动加上css前缀。</p>\n<h4 id=\"5-2-4-消除未使用的CSS\"><a href=\"#5-2-4-消除未使用的CSS\" class=\"headerlink\" title=\"5.2.4 消除未使用的CSS\"></a>5.2.4 消除未使用的CSS</h4><p>对于框架(比如<code>bootstrap</code>)或者自己修改后没有使用的css，可以使用<code>PurifyCSS-webpack</code>：</p>\n<pre><code>// -D代表的是–save-dev ,只是一个简写\n//  需要安装purifyCSS-webpack、purify-css这两个包\ncnpm i -D purifycss-webpack purify-css</code></pre><p>因为我们需要同步检查html模板，所以我们需要引入node的glob对象使用。同时，引入purifycss-webpack。</p>\n<pre><code>const glob = require(&apos;glob&apos;);\nconst PurifyCSSPlugin = require(&quot;purifycss-webpack&quot;);</code></pre><p>我们在<code>plugins</code>中配置:</p>\n<pre><code>// PurifyCSSPlugin 要在 extractTextPlugin 之前，不然 extractTextPlugin 里的压缩和自动前缀可能被影响\nnew PurifyCSSPlugin({\n    // 配置了一个paths，主要是需找html模板，purifycss根据这个配置会遍历你的文件，查找哪些css被使用了\n    paths: glob.sync(path.join(__dirname, &apos;src/*.html&apos;)),\n}),</code></pre><h4 id=\"5-2-5-less打包\"><a href=\"#5-2-5-less打包\" class=\"headerlink\" title=\"5.2.5 less打包\"></a>5.2.5 less打包</h4><p>确定你的生产环境中配了<code>less</code>服务：</p>\n<pre><code>cnpm install --save-dev less</code></pre><p>然后安装<code>less-loader</code>:</p>\n<pre><code>cnpm install --save-dev less-loader</code></pre><p>在<code>src/css</code>下创建 <code>myless.less</code>：</p>\n<pre><code>@base :#000;\n#gogo{\n    width:300px;\n    height:300px;\n    background-color:@base;\n}</code></pre><p>配置了<code>extractTextPlugin</code>，在<code>module</code>里这样配置<code>less-loader</code>:</p>\n<pre><code>{\n    test: /\\.less$/,\n    use: extractTextPlugin.extract({\n        use: [{\n            loader: &quot;css-loader&quot;,\n            options: { minimize: true }\n        }, {\n            loader: &quot;less-loader&quot;\n        },{\n            loader: &apos;postcss-loader&apos;\n        }],\n        fallback: &quot;style-loader&quot;\n    })\n}</code></pre><p>在<code>entry.js</code>中配置：</p>\n<pre><code>import less from &apos;./css/black.less&apos;;</code></pre><p>【sass亦同 : 需要在项目目录下用npm安装两个包。node-sass和sass-loader】</p>\n<p><img src=\"https://thumbnail0.baidupcs.com/thumbnail/9c0f8419c448613afe5e9ce4e03c42dd?fid=1737706044-250528-418203039170764&time=1517058000&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Qkr71fUc1rIISl3r2mSINMehzCM%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=624108863495940664&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video\" alt=\"分割线\"></p>\n<p>当前的<code>webpack.config.js</code></p>\n<pre><code>const path = require(&apos;path&apos;);\nconst htmlPlugin= require(&apos;html-webpack-plugin&apos;);\nconst extractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);\nconst glob = require(&apos;glob&apos;);\nconst PurifyCSSPlugin = require(&quot;purifycss-webpack&quot;);\n\nmodule.exports={\n\n    // 入口文件的配置项\n    entry:{\n        // 这里的entry可以随意命名，使用相对路径引入相应js\n        entry: &apos;./src/entry.js&apos;\n        // 如果需要引入多个js\n        // entry: [&apos;./src/entry.js&apos;, &apos;./src/myjs.js&apos;]\n    },\n\n    // 出口文件的配置项\n    output:{\n        // 打包的路径输出位置，resolve(解析),这里指定一个本机绝对路径\n        path: path.resolve(__dirname, &apos;dist&apos;),\n        // 打包的文件输出名称\n        filename: &apos;output.js&apos;\n    },\n\n    // 模块, 比如解读打包js/CSS, 转换压缩图片\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,\n                use: extractTextPlugin.extract({\n                    fallback: &quot;style-loader&quot;,\n                    use: [\n                        { loader: &apos;css-loader&apos;, options: { minimize: true } },\n                        &apos;postcss-loader&apos;\n                    ]\n                })\n            },{\n                test: /\\.less$/,\n                use: extractTextPlugin.extract({\n                    use: [{\n                        loader: &quot;css-loader&quot;,\n                        options: { minimize: true }\n                    }, {\n                        loader: &quot;less-loader&quot;\n                    },{\n                        loader: &apos;postcss-loader&apos;\n                    }],\n                    fallback: &quot;style-loader&quot;\n                })\n            }\n        ]\n    },\n\n    //插件\n    plugins:[\n        new htmlPlugin({\n            // minify：是对html文件进行压缩，removeAttrubuteQuotes是却掉属性的双引号。\n            minify:{\n                removeAttributeQuotes:true\n            },\n            // hash：为了开发中js有缓存效果，所以加入hash，这样可以有效避免缓存JS。\n            hash:true,\n            // template：是要打包的html模版路径和文件名称。\n            template:&apos;./src/index.html&apos;\n        }),\n\n        // PurifyCSSPlugin 要在 extractTextPlugin 之前，不然 extractTextPlugin 里的压缩和自动前缀可能被影响\n        new PurifyCSSPlugin({\n            // 配置了一个paths，主要是需找html模板，purifycss根据这个配置会遍历你的文件，查找哪些css被使用了\n            paths: glob.sync(path.join(__dirname, &apos;src/*.html&apos;)),\n        }),\n\n        new extractTextPlugin(&quot;/css/index.css&quot;),\n    ],\n\n    // 开发调试工具\n    devtool:&apos;&apos;,\n\n    //配置webpack开发服务\n    devServer:{\n        // 设置关联的基本运行路径，这里因为例子是dist，所以我们写的dist\n        contentBase:path.resolve(__dirname,&apos;dist&apos;),\n        // 服务器的IP地址，可以使用IP也可以使用localhost。可以使用ipconfig获取本机ipv4地址在这里使用。\n        host:&apos;localhost&apos;,\n        // 服务端压缩是否开启，一般为开启\n        compress:true,\n        //配置服务端口号，这里使用1010\n        port:1010\n    }\n}</code></pre><p>当前的<code>entry.js</code>:</p>\n<pre><code>import css from &apos;./css/index.css&apos;;\nimport less from &apos;./css/myless.less&apos;;\n\nconsole.log(&quot;123&quot;);\nvar xuqingfeng = &quot;asd2333&quot;;</code></pre><p><img src=\"https://thumbnail0.baidupcs.com/thumbnail/9c0f8419c448613afe5e9ce4e03c42dd?fid=1737706044-250528-418203039170764&time=1517058000&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Qkr71fUc1rIISl3r2mSINMehzCM%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=624108863495940664&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video\" alt=\"分割线\"></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>目录</p>\n<ol start=\"5\">\n<li>模块与插件配置</li>\n</ol>\n<blockquote>\n<p>5.1 发布HTML</p>\n<p>5.2  CSS打包</p>\n<blockquote>\n<p>5.2.1  分离CSS</p>\n<p>5.2.2 压缩(丑化)css代码</p>\n<p>5.2.3 自动处理CSS3属性前缀</p>\n<p>5.2.4 消除未使用的CSS</p>\n<p>5.2.5 less打包</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2 id=\"5-模块与插件配置\"><a href=\"#5-模块与插件配置\" class=\"headerlink\" title=\"5. 模块与插件配置\"></a>5. 模块与插件配置</h2><p>什么是<code>Loaders</code>? <code>loader</code> 用于对模块的源代码进行转换。是<code>webpack</code>最重要的功能，它有如下配置项：</p>\n<pre><code>test: 用于匹配处理文件的扩展名的正则表达式，必须配置\n\nuse: loader名称(就是你要使用的模块的名称)，必须配置\n\ninclude/exclude: 手动添加的&apos;必须处理的文件(文件夹)/屏蔽不需要处理的文件(文件夹)&apos;，可选配置\n\nquery: 为loaders提供额外的设置选项（可选）</code></pre><h3 id=\"5-1-发布HTML\"><a href=\"#5-1-发布HTML\" class=\"headerlink\" title=\"5.1 发布HTML\"></a>5.1 发布HTML</h3><p>我们在src下创建一个<code>index.html</code>文件：</p>\n<pre><code>- webpack\n    + dist // 文件输出目录\n    + node_modules // node包依赖\n    - src // 源码文件目录\n        entry.js // webpack的入口文件\n        index.html \n    package.json\n    webpack.config.js // webpack配置文件</code></pre><p><code>index.html</code>:</p>\n<pre><code>&lt;!doctype html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;!-- 手机页面中加入这句话，可以让页面适应设备的宽度。initial-scale - 初始的缩放比例 --&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;!-- Edge 模式通知 Windows Internet Explorer 以最高级别的可用模式显示内容 --&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt;\n    &lt;title&gt;XQF webpack test&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=&quot;gogo&quot;&gt;&lt;/div&gt;\n    &lt;div id=&quot;title&quot;&gt;&lt;/div&gt;\n    &lt;p&gt;我是小段落123&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><p>▲ 这份<code>index.html</code>文件没有js引入，<code>webpack</code>会为我们自动引入<code>js</code>。它还能够通过入口js文件帮我们自动引入<code>css</code>文件。</p>\n<p>我们先安装<code>html-webpack-plugin</code>，它简化了HTML文件的创建，以便为你的webpack包提供服务：</p>\n<pre><code>cnpm install --save-dev html-webpack-plugin</code></pre><p>然后在<code>webpack.config.js</code>中引入插件：</p>\n<pre><code>// 头部require\nconst htmlPlugin = require(&apos;html-webpack-plugin&apos;);\n\n// 在plugins中插入\nnew htmlPlugin({\n    // minify：是对html文件进行压缩，removeAttrubuteQuotes是却掉属性的双引号。\n    minify:{\n        removeAttributeQuotes:true\n    },\n    // hash：为了开发中js有缓存效果，所以加入hash，这样可以有效避免缓存JS。\n    hash:true,\n    // template：是要打包的html模版路径和文件名称。\n    template:&apos;./src/index.html&apos;\n})</code></pre><h3 id=\"5-2-CSS打包\"><a href=\"#5-2-CSS打包\" class=\"headerlink\" title=\"5.2 CSS打包\"></a>5.2 CSS打包</h3><p>在<code>src</code>创建文件夹<code>css</code>，在<code>css</code>里创建<code>index.css</code>:</p>\n<pre><code>- src\n    - css\n        index.css</code></pre><p><code>index.css</code>:</p>\n<pre><code>body {\n    background-color: #D5B740;\n    color: black;\n}\n#gogo {\n    width: 466px;\n    height: 453px;\n    transform: rotate(45deg);\n    box-shadow: 1px 1px 0 rgba(0,0,0,.25);\n}\n#meiyong {\n    width: 100%;\n}\n#meiyong2 {\n    width: 50%;\n}</code></pre><p>css打包需要<code>style-loader</code>、<code>css-loader</code>两个<code>loader</code>。 ==一般这两个<code>loader</code>结合使用，顺序是<code>style-loader</code>在前== ：</p>\n<pre><code>// 使用npm下载两个`loader`:\ncnpm install --save-dev style-loader css-loader</code></pre><p><code>style-loader</code>: 让js解析css。</p>\n<p><code>css-loader</code>: <code>css-loader</code> 解释(<code>interpret</code>) <code>@import</code> 和 <code>url()</code> ，会 <code>import/require()</code> 后再解析<code>(resolve)</code>它们。</p>\n<p>在入口文件<code>entry.js</code>里引入<code>css</code>：</p>\n<pre><code>import css from &apos;./css/index.css&apos;;</code></pre><p>在<code>webpack.config.js</code>的配置:</p>\n<pre><code>module: {\n    rules: [\n        {\n            test: /\\.css$/,\n            use: [ &apos;style-loader&apos;, &apos;css-loader&apos; ]\n            // use可以换作loader\n            // loader: [ &apos;style-loader&apos;, &apos;css-loader&apos; ]\n        }\n    ]\n},</code></pre><p>执行<code>npm start</code>打包一下，我们发现打包成功了。我们可以执行<code>npm run server</code>在服务端查看一下。</p>\n<h4 id=\"5-2-1-分离CSS\"><a href=\"#5-2-1-分离CSS\" class=\"headerlink\" title=\"5.2.1 分离CSS\"></a>5.2.1 分离CSS</h4><p>但是我们发现<code>css</code>是打包在<code>js</code>里的，因为<code>webpack</code>官方认为CSS就应该打包到<code>JavasScript</code>当中以减少<code>http</code>的请求数，但现实需求有时候需要分离<code>css</code>。那么我们需要一个插件<code>extract-text-webpack-plugin</code>：</p>\n<pre><code>cnpm install --save-dev extract-text-webpack-plugin</code></pre><p>安装完成后在<code>webpack.config.js</code>中引用</p>\n<pre><code>// 顶部require引入\nconst extractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);\n\n// 在module中进行配置\n{\n    test: /\\.css$/,\n    use: extractTextPlugin.extract({\n        fallback: &quot;style-loader&quot;,\n        use: &apos;css-loader&apos;\n    })                \n},\n\n// 在plugins中进行配置\nplugins:[\n    new extractTextPlugin(&quot;./css/index.css&quot;)\n],</code></pre><h4 id=\"5-2-2-压缩-丑化-css代码\"><a href=\"#5-2-2-压缩-丑化-css代码\" class=\"headerlink\" title=\"5.2.2 压缩(丑化)css代码\"></a>5.2.2 压缩(丑化)css代码</h4><p>设置 <code>minimize:true</code> ,就可以压缩<code>css</code>了。</p>\n<pre><code>module: {\n    rules: [\n        {\n            test: /\\.css$/,\n            use: extractTextPlugin.extract({\n                fallback: &quot;style-loader&quot;,\n                use: [\n                    { loader: &apos;css-loader&apos;, options: { minimize: true } }\n                ]\n            })\n        }\n    ]\n},</code></pre><h4 id=\"5-2-3-自动处理CSS3属性前缀\"><a href=\"#5-2-3-自动处理CSS3属性前缀\" class=\"headerlink\" title=\"5.2.3 自动处理CSS3属性前缀\"></a>5.2.3 自动处理CSS3属性前缀</h4><p>下载 <code>postcss-loader</code> 和<code>autoprefixer</code>（自动添加前缀的插件）。</p>\n<pre><code>cnpm install --save-dev postcss-loader autoprefixer</code></pre><p>在<code>src</code>下建立<code>postcss.config.js</code>:</p>\n<pre><code>- webpack\n    + dist // 文件输出目录\n    + node_modules // node包依赖\n    - src // 源码文件目录\n        - css\n            index.css\n        entry.js // webpack的入口文件\n        index.html \n    package.json\n    postcss.config.js // postcss配置文件\n    webpack.config.js // webpack配置文件</code></pre><p><code>postcss.config.js</code>:</p>\n<pre><code>module.exports = {\n    plugins: [\n        require(&apos;autoprefixer&apos;)\n    ]\n}</code></pre><p>没有配置外部css导出，在<code>module</code>这样配置<code>postcss</code>:</p>\n<pre><code>{\n      test: /\\.css$/,\n      use: [\n            {\n              loader: &quot;style-loader&quot;\n            }, {\n              loader: &quot;css-loader&quot;,\n              options: {\n                 modules: true\n              }\n            }, {\n              loader: &quot;postcss-loader&quot;\n            }\n      ]\n}</code></pre><p>配置了<code>extractTextPlugin</code>，在<code>module</code>这样配置<code>postcss</code>:</p>\n<pre><code>{\n    test: /\\.css$/,\n    use: extractTextPlugin.extract({\n        fallback: &apos;style-loader&apos;,\n        use: [\n            { loader: &apos;css-loader&apos;, options: { importLoaders: 1 } },\n            &apos;postcss-loader&apos;\n        ]\n    })\n\n}</code></pre><p>执行打包处理，自动加上css前缀。</p>\n<h4 id=\"5-2-4-消除未使用的CSS\"><a href=\"#5-2-4-消除未使用的CSS\" class=\"headerlink\" title=\"5.2.4 消除未使用的CSS\"></a>5.2.4 消除未使用的CSS</h4><p>对于框架(比如<code>bootstrap</code>)或者自己修改后没有使用的css，可以使用<code>PurifyCSS-webpack</code>：</p>\n<pre><code>// -D代表的是–save-dev ,只是一个简写\n//  需要安装purifyCSS-webpack、purify-css这两个包\ncnpm i -D purifycss-webpack purify-css</code></pre><p>因为我们需要同步检查html模板，所以我们需要引入node的glob对象使用。同时，引入purifycss-webpack。</p>\n<pre><code>const glob = require(&apos;glob&apos;);\nconst PurifyCSSPlugin = require(&quot;purifycss-webpack&quot;);</code></pre><p>我们在<code>plugins</code>中配置:</p>\n<pre><code>// PurifyCSSPlugin 要在 extractTextPlugin 之前，不然 extractTextPlugin 里的压缩和自动前缀可能被影响\nnew PurifyCSSPlugin({\n    // 配置了一个paths，主要是需找html模板，purifycss根据这个配置会遍历你的文件，查找哪些css被使用了\n    paths: glob.sync(path.join(__dirname, &apos;src/*.html&apos;)),\n}),</code></pre><h4 id=\"5-2-5-less打包\"><a href=\"#5-2-5-less打包\" class=\"headerlink\" title=\"5.2.5 less打包\"></a>5.2.5 less打包</h4><p>确定你的生产环境中配了<code>less</code>服务：</p>\n<pre><code>cnpm install --save-dev less</code></pre><p>然后安装<code>less-loader</code>:</p>\n<pre><code>cnpm install --save-dev less-loader</code></pre><p>在<code>src/css</code>下创建 <code>myless.less</code>：</p>\n<pre><code>@base :#000;\n#gogo{\n    width:300px;\n    height:300px;\n    background-color:@base;\n}</code></pre><p>配置了<code>extractTextPlugin</code>，在<code>module</code>里这样配置<code>less-loader</code>:</p>\n<pre><code>{\n    test: /\\.less$/,\n    use: extractTextPlugin.extract({\n        use: [{\n            loader: &quot;css-loader&quot;,\n            options: { minimize: true }\n        }, {\n            loader: &quot;less-loader&quot;\n        },{\n            loader: &apos;postcss-loader&apos;\n        }],\n        fallback: &quot;style-loader&quot;\n    })\n}</code></pre><p>在<code>entry.js</code>中配置：</p>\n<pre><code>import less from &apos;./css/black.less&apos;;</code></pre><p>【sass亦同 : 需要在项目目录下用npm安装两个包。node-sass和sass-loader】</p>\n<p><img src=\"https://thumbnail0.baidupcs.com/thumbnail/9c0f8419c448613afe5e9ce4e03c42dd?fid=1737706044-250528-418203039170764&time=1517058000&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Qkr71fUc1rIISl3r2mSINMehzCM%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=624108863495940664&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video\" alt=\"分割线\"></p>\n<p>当前的<code>webpack.config.js</code></p>\n<pre><code>const path = require(&apos;path&apos;);\nconst htmlPlugin= require(&apos;html-webpack-plugin&apos;);\nconst extractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);\nconst glob = require(&apos;glob&apos;);\nconst PurifyCSSPlugin = require(&quot;purifycss-webpack&quot;);\n\nmodule.exports={\n\n    // 入口文件的配置项\n    entry:{\n        // 这里的entry可以随意命名，使用相对路径引入相应js\n        entry: &apos;./src/entry.js&apos;\n        // 如果需要引入多个js\n        // entry: [&apos;./src/entry.js&apos;, &apos;./src/myjs.js&apos;]\n    },\n\n    // 出口文件的配置项\n    output:{\n        // 打包的路径输出位置，resolve(解析),这里指定一个本机绝对路径\n        path: path.resolve(__dirname, &apos;dist&apos;),\n        // 打包的文件输出名称\n        filename: &apos;output.js&apos;\n    },\n\n    // 模块, 比如解读打包js/CSS, 转换压缩图片\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,\n                use: extractTextPlugin.extract({\n                    fallback: &quot;style-loader&quot;,\n                    use: [\n                        { loader: &apos;css-loader&apos;, options: { minimize: true } },\n                        &apos;postcss-loader&apos;\n                    ]\n                })\n            },{\n                test: /\\.less$/,\n                use: extractTextPlugin.extract({\n                    use: [{\n                        loader: &quot;css-loader&quot;,\n                        options: { minimize: true }\n                    }, {\n                        loader: &quot;less-loader&quot;\n                    },{\n                        loader: &apos;postcss-loader&apos;\n                    }],\n                    fallback: &quot;style-loader&quot;\n                })\n            }\n        ]\n    },\n\n    //插件\n    plugins:[\n        new htmlPlugin({\n            // minify：是对html文件进行压缩，removeAttrubuteQuotes是却掉属性的双引号。\n            minify:{\n                removeAttributeQuotes:true\n            },\n            // hash：为了开发中js有缓存效果，所以加入hash，这样可以有效避免缓存JS。\n            hash:true,\n            // template：是要打包的html模版路径和文件名称。\n            template:&apos;./src/index.html&apos;\n        }),\n\n        // PurifyCSSPlugin 要在 extractTextPlugin 之前，不然 extractTextPlugin 里的压缩和自动前缀可能被影响\n        new PurifyCSSPlugin({\n            // 配置了一个paths，主要是需找html模板，purifycss根据这个配置会遍历你的文件，查找哪些css被使用了\n            paths: glob.sync(path.join(__dirname, &apos;src/*.html&apos;)),\n        }),\n\n        new extractTextPlugin(&quot;/css/index.css&quot;),\n    ],\n\n    // 开发调试工具\n    devtool:&apos;&apos;,\n\n    //配置webpack开发服务\n    devServer:{\n        // 设置关联的基本运行路径，这里因为例子是dist，所以我们写的dist\n        contentBase:path.resolve(__dirname,&apos;dist&apos;),\n        // 服务器的IP地址，可以使用IP也可以使用localhost。可以使用ipconfig获取本机ipv4地址在这里使用。\n        host:&apos;localhost&apos;,\n        // 服务端压缩是否开启，一般为开启\n        compress:true,\n        //配置服务端口号，这里使用1010\n        port:1010\n    }\n}</code></pre><p>当前的<code>entry.js</code>:</p>\n<pre><code>import css from &apos;./css/index.css&apos;;\nimport less from &apos;./css/myless.less&apos;;\n\nconsole.log(&quot;123&quot;);\nvar xuqingfeng = &quot;asd2333&quot;;</code></pre><p><img src=\"https://thumbnail0.baidupcs.com/thumbnail/9c0f8419c448613afe5e9ce4e03c42dd?fid=1737706044-250528-418203039170764&time=1517058000&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Qkr71fUc1rIISl3r2mSINMehzCM%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=624108863495940664&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video\" alt=\"分割线\"></p>\n"},{"title":"内存模型","date":"2019-07-31T06:21:08.000Z","_content":"\n### 计算机所有信息的存储方式\n计算机中采用二进制表示各种信息，也就是0和1，字节是基本单位。\n\n#### 一、计算机中数的表示\n##### 1.表示范围\n计算机数的表示范围跟字节有关：\n\n类型 | 表示方式\n---|---\n无符号数 | 0 ~ 2^n-1\n有符号数 | -2^(n-1)-1 ~ 2^(n-1)-1\n\n小数：符号位+整数位+指数位  \n非法数字：NaN  \n正无穷大，负无穷大：±∞\n\n\n##### 2.原码、反码、补码\n*  原码：正数的原码是将数的符号位用0表示，负数的原码是将数的符号位用1表示。  \n*  反码：反码表示为符号位不变，其余位按位取反。\n*  补码：原码除符号位外每位取反加1。  \n\n对于正数，原码=反码=补码；对于负数，它的符号位是1，反码就是除符号位每位取反，补码是它的反码加一。计算机对于数字是以补码的方式存储，因为不以补码的方式存储0会有两个存储方式，正数和负数相加结果不对。\n\n##### 3.位运算\n或运算\n\n```\n1 | 0 = 1;\n```\n\n与运算\n\n```\n1 & 0 = 0;\n```\n异或运算（同0异1）\n\n```\n1 ^ 0 = 1; 1 ^ 1 = 0; 0 ^ 0 = 0;\n```\n取反\n\n```\n~0 = 1; ~1 = 0;\n```\n\n\n位移（左：低位补0，右移：高位补0）\n\n```\n1 << 2 = 0000 0001 << 2 = 0000 0100 = 4\n```\n应用：\n\n###### 求数字x的第y位为0还是1\n\n```\nint getFlag(int x,int y) {\n    return (x >> (32 - y)) & 1;\n}\n```\n###### 将数字x的第y位设为0或1\n\n```\nint setFlag(int x,int y,int v) {\n    if(v == 0) {\n        return x & 1 << ~(32 - y)\n    } else {\n        return x | (1 << (32 - y));\n    }\n}\n```\n\n#### 二、编码\n\n对于不同国家的语言有不同的编码方式，同样的编码在不同地方会被解释成不同的语言符号。假如我们想要打开一个文件，比如知道它的编码方式是什么，用它的编码方式打开，否则用错误的编码方式打开文件，就会遇到乱码问题。\n\n##### 1.ASCII码\n\nASCII码一共定义了128个字符的编码。\n\n##### 2.Unicode  \n\n英语使用128个符号编码就够了，但是用来表示其他国家的语言却不够。所有就产生了这样的需求：需要一种编码，将世界各个国家所有的语言符号都包括进去。那么每一个符号都有对应的编码，那么我们可以通过这种编码查看文件就不会产生乱码的问题。这就是Unicode，它的名字即表示这是一种独一无二的编码。\n\n##### 3.UTF-8  \n\nUTF-8是Unicode的实现方式之一。\n\n##### 4.gb2312  \n\ngb2312是中文简体字编码。已经包括了我们生活中最常用的所有汉字与一些符号。\n\n##### 5.gbk\n\n由于中文汉字繁多，gb2312只包括了六千多个汉字，还不能够完全表示，所以gbk在gb2312的基础上兼容扩展了更多的汉字，还包括繁体字。\n\n#### 三、内存分配\n\n##### 1.基本类型  \n\n基本类型在内存空间直接存储它们相应的值，比如数字，字符串。\n\n##### 2.引用类型  \n\n引用类型在内存空间不直接存储它们的值，而是存储这个数据的引用。比如数组、函数。\n\n##### 3.堆栈\n\n基本类型和引用类型分别存储在内存的栈和堆中。基本类型是存储在栈中的简单数据，如果我们对他进行修改，是可以直接修改成功的，而引用类型值是存储在堆中的对象，如果有两个相同对象指向同一个引用，我们修改其中一个会导致另一个也跟着修改。\n\n#### 五、内存回收\n\n这个问题等我哪天想明白了再更新。。。\n\n\n","source":"_posts/内存模型.md","raw":"---\ntitle: 内存模型\ndate: 2019-07-31 14:21:08  \ncategories: 计算机基础  \ntags:\n---\n\n### 计算机所有信息的存储方式\n计算机中采用二进制表示各种信息，也就是0和1，字节是基本单位。\n\n#### 一、计算机中数的表示\n##### 1.表示范围\n计算机数的表示范围跟字节有关：\n\n类型 | 表示方式\n---|---\n无符号数 | 0 ~ 2^n-1\n有符号数 | -2^(n-1)-1 ~ 2^(n-1)-1\n\n小数：符号位+整数位+指数位  \n非法数字：NaN  \n正无穷大，负无穷大：±∞\n\n\n##### 2.原码、反码、补码\n*  原码：正数的原码是将数的符号位用0表示，负数的原码是将数的符号位用1表示。  \n*  反码：反码表示为符号位不变，其余位按位取反。\n*  补码：原码除符号位外每位取反加1。  \n\n对于正数，原码=反码=补码；对于负数，它的符号位是1，反码就是除符号位每位取反，补码是它的反码加一。计算机对于数字是以补码的方式存储，因为不以补码的方式存储0会有两个存储方式，正数和负数相加结果不对。\n\n##### 3.位运算\n或运算\n\n```\n1 | 0 = 1;\n```\n\n与运算\n\n```\n1 & 0 = 0;\n```\n异或运算（同0异1）\n\n```\n1 ^ 0 = 1; 1 ^ 1 = 0; 0 ^ 0 = 0;\n```\n取反\n\n```\n~0 = 1; ~1 = 0;\n```\n\n\n位移（左：低位补0，右移：高位补0）\n\n```\n1 << 2 = 0000 0001 << 2 = 0000 0100 = 4\n```\n应用：\n\n###### 求数字x的第y位为0还是1\n\n```\nint getFlag(int x,int y) {\n    return (x >> (32 - y)) & 1;\n}\n```\n###### 将数字x的第y位设为0或1\n\n```\nint setFlag(int x,int y,int v) {\n    if(v == 0) {\n        return x & 1 << ~(32 - y)\n    } else {\n        return x | (1 << (32 - y));\n    }\n}\n```\n\n#### 二、编码\n\n对于不同国家的语言有不同的编码方式，同样的编码在不同地方会被解释成不同的语言符号。假如我们想要打开一个文件，比如知道它的编码方式是什么，用它的编码方式打开，否则用错误的编码方式打开文件，就会遇到乱码问题。\n\n##### 1.ASCII码\n\nASCII码一共定义了128个字符的编码。\n\n##### 2.Unicode  \n\n英语使用128个符号编码就够了，但是用来表示其他国家的语言却不够。所有就产生了这样的需求：需要一种编码，将世界各个国家所有的语言符号都包括进去。那么每一个符号都有对应的编码，那么我们可以通过这种编码查看文件就不会产生乱码的问题。这就是Unicode，它的名字即表示这是一种独一无二的编码。\n\n##### 3.UTF-8  \n\nUTF-8是Unicode的实现方式之一。\n\n##### 4.gb2312  \n\ngb2312是中文简体字编码。已经包括了我们生活中最常用的所有汉字与一些符号。\n\n##### 5.gbk\n\n由于中文汉字繁多，gb2312只包括了六千多个汉字，还不能够完全表示，所以gbk在gb2312的基础上兼容扩展了更多的汉字，还包括繁体字。\n\n#### 三、内存分配\n\n##### 1.基本类型  \n\n基本类型在内存空间直接存储它们相应的值，比如数字，字符串。\n\n##### 2.引用类型  \n\n引用类型在内存空间不直接存储它们的值，而是存储这个数据的引用。比如数组、函数。\n\n##### 3.堆栈\n\n基本类型和引用类型分别存储在内存的栈和堆中。基本类型是存储在栈中的简单数据，如果我们对他进行修改，是可以直接修改成功的，而引用类型值是存储在堆中的对象，如果有两个相同对象指向同一个引用，我们修改其中一个会导致另一个也跟着修改。\n\n#### 五、内存回收\n\n这个问题等我哪天想明白了再更新。。。\n\n\n","slug":"内存模型","published":1,"updated":"2020-04-01T02:15:52.394Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8gp7rzg000mkb9h5hix24zf","content":"<h3 id=\"计算机所有信息的存储方式\"><a href=\"#计算机所有信息的存储方式\" class=\"headerlink\" title=\"计算机所有信息的存储方式\"></a>计算机所有信息的存储方式</h3><p>计算机中采用二进制表示各种信息，也就是0和1，字节是基本单位。</p>\n<h4 id=\"一、计算机中数的表示\"><a href=\"#一、计算机中数的表示\" class=\"headerlink\" title=\"一、计算机中数的表示\"></a>一、计算机中数的表示</h4><h5 id=\"1-表示范围\"><a href=\"#1-表示范围\" class=\"headerlink\" title=\"1.表示范围\"></a>1.表示范围</h5><p>计算机数的表示范围跟字节有关：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>表示方式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>无符号数</td>\n<td>0 ~ 2^n-1</td>\n</tr>\n<tr>\n<td>有符号数</td>\n<td>-2^(n-1)-1 ~ 2^(n-1)-1</td>\n</tr>\n</tbody></table>\n<p>小数：符号位+整数位+指数位<br>非法数字：NaN<br>正无穷大，负无穷大：±∞</p>\n<h5 id=\"2-原码、反码、补码\"><a href=\"#2-原码、反码、补码\" class=\"headerlink\" title=\"2.原码、反码、补码\"></a>2.原码、反码、补码</h5><ul>\n<li>原码：正数的原码是将数的符号位用0表示，负数的原码是将数的符号位用1表示。  </li>\n<li>反码：反码表示为符号位不变，其余位按位取反。</li>\n<li>补码：原码除符号位外每位取反加1。  </li>\n</ul>\n<p>对于正数，原码=反码=补码；对于负数，它的符号位是1，反码就是除符号位每位取反，补码是它的反码加一。计算机对于数字是以补码的方式存储，因为不以补码的方式存储0会有两个存储方式，正数和负数相加结果不对。</p>\n<h5 id=\"3-位运算\"><a href=\"#3-位运算\" class=\"headerlink\" title=\"3.位运算\"></a>3.位运算</h5><p>或运算</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 | 0 &#x3D; 1;</span><br></pre></td></tr></table></figure>\n\n<p>与运算</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 &amp; 0 &#x3D; 0;</span><br></pre></td></tr></table></figure>\n<p>异或运算（同0异1）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 ^ 0 &#x3D; 1; 1 ^ 1 &#x3D; 0; 0 ^ 0 &#x3D; 0;</span><br></pre></td></tr></table></figure>\n<p>取反</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~0 &#x3D; 1; ~1 &#x3D; 0;</span><br></pre></td></tr></table></figure>\n\n\n<p>位移（左：低位补0，右移：高位补0）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 &lt;&lt; 2 &#x3D; 0000 0001 &lt;&lt; 2 &#x3D; 0000 0100 &#x3D; 4</span><br></pre></td></tr></table></figure>\n<p>应用：</p>\n<h6 id=\"求数字x的第y位为0还是1\"><a href=\"#求数字x的第y位为0还是1\" class=\"headerlink\" title=\"求数字x的第y位为0还是1\"></a>求数字x的第y位为0还是1</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int getFlag(int x,int y) &#123;</span><br><span class=\"line\">    return (x &gt;&gt; (32 - y)) &amp; 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"将数字x的第y位设为0或1\"><a href=\"#将数字x的第y位设为0或1\" class=\"headerlink\" title=\"将数字x的第y位设为0或1\"></a>将数字x的第y位设为0或1</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int setFlag(int x,int y,int v) &#123;</span><br><span class=\"line\">    if(v &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">        return x &amp; 1 &lt;&lt; ~(32 - y)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return x | (1 &lt;&lt; (32 - y));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"二、编码\"><a href=\"#二、编码\" class=\"headerlink\" title=\"二、编码\"></a>二、编码</h4><p>对于不同国家的语言有不同的编码方式，同样的编码在不同地方会被解释成不同的语言符号。假如我们想要打开一个文件，比如知道它的编码方式是什么，用它的编码方式打开，否则用错误的编码方式打开文件，就会遇到乱码问题。</p>\n<h5 id=\"1-ASCII码\"><a href=\"#1-ASCII码\" class=\"headerlink\" title=\"1.ASCII码\"></a>1.ASCII码</h5><p>ASCII码一共定义了128个字符的编码。</p>\n<h5 id=\"2-Unicode\"><a href=\"#2-Unicode\" class=\"headerlink\" title=\"2.Unicode\"></a>2.Unicode</h5><p>英语使用128个符号编码就够了，但是用来表示其他国家的语言却不够。所有就产生了这样的需求：需要一种编码，将世界各个国家所有的语言符号都包括进去。那么每一个符号都有对应的编码，那么我们可以通过这种编码查看文件就不会产生乱码的问题。这就是Unicode，它的名字即表示这是一种独一无二的编码。</p>\n<h5 id=\"3-UTF-8\"><a href=\"#3-UTF-8\" class=\"headerlink\" title=\"3.UTF-8\"></a>3.UTF-8</h5><p>UTF-8是Unicode的实现方式之一。</p>\n<h5 id=\"4-gb2312\"><a href=\"#4-gb2312\" class=\"headerlink\" title=\"4.gb2312\"></a>4.gb2312</h5><p>gb2312是中文简体字编码。已经包括了我们生活中最常用的所有汉字与一些符号。</p>\n<h5 id=\"5-gbk\"><a href=\"#5-gbk\" class=\"headerlink\" title=\"5.gbk\"></a>5.gbk</h5><p>由于中文汉字繁多，gb2312只包括了六千多个汉字，还不能够完全表示，所以gbk在gb2312的基础上兼容扩展了更多的汉字，还包括繁体字。</p>\n<h4 id=\"三、内存分配\"><a href=\"#三、内存分配\" class=\"headerlink\" title=\"三、内存分配\"></a>三、内存分配</h4><h5 id=\"1-基本类型\"><a href=\"#1-基本类型\" class=\"headerlink\" title=\"1.基本类型\"></a>1.基本类型</h5><p>基本类型在内存空间直接存储它们相应的值，比如数字，字符串。</p>\n<h5 id=\"2-引用类型\"><a href=\"#2-引用类型\" class=\"headerlink\" title=\"2.引用类型\"></a>2.引用类型</h5><p>引用类型在内存空间不直接存储它们的值，而是存储这个数据的引用。比如数组、函数。</p>\n<h5 id=\"3-堆栈\"><a href=\"#3-堆栈\" class=\"headerlink\" title=\"3.堆栈\"></a>3.堆栈</h5><p>基本类型和引用类型分别存储在内存的栈和堆中。基本类型是存储在栈中的简单数据，如果我们对他进行修改，是可以直接修改成功的，而引用类型值是存储在堆中的对象，如果有两个相同对象指向同一个引用，我们修改其中一个会导致另一个也跟着修改。</p>\n<h4 id=\"五、内存回收\"><a href=\"#五、内存回收\" class=\"headerlink\" title=\"五、内存回收\"></a>五、内存回收</h4><p>这个问题等我哪天想明白了再更新。。。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"计算机所有信息的存储方式\"><a href=\"#计算机所有信息的存储方式\" class=\"headerlink\" title=\"计算机所有信息的存储方式\"></a>计算机所有信息的存储方式</h3><p>计算机中采用二进制表示各种信息，也就是0和1，字节是基本单位。</p>\n<h4 id=\"一、计算机中数的表示\"><a href=\"#一、计算机中数的表示\" class=\"headerlink\" title=\"一、计算机中数的表示\"></a>一、计算机中数的表示</h4><h5 id=\"1-表示范围\"><a href=\"#1-表示范围\" class=\"headerlink\" title=\"1.表示范围\"></a>1.表示范围</h5><p>计算机数的表示范围跟字节有关：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>表示方式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>无符号数</td>\n<td>0 ~ 2^n-1</td>\n</tr>\n<tr>\n<td>有符号数</td>\n<td>-2^(n-1)-1 ~ 2^(n-1)-1</td>\n</tr>\n</tbody></table>\n<p>小数：符号位+整数位+指数位<br>非法数字：NaN<br>正无穷大，负无穷大：±∞</p>\n<h5 id=\"2-原码、反码、补码\"><a href=\"#2-原码、反码、补码\" class=\"headerlink\" title=\"2.原码、反码、补码\"></a>2.原码、反码、补码</h5><ul>\n<li>原码：正数的原码是将数的符号位用0表示，负数的原码是将数的符号位用1表示。  </li>\n<li>反码：反码表示为符号位不变，其余位按位取反。</li>\n<li>补码：原码除符号位外每位取反加1。  </li>\n</ul>\n<p>对于正数，原码=反码=补码；对于负数，它的符号位是1，反码就是除符号位每位取反，补码是它的反码加一。计算机对于数字是以补码的方式存储，因为不以补码的方式存储0会有两个存储方式，正数和负数相加结果不对。</p>\n<h5 id=\"3-位运算\"><a href=\"#3-位运算\" class=\"headerlink\" title=\"3.位运算\"></a>3.位运算</h5><p>或运算</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 | 0 &#x3D; 1;</span><br></pre></td></tr></table></figure>\n\n<p>与运算</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 &amp; 0 &#x3D; 0;</span><br></pre></td></tr></table></figure>\n<p>异或运算（同0异1）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 ^ 0 &#x3D; 1; 1 ^ 1 &#x3D; 0; 0 ^ 0 &#x3D; 0;</span><br></pre></td></tr></table></figure>\n<p>取反</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~0 &#x3D; 1; ~1 &#x3D; 0;</span><br></pre></td></tr></table></figure>\n\n\n<p>位移（左：低位补0，右移：高位补0）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 &lt;&lt; 2 &#x3D; 0000 0001 &lt;&lt; 2 &#x3D; 0000 0100 &#x3D; 4</span><br></pre></td></tr></table></figure>\n<p>应用：</p>\n<h6 id=\"求数字x的第y位为0还是1\"><a href=\"#求数字x的第y位为0还是1\" class=\"headerlink\" title=\"求数字x的第y位为0还是1\"></a>求数字x的第y位为0还是1</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int getFlag(int x,int y) &#123;</span><br><span class=\"line\">    return (x &gt;&gt; (32 - y)) &amp; 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"将数字x的第y位设为0或1\"><a href=\"#将数字x的第y位设为0或1\" class=\"headerlink\" title=\"将数字x的第y位设为0或1\"></a>将数字x的第y位设为0或1</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int setFlag(int x,int y,int v) &#123;</span><br><span class=\"line\">    if(v &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">        return x &amp; 1 &lt;&lt; ~(32 - y)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return x | (1 &lt;&lt; (32 - y));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"二、编码\"><a href=\"#二、编码\" class=\"headerlink\" title=\"二、编码\"></a>二、编码</h4><p>对于不同国家的语言有不同的编码方式，同样的编码在不同地方会被解释成不同的语言符号。假如我们想要打开一个文件，比如知道它的编码方式是什么，用它的编码方式打开，否则用错误的编码方式打开文件，就会遇到乱码问题。</p>\n<h5 id=\"1-ASCII码\"><a href=\"#1-ASCII码\" class=\"headerlink\" title=\"1.ASCII码\"></a>1.ASCII码</h5><p>ASCII码一共定义了128个字符的编码。</p>\n<h5 id=\"2-Unicode\"><a href=\"#2-Unicode\" class=\"headerlink\" title=\"2.Unicode\"></a>2.Unicode</h5><p>英语使用128个符号编码就够了，但是用来表示其他国家的语言却不够。所有就产生了这样的需求：需要一种编码，将世界各个国家所有的语言符号都包括进去。那么每一个符号都有对应的编码，那么我们可以通过这种编码查看文件就不会产生乱码的问题。这就是Unicode，它的名字即表示这是一种独一无二的编码。</p>\n<h5 id=\"3-UTF-8\"><a href=\"#3-UTF-8\" class=\"headerlink\" title=\"3.UTF-8\"></a>3.UTF-8</h5><p>UTF-8是Unicode的实现方式之一。</p>\n<h5 id=\"4-gb2312\"><a href=\"#4-gb2312\" class=\"headerlink\" title=\"4.gb2312\"></a>4.gb2312</h5><p>gb2312是中文简体字编码。已经包括了我们生活中最常用的所有汉字与一些符号。</p>\n<h5 id=\"5-gbk\"><a href=\"#5-gbk\" class=\"headerlink\" title=\"5.gbk\"></a>5.gbk</h5><p>由于中文汉字繁多，gb2312只包括了六千多个汉字，还不能够完全表示，所以gbk在gb2312的基础上兼容扩展了更多的汉字，还包括繁体字。</p>\n<h4 id=\"三、内存分配\"><a href=\"#三、内存分配\" class=\"headerlink\" title=\"三、内存分配\"></a>三、内存分配</h4><h5 id=\"1-基本类型\"><a href=\"#1-基本类型\" class=\"headerlink\" title=\"1.基本类型\"></a>1.基本类型</h5><p>基本类型在内存空间直接存储它们相应的值，比如数字，字符串。</p>\n<h5 id=\"2-引用类型\"><a href=\"#2-引用类型\" class=\"headerlink\" title=\"2.引用类型\"></a>2.引用类型</h5><p>引用类型在内存空间不直接存储它们的值，而是存储这个数据的引用。比如数组、函数。</p>\n<h5 id=\"3-堆栈\"><a href=\"#3-堆栈\" class=\"headerlink\" title=\"3.堆栈\"></a>3.堆栈</h5><p>基本类型和引用类型分别存储在内存的栈和堆中。基本类型是存储在栈中的简单数据，如果我们对他进行修改，是可以直接修改成功的，而引用类型值是存储在堆中的对象，如果有两个相同对象指向同一个引用，我们修改其中一个会导致另一个也跟着修改。</p>\n<h4 id=\"五、内存回收\"><a href=\"#五、内存回收\" class=\"headerlink\" title=\"五、内存回收\"></a>五、内存回收</h4><p>这个问题等我哪天想明白了再更新。。。</p>\n"},{"title":"闭包","date":"2019-04-01T14:21:08.000Z","_content":"\n## 闭包\n\n&emsp;&emsp;和大多数现代编程语言一样，JavaScript也采用词法作用域，也就是说，函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定的。为了实现这这种词法作用域，JavaScript函数对象的内部状态不仅包含函数的逻辑代码，还必须引用当前的`作用域链`。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性被称为`\"闭包\"`。\n\n> &emsp;&emsp;作用域链：每一段JavaScript代码(全局代码或函数)都有一个与之关联的作用域链(scope chain)。这个作用域链是一个对象列表或者链表，这组对象定义了这段代码\"作用域中\"的变量。当JavaScript需要查找变量x的值的时候(这个过程称做\"变量解析\")，它会从链中的第一个对象开始查找，如果这个对象有一个名为x的属性，则会直接使用这个属性的值，如果第一个对象中不存在名为x的属性，JavaScript会继续查找链上的下一个对象。如果第二个对象依然没有名为x的属性，则会继续查找下一个对象，以此类对。如果作用域链上没有任何一个对象含有属性x，那么久人为这段代码的作用域链上不存在x，并最终抛出一个引用错误异常。\n> &emsp;&emsp;在JavaScript最顶层代码中(也就是不包含在任何函数定义内的代码)，作用域链由一个全局对象组成。在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域链上至少有三个对象。当定义一个函数时，它实际上保存一个作用域链。当调用这个函数时，它穿件一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的\"链\"。对于嵌套函数来讲，每次调用外部函数时，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都有微妙的差别——在每次调用外部函数时，内部函数的代码都是相同的，而且关联这段代码的作用域链也不相同。\n\n&emsp;&emsp;所有的JavaScript函数都是闭包；他们都是对象，他们都关联到作用域链。定义大多数函数时的作用域链在调用函数时依然有效，但这并不影响闭包。当调用函数时闭包所指向的作用域链和定义函数时的作用域链不是同一个作用域链时，就会有一些微妙的变化。当一个函数潜逃了另外一个函数，外部函数将嵌套的函数对象作为返回值返回的时候往往会发生这种事情。有很多强大的编程技术都利用到了这类嵌套的函数闭包，以至于这种编程模式在JavaScript中非常常见。\n&emsp;&emsp;理解闭包首先要了解嵌套函数的此法作用域规则:\n```javascript\nvar scope = \"global scope\";  // 全局变量\nfunction checkscope() {\n  var scope = \"local scope\";  // 局部变量\n  function f() {\n    return scope;   // 在作用域中返回这个值\n  }\n  return f();\n}\ncheckscope()  // => \"local scope\"\n```\n&emsp;&emsp;`checkscope()`函数声明了一个局部变量，并定义一个函数`f()`，函数`f()`返回了这个变量的值，最后将函数`f()`的执行结果返回。对上面的代码做一点改动：\n```javascript\nvar scope = \"global scope\";  // 全局变量\nfunction checkscope() {\n  var scope = \"local scope\";  // 局部变量\n  function f() {\n    return scope;   // 在作用域中返回这个值\n  }\n  return f;\n}\ncheckscope()()\n```\n&emsp;&emsp;这段代码中，函数内的一对圆括号移动到了`checkscope()`之后。`checkscope()`现在仅仅返回函数内嵌套的一个函数对象，而不是直接返回结果。在定义函数的作用域外面，调用这个嵌套的函数（包含最后一行代码的最后一对括号），最后仍会返回`\"local scope\"`。\n&emsp;&emsp;词法作用域的基本规则：JavaScript函数的执行用到了作用域链，这个作用域链是函数定义的时候创建的。嵌套的函数`f()`定义在这个作用域链里，其中的变量scope一定是局部变量，不管在何时何地执行函数`f()`，这种绑定在执行`f()`时依然有效，因此最后一行代码返回`\"local scope\"`，而不是`\"global scope\"`。简言之，闭包这个特性很强大：它们可以捕捉到局部变量（和参数），并一直保存下来，看起来像这些变量绑定到了再其中定义它们的外部函数。\n例如，定义一个`uniqueInteger`函数：\n```javascript\n// 初始化函数对象的计数器属性\n// 由于函数声明被提前，因此这里可以在函数声明前给它的成员赋值\nuniqueInteger.counter = 0;\n\n// 每次调用这个函数都会返回一个不同的整数\n// 它使用一个属性来记住下一次将要返回的值\nfunction uniqueInteger() {\n  return uniqueInteger.counter++; // 先返回计数器的值，然后计数器自增1\n}\n```\n&emsp;&emsp;这个函数使用自身的一个属性来保存每次返回的值，以便每次调用都能跟从上次的返回值。但这种做法有一个问题，就是恶意代码可能将计数器重置或者把一个非整数赋值给它，导致`uniqueInteger()`函数不一定能产生\"唯一\"的“整数”。而闭包可以捕捉到单个函数调用的局部变量，并将这些局部变量用作私有状态。利用闭包重写`uniqueInteger()`函数：\n```javascript\nvar uniqueInteger = (function () { // 定义函数并立即调用\n  var counter = 0;  // 函数的私有状态\n  return function() { return counter++; }\n}());\n```\n&emsp;&emsp;第一行代码看起来像将函数赋值给一个变量`uniqueInteger`，实际上，这段代码定义了一个立即调用函数（函数的开始带有左圆括号），因此是这个函数的返回值赋值给变量`uniqueInteger`。这个函数体返回另外一个函数，这是一个嵌套的函数，我们将它赋值给变量`uniqueInteger`，嵌套的函数是可以访问作用域内的变量的，而且可以访问外部函数中定义的`counter`变量。当外部函数返回值后，其他任何代码都无法访问`counter`变量，只有内部的函数才能访问到它。\n&emsp;&emsp;像`counter`一样的私有变量不是只能用在一个单独的闭包内，在同一个外部函数内定义的多个嵌套函数也可以访问它，这多个嵌套函数都共享一个作用域链：\n```javascript\nfunction counter() { \n  var n = 0;\n  return {\n    count: function() { return n++; },\n    reset: function() { n = 0; }\n  };\n }\n\nvar c = counter(), d = counter(); // 创建两个计数器\nc.count(); // => 0\nd.count(); // => 0:他们互不干扰\nc.reset(); // reset()和count()方法共享状态\nc.count(); // => 0:因为重置了c\nd.count(); // => 1:没有重置d\n```\n&emsp;&emsp;`counter()`函数返回了一个“计数器”对象，这个对象包含两个方法：`count()`返回下一个整数，`reset()`将计数器重置为内部状态。这两个方法都可以访问私有变量n。再者，每次调用counter()都会创建一个新的作用域链和一个新的私有变量。因此，如果调用`counter()`量词，则会得到两个计数器对象，而且彼此包含不同的私有变量，调用其中一个计数器对象的`count()`或`reset()`不会影响到另外一个对象。\n&emsp;&emsp;其实可以将这个闭包合并为属性存取器方法`getter`和`setter`。如下，利用闭包实现`counter()`的私有状态：\n```javascript\nfunction counter(n) { // 函数参数n是一个私有变量\n  return {\n    // 属性getter方法返回并给私有计数器var递增1\n    get count() { return n++; },\n    // 属性setter不允许n递减\n    set count(m) {\n      if (m>=n) n = m;\n      else throw Error(\"count can only be set to a larger value\");\n    }\n  };\n}\n\nvar c = counter(1000);\nc.count   // => 1000\nc.count   // => 1000\nc.count = 2000\nc.count   // => 2000\nc.count = 2000  // => Error!\n```\n&emsp;&emsp;这个`counter()`函数并为声明局部变量，而只是使用参数n来保存私有状态，属性存取器方法可以访问n。这样调用`counter()`的函数就可以指定私有变量的初始值了。\n&emsp;&emsp;定义一个`addPrivatePropetry()`函数，这个函数定义一个私有变量，以及两个嵌套的函数用来获取和设置这个私有变量的值，它将这些嵌套函数添加为所指定对象的方法，利用闭包实现的私有属性存取器方法：\n```javascript\n// 这个函数给对象o增加了属性存取器方法\n// 方法名称为get<name>和set<name>。如果提供了一个判定函数\n// setter方法就会用它来检测参数的合法性，然后在存储它\n// 如果判定函数返回false，setter方法抛出一个异常\n\n// 这个函数不的getter和setter函数\n// 所操作的属性值并没有存储在对象o中\n// 相反，这个值仅仅是保存在函数中的局部变量中\n// getter和setter方法同样是局部函数，因此可以访问这个局部变量\n// 也就是说，对于两个存取器的方法来说这个变量是私有的\n// 没有办法绕过存存取器来设置或修改这个值\nfunction addPrivatePropetry(o, name, predicate) {\n  var value; // 这是一个属性值\n\n  // getter方法简单地将其返回\n  o[\"get\" + name] = function() { return value; };\n\n  // setter方法首先检查值是否合法，若不合法就抛出异常\n  // 否则就将其存储\n  o[\"set\" + name] = function(v) {\n    if (predicate && !predicate(v)) {\n      throw Error(\"set\" + name + \": invalid value\" + v);\n    } else {\n      value = v;\n    }\n  };\n}\n\n// addPrivatePropetry()方法\nvar o = {}; // 设置一个空对象\n// 增加属性存取器方法getName()和setName()\n// 确保只允许字符串值\naddPrivatePropetry(o, \"Name\", function(x) { return typeof x == \"string\"; });\n\no.setName(\"Frank\"); // 设置属性值\nconsole.log(o.getName()); // 得到属性值\no.setName(o); // 设置一个错误类型的值\n```\n&emsp;&emsp;在同一个作用域中定义两个闭包，这两个闭包共享同样的私有变量或变量。这是很重要的一种方式，但要小心那些不希望共享的变量旺旺不经意间共享给了其他的闭包，比如：\n```javascript\n// 这个函数返回一个总是返回v的函数\nfunction constfunc(v) {\n  return function() { return v };\n}\n\n// 创建一个数组用来存储常数函数\nvar funcs = [];\nfor (var i = 0; i < 10; i++) {\n  funcs[i] = constfunc(i);\n}\n\n// 在第五个位置的元素所表示的函数值返回5\nfuncs[5]() // => 5\n```\n&emsp;&emsp;这段代码利用循环创建了很多歌闭包，当写类似这种代码的时候往往会犯一个错误：那就是师徒将循环代码移入定义这个闭包的函数之内，比如：\n```javascript\n// 返回一个函数组成的数组，它们的返回值是0~9\nfunction constfunc() {\n  var funcs = [];\n  for (var i = 0; i < 10; i++) {\n    funcs[i] = function() { return i; }; \n  }\n  return funcs;\n}\n\nvar funcs = constfunc();\nfuncs[5]() // ??\n```\n&emsp;&emsp;上面这段代码创建了10个闭包，并将它们存储到一个数组中。这些闭包都是在同一个函数调用中定义的，因此它们可以共享变量i。当`constfunc()`返回时，变量i的值是10，所有的闭包都共享这一个值，因此，数组中的函数的返回值都是同一个值，这不是想要的结果。关联到闭包的作用域链都是“活动的”。嵌套的函数不会将作用域链内的私有成员复制一份，也不会对所绑定的变量生成静态快照。\n&emsp;&emsp;`this`是JavaScript的关键字，而不是变量。每个函数调用都包含一个`this`值， 如果闭包在外部函数里是无法访问`this`的，除非外部函数将`this`转为一个变量：\n```javascript\nvar self = this; // 将this保存至一个变量中，以便嵌套的函数能够访问它\n```\n&emsp;&emsp;绑定`arguments`的问题与之类似。`arguments`并不是一个关键字，但是在调用每个函数时都会自动声明它，由于闭包具有自己所绑定的`arguments`，因此闭包内无法直接访问外部函数的参数数组，除非外部函数将参数数组保存到另外一个变量中：\n```javascript\nvar outerArguments = arguments; // 保存起来以便嵌套的函数能使用它\n```\n\n","source":"_posts/闭包.md","raw":"---\ntitle: 闭包\ndate: 2019-04-01 22:21:08  \ncategories: JavaScript  \ntags:\n---\n\n## 闭包\n\n&emsp;&emsp;和大多数现代编程语言一样，JavaScript也采用词法作用域，也就是说，函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定的。为了实现这这种词法作用域，JavaScript函数对象的内部状态不仅包含函数的逻辑代码，还必须引用当前的`作用域链`。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性被称为`\"闭包\"`。\n\n> &emsp;&emsp;作用域链：每一段JavaScript代码(全局代码或函数)都有一个与之关联的作用域链(scope chain)。这个作用域链是一个对象列表或者链表，这组对象定义了这段代码\"作用域中\"的变量。当JavaScript需要查找变量x的值的时候(这个过程称做\"变量解析\")，它会从链中的第一个对象开始查找，如果这个对象有一个名为x的属性，则会直接使用这个属性的值，如果第一个对象中不存在名为x的属性，JavaScript会继续查找链上的下一个对象。如果第二个对象依然没有名为x的属性，则会继续查找下一个对象，以此类对。如果作用域链上没有任何一个对象含有属性x，那么久人为这段代码的作用域链上不存在x，并最终抛出一个引用错误异常。\n> &emsp;&emsp;在JavaScript最顶层代码中(也就是不包含在任何函数定义内的代码)，作用域链由一个全局对象组成。在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域链上至少有三个对象。当定义一个函数时，它实际上保存一个作用域链。当调用这个函数时，它穿件一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的\"链\"。对于嵌套函数来讲，每次调用外部函数时，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都有微妙的差别——在每次调用外部函数时，内部函数的代码都是相同的，而且关联这段代码的作用域链也不相同。\n\n&emsp;&emsp;所有的JavaScript函数都是闭包；他们都是对象，他们都关联到作用域链。定义大多数函数时的作用域链在调用函数时依然有效，但这并不影响闭包。当调用函数时闭包所指向的作用域链和定义函数时的作用域链不是同一个作用域链时，就会有一些微妙的变化。当一个函数潜逃了另外一个函数，外部函数将嵌套的函数对象作为返回值返回的时候往往会发生这种事情。有很多强大的编程技术都利用到了这类嵌套的函数闭包，以至于这种编程模式在JavaScript中非常常见。\n&emsp;&emsp;理解闭包首先要了解嵌套函数的此法作用域规则:\n```javascript\nvar scope = \"global scope\";  // 全局变量\nfunction checkscope() {\n  var scope = \"local scope\";  // 局部变量\n  function f() {\n    return scope;   // 在作用域中返回这个值\n  }\n  return f();\n}\ncheckscope()  // => \"local scope\"\n```\n&emsp;&emsp;`checkscope()`函数声明了一个局部变量，并定义一个函数`f()`，函数`f()`返回了这个变量的值，最后将函数`f()`的执行结果返回。对上面的代码做一点改动：\n```javascript\nvar scope = \"global scope\";  // 全局变量\nfunction checkscope() {\n  var scope = \"local scope\";  // 局部变量\n  function f() {\n    return scope;   // 在作用域中返回这个值\n  }\n  return f;\n}\ncheckscope()()\n```\n&emsp;&emsp;这段代码中，函数内的一对圆括号移动到了`checkscope()`之后。`checkscope()`现在仅仅返回函数内嵌套的一个函数对象，而不是直接返回结果。在定义函数的作用域外面，调用这个嵌套的函数（包含最后一行代码的最后一对括号），最后仍会返回`\"local scope\"`。\n&emsp;&emsp;词法作用域的基本规则：JavaScript函数的执行用到了作用域链，这个作用域链是函数定义的时候创建的。嵌套的函数`f()`定义在这个作用域链里，其中的变量scope一定是局部变量，不管在何时何地执行函数`f()`，这种绑定在执行`f()`时依然有效，因此最后一行代码返回`\"local scope\"`，而不是`\"global scope\"`。简言之，闭包这个特性很强大：它们可以捕捉到局部变量（和参数），并一直保存下来，看起来像这些变量绑定到了再其中定义它们的外部函数。\n例如，定义一个`uniqueInteger`函数：\n```javascript\n// 初始化函数对象的计数器属性\n// 由于函数声明被提前，因此这里可以在函数声明前给它的成员赋值\nuniqueInteger.counter = 0;\n\n// 每次调用这个函数都会返回一个不同的整数\n// 它使用一个属性来记住下一次将要返回的值\nfunction uniqueInteger() {\n  return uniqueInteger.counter++; // 先返回计数器的值，然后计数器自增1\n}\n```\n&emsp;&emsp;这个函数使用自身的一个属性来保存每次返回的值，以便每次调用都能跟从上次的返回值。但这种做法有一个问题，就是恶意代码可能将计数器重置或者把一个非整数赋值给它，导致`uniqueInteger()`函数不一定能产生\"唯一\"的“整数”。而闭包可以捕捉到单个函数调用的局部变量，并将这些局部变量用作私有状态。利用闭包重写`uniqueInteger()`函数：\n```javascript\nvar uniqueInteger = (function () { // 定义函数并立即调用\n  var counter = 0;  // 函数的私有状态\n  return function() { return counter++; }\n}());\n```\n&emsp;&emsp;第一行代码看起来像将函数赋值给一个变量`uniqueInteger`，实际上，这段代码定义了一个立即调用函数（函数的开始带有左圆括号），因此是这个函数的返回值赋值给变量`uniqueInteger`。这个函数体返回另外一个函数，这是一个嵌套的函数，我们将它赋值给变量`uniqueInteger`，嵌套的函数是可以访问作用域内的变量的，而且可以访问外部函数中定义的`counter`变量。当外部函数返回值后，其他任何代码都无法访问`counter`变量，只有内部的函数才能访问到它。\n&emsp;&emsp;像`counter`一样的私有变量不是只能用在一个单独的闭包内，在同一个外部函数内定义的多个嵌套函数也可以访问它，这多个嵌套函数都共享一个作用域链：\n```javascript\nfunction counter() { \n  var n = 0;\n  return {\n    count: function() { return n++; },\n    reset: function() { n = 0; }\n  };\n }\n\nvar c = counter(), d = counter(); // 创建两个计数器\nc.count(); // => 0\nd.count(); // => 0:他们互不干扰\nc.reset(); // reset()和count()方法共享状态\nc.count(); // => 0:因为重置了c\nd.count(); // => 1:没有重置d\n```\n&emsp;&emsp;`counter()`函数返回了一个“计数器”对象，这个对象包含两个方法：`count()`返回下一个整数，`reset()`将计数器重置为内部状态。这两个方法都可以访问私有变量n。再者，每次调用counter()都会创建一个新的作用域链和一个新的私有变量。因此，如果调用`counter()`量词，则会得到两个计数器对象，而且彼此包含不同的私有变量，调用其中一个计数器对象的`count()`或`reset()`不会影响到另外一个对象。\n&emsp;&emsp;其实可以将这个闭包合并为属性存取器方法`getter`和`setter`。如下，利用闭包实现`counter()`的私有状态：\n```javascript\nfunction counter(n) { // 函数参数n是一个私有变量\n  return {\n    // 属性getter方法返回并给私有计数器var递增1\n    get count() { return n++; },\n    // 属性setter不允许n递减\n    set count(m) {\n      if (m>=n) n = m;\n      else throw Error(\"count can only be set to a larger value\");\n    }\n  };\n}\n\nvar c = counter(1000);\nc.count   // => 1000\nc.count   // => 1000\nc.count = 2000\nc.count   // => 2000\nc.count = 2000  // => Error!\n```\n&emsp;&emsp;这个`counter()`函数并为声明局部变量，而只是使用参数n来保存私有状态，属性存取器方法可以访问n。这样调用`counter()`的函数就可以指定私有变量的初始值了。\n&emsp;&emsp;定义一个`addPrivatePropetry()`函数，这个函数定义一个私有变量，以及两个嵌套的函数用来获取和设置这个私有变量的值，它将这些嵌套函数添加为所指定对象的方法，利用闭包实现的私有属性存取器方法：\n```javascript\n// 这个函数给对象o增加了属性存取器方法\n// 方法名称为get<name>和set<name>。如果提供了一个判定函数\n// setter方法就会用它来检测参数的合法性，然后在存储它\n// 如果判定函数返回false，setter方法抛出一个异常\n\n// 这个函数不的getter和setter函数\n// 所操作的属性值并没有存储在对象o中\n// 相反，这个值仅仅是保存在函数中的局部变量中\n// getter和setter方法同样是局部函数，因此可以访问这个局部变量\n// 也就是说，对于两个存取器的方法来说这个变量是私有的\n// 没有办法绕过存存取器来设置或修改这个值\nfunction addPrivatePropetry(o, name, predicate) {\n  var value; // 这是一个属性值\n\n  // getter方法简单地将其返回\n  o[\"get\" + name] = function() { return value; };\n\n  // setter方法首先检查值是否合法，若不合法就抛出异常\n  // 否则就将其存储\n  o[\"set\" + name] = function(v) {\n    if (predicate && !predicate(v)) {\n      throw Error(\"set\" + name + \": invalid value\" + v);\n    } else {\n      value = v;\n    }\n  };\n}\n\n// addPrivatePropetry()方法\nvar o = {}; // 设置一个空对象\n// 增加属性存取器方法getName()和setName()\n// 确保只允许字符串值\naddPrivatePropetry(o, \"Name\", function(x) { return typeof x == \"string\"; });\n\no.setName(\"Frank\"); // 设置属性值\nconsole.log(o.getName()); // 得到属性值\no.setName(o); // 设置一个错误类型的值\n```\n&emsp;&emsp;在同一个作用域中定义两个闭包，这两个闭包共享同样的私有变量或变量。这是很重要的一种方式，但要小心那些不希望共享的变量旺旺不经意间共享给了其他的闭包，比如：\n```javascript\n// 这个函数返回一个总是返回v的函数\nfunction constfunc(v) {\n  return function() { return v };\n}\n\n// 创建一个数组用来存储常数函数\nvar funcs = [];\nfor (var i = 0; i < 10; i++) {\n  funcs[i] = constfunc(i);\n}\n\n// 在第五个位置的元素所表示的函数值返回5\nfuncs[5]() // => 5\n```\n&emsp;&emsp;这段代码利用循环创建了很多歌闭包，当写类似这种代码的时候往往会犯一个错误：那就是师徒将循环代码移入定义这个闭包的函数之内，比如：\n```javascript\n// 返回一个函数组成的数组，它们的返回值是0~9\nfunction constfunc() {\n  var funcs = [];\n  for (var i = 0; i < 10; i++) {\n    funcs[i] = function() { return i; }; \n  }\n  return funcs;\n}\n\nvar funcs = constfunc();\nfuncs[5]() // ??\n```\n&emsp;&emsp;上面这段代码创建了10个闭包，并将它们存储到一个数组中。这些闭包都是在同一个函数调用中定义的，因此它们可以共享变量i。当`constfunc()`返回时，变量i的值是10，所有的闭包都共享这一个值，因此，数组中的函数的返回值都是同一个值，这不是想要的结果。关联到闭包的作用域链都是“活动的”。嵌套的函数不会将作用域链内的私有成员复制一份，也不会对所绑定的变量生成静态快照。\n&emsp;&emsp;`this`是JavaScript的关键字，而不是变量。每个函数调用都包含一个`this`值， 如果闭包在外部函数里是无法访问`this`的，除非外部函数将`this`转为一个变量：\n```javascript\nvar self = this; // 将this保存至一个变量中，以便嵌套的函数能够访问它\n```\n&emsp;&emsp;绑定`arguments`的问题与之类似。`arguments`并不是一个关键字，但是在调用每个函数时都会自动声明它，由于闭包具有自己所绑定的`arguments`，因此闭包内无法直接访问外部函数的参数数组，除非外部函数将参数数组保存到另外一个变量中：\n```javascript\nvar outerArguments = arguments; // 保存起来以便嵌套的函数能使用它\n```\n\n","slug":"闭包","published":1,"updated":"2020-04-01T02:15:52.394Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8gp7rzk000okb9hg86ke2c6","content":"<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>&emsp;&emsp;和大多数现代编程语言一样，JavaScript也采用词法作用域，也就是说，函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定的。为了实现这这种词法作用域，JavaScript函数对象的内部状态不仅包含函数的逻辑代码，还必须引用当前的<code>作用域链</code>。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性被称为<code>&quot;闭包&quot;</code>。</p>\n<blockquote>\n<p>&emsp;&emsp;作用域链：每一段JavaScript代码(全局代码或函数)都有一个与之关联的作用域链(scope chain)。这个作用域链是一个对象列表或者链表，这组对象定义了这段代码”作用域中”的变量。当JavaScript需要查找变量x的值的时候(这个过程称做”变量解析”)，它会从链中的第一个对象开始查找，如果这个对象有一个名为x的属性，则会直接使用这个属性的值，如果第一个对象中不存在名为x的属性，JavaScript会继续查找链上的下一个对象。如果第二个对象依然没有名为x的属性，则会继续查找下一个对象，以此类对。如果作用域链上没有任何一个对象含有属性x，那么久人为这段代码的作用域链上不存在x，并最终抛出一个引用错误异常。<br>&emsp;&emsp;在JavaScript最顶层代码中(也就是不包含在任何函数定义内的代码)，作用域链由一个全局对象组成。在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域链上至少有三个对象。当定义一个函数时，它实际上保存一个作用域链。当调用这个函数时，它穿件一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的”链”。对于嵌套函数来讲，每次调用外部函数时，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都有微妙的差别——在每次调用外部函数时，内部函数的代码都是相同的，而且关联这段代码的作用域链也不相同。</p>\n</blockquote>\n<p>&emsp;&emsp;所有的JavaScript函数都是闭包；他们都是对象，他们都关联到作用域链。定义大多数函数时的作用域链在调用函数时依然有效，但这并不影响闭包。当调用函数时闭包所指向的作用域链和定义函数时的作用域链不是同一个作用域链时，就会有一些微妙的变化。当一个函数潜逃了另外一个函数，外部函数将嵌套的函数对象作为返回值返回的时候往往会发生这种事情。有很多强大的编程技术都利用到了这类嵌套的函数闭包，以至于这种编程模式在JavaScript中非常常见。<br>&emsp;&emsp;理解闭包首先要了解嵌套函数的此法作用域规则:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">\"global scope\"</span>;  <span class=\"comment\">// 全局变量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkscope</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> scope = <span class=\"string\">\"local scope\"</span>;  <span class=\"comment\">// 局部变量</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> scope;   <span class=\"comment\">// 在作用域中返回这个值</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> f();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">checkscope()  <span class=\"comment\">// =&gt; \"local scope\"</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>checkscope()</code>函数声明了一个局部变量，并定义一个函数<code>f()</code>，函数<code>f()</code>返回了这个变量的值，最后将函数<code>f()</code>的执行结果返回。对上面的代码做一点改动：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">\"global scope\"</span>;  <span class=\"comment\">// 全局变量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkscope</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> scope = <span class=\"string\">\"local scope\"</span>;  <span class=\"comment\">// 局部变量</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> scope;   <span class=\"comment\">// 在作用域中返回这个值</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">checkscope()()</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这段代码中，函数内的一对圆括号移动到了<code>checkscope()</code>之后。<code>checkscope()</code>现在仅仅返回函数内嵌套的一个函数对象，而不是直接返回结果。在定义函数的作用域外面，调用这个嵌套的函数（包含最后一行代码的最后一对括号），最后仍会返回<code>&quot;local scope&quot;</code>。<br>&emsp;&emsp;词法作用域的基本规则：JavaScript函数的执行用到了作用域链，这个作用域链是函数定义的时候创建的。嵌套的函数<code>f()</code>定义在这个作用域链里，其中的变量scope一定是局部变量，不管在何时何地执行函数<code>f()</code>，这种绑定在执行<code>f()</code>时依然有效，因此最后一行代码返回<code>&quot;local scope&quot;</code>，而不是<code>&quot;global scope&quot;</code>。简言之，闭包这个特性很强大：它们可以捕捉到局部变量（和参数），并一直保存下来，看起来像这些变量绑定到了再其中定义它们的外部函数。<br>例如，定义一个<code>uniqueInteger</code>函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化函数对象的计数器属性</span></span><br><span class=\"line\"><span class=\"comment\">// 由于函数声明被提前，因此这里可以在函数声明前给它的成员赋值</span></span><br><span class=\"line\">uniqueInteger.counter = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 每次调用这个函数都会返回一个不同的整数</span></span><br><span class=\"line\"><span class=\"comment\">// 它使用一个属性来记住下一次将要返回的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uniqueInteger</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> uniqueInteger.counter++; <span class=\"comment\">// 先返回计数器的值，然后计数器自增1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这个函数使用自身的一个属性来保存每次返回的值，以便每次调用都能跟从上次的返回值。但这种做法有一个问题，就是恶意代码可能将计数器重置或者把一个非整数赋值给它，导致<code>uniqueInteger()</code>函数不一定能产生”唯一”的“整数”。而闭包可以捕捉到单个函数调用的局部变量，并将这些局部变量用作私有状态。利用闭包重写<code>uniqueInteger()</code>函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> uniqueInteger = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 定义函数并立即调用</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> counter = <span class=\"number\">0</span>;  <span class=\"comment\">// 函数的私有状态</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> counter++; &#125;</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;第一行代码看起来像将函数赋值给一个变量<code>uniqueInteger</code>，实际上，这段代码定义了一个立即调用函数（函数的开始带有左圆括号），因此是这个函数的返回值赋值给变量<code>uniqueInteger</code>。这个函数体返回另外一个函数，这是一个嵌套的函数，我们将它赋值给变量<code>uniqueInteger</code>，嵌套的函数是可以访问作用域内的变量的，而且可以访问外部函数中定义的<code>counter</code>变量。当外部函数返回值后，其他任何代码都无法访问<code>counter</code>变量，只有内部的函数才能访问到它。<br>&emsp;&emsp;像<code>counter</code>一样的私有变量不是只能用在一个单独的闭包内，在同一个外部函数内定义的多个嵌套函数也可以访问它，这多个嵌套函数都共享一个作用域链：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">counter</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">var</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    count: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> n++; &#125;,</span><br><span class=\"line\">    reset: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; n = <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = counter(), d = counter(); <span class=\"comment\">// 创建两个计数器</span></span><br><span class=\"line\">c.count(); <span class=\"comment\">// =&gt; 0</span></span><br><span class=\"line\">d.count(); <span class=\"comment\">// =&gt; 0:他们互不干扰</span></span><br><span class=\"line\">c.reset(); <span class=\"comment\">// reset()和count()方法共享状态</span></span><br><span class=\"line\">c.count(); <span class=\"comment\">// =&gt; 0:因为重置了c</span></span><br><span class=\"line\">d.count(); <span class=\"comment\">// =&gt; 1:没有重置d</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>counter()</code>函数返回了一个“计数器”对象，这个对象包含两个方法：<code>count()</code>返回下一个整数，<code>reset()</code>将计数器重置为内部状态。这两个方法都可以访问私有变量n。再者，每次调用counter()都会创建一个新的作用域链和一个新的私有变量。因此，如果调用<code>counter()</code>量词，则会得到两个计数器对象，而且彼此包含不同的私有变量，调用其中一个计数器对象的<code>count()</code>或<code>reset()</code>不会影响到另外一个对象。<br>&emsp;&emsp;其实可以将这个闭包合并为属性存取器方法<code>getter</code>和<code>setter</code>。如下，利用闭包实现<code>counter()</code>的私有状态：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">counter</span>(<span class=\"params\">n</span>) </span>&#123; <span class=\"comment\">// 函数参数n是一个私有变量</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 属性getter方法返回并给私有计数器var递增1</span></span><br><span class=\"line\">    <span class=\"keyword\">get</span> count() &#123; <span class=\"keyword\">return</span> n++; &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 属性setter不允许n递减</span></span><br><span class=\"line\">    <span class=\"keyword\">set</span> count(m) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (m&gt;=n) n = m;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">throw</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"count can only be set to a larger value\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = counter(<span class=\"number\">1000</span>);</span><br><span class=\"line\">c.count   <span class=\"comment\">// =&gt; 1000</span></span><br><span class=\"line\">c.count   <span class=\"comment\">// =&gt; 1000</span></span><br><span class=\"line\">c.count = <span class=\"number\">2000</span></span><br><span class=\"line\">c.count   <span class=\"comment\">// =&gt; 2000</span></span><br><span class=\"line\">c.count = <span class=\"number\">2000</span>  <span class=\"comment\">// =&gt; Error!</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这个<code>counter()</code>函数并为声明局部变量，而只是使用参数n来保存私有状态，属性存取器方法可以访问n。这样调用<code>counter()</code>的函数就可以指定私有变量的初始值了。<br>&emsp;&emsp;定义一个<code>addPrivatePropetry()</code>函数，这个函数定义一个私有变量，以及两个嵌套的函数用来获取和设置这个私有变量的值，它将这些嵌套函数添加为所指定对象的方法，利用闭包实现的私有属性存取器方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这个函数给对象o增加了属性存取器方法</span></span><br><span class=\"line\"><span class=\"comment\">// 方法名称为get&lt;name&gt;和set&lt;name&gt;。如果提供了一个判定函数</span></span><br><span class=\"line\"><span class=\"comment\">// setter方法就会用它来检测参数的合法性，然后在存储它</span></span><br><span class=\"line\"><span class=\"comment\">// 如果判定函数返回false，setter方法抛出一个异常</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这个函数不的getter和setter函数</span></span><br><span class=\"line\"><span class=\"comment\">// 所操作的属性值并没有存储在对象o中</span></span><br><span class=\"line\"><span class=\"comment\">// 相反，这个值仅仅是保存在函数中的局部变量中</span></span><br><span class=\"line\"><span class=\"comment\">// getter和setter方法同样是局部函数，因此可以访问这个局部变量</span></span><br><span class=\"line\"><span class=\"comment\">// 也就是说，对于两个存取器的方法来说这个变量是私有的</span></span><br><span class=\"line\"><span class=\"comment\">// 没有办法绕过存存取器来设置或修改这个值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addPrivatePropetry</span>(<span class=\"params\">o, name, predicate</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> value; <span class=\"comment\">// 这是一个属性值</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// getter方法简单地将其返回</span></span><br><span class=\"line\">  o[<span class=\"string\">\"get\"</span> + name] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> value; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// setter方法首先检查值是否合法，若不合法就抛出异常</span></span><br><span class=\"line\">  <span class=\"comment\">// 否则就将其存储</span></span><br><span class=\"line\">  o[<span class=\"string\">\"set\"</span> + name] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (predicate &amp;&amp; !predicate(v)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"set\"</span> + name + <span class=\"string\">\": invalid value\"</span> + v);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      value = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// addPrivatePropetry()方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;&#125;; <span class=\"comment\">// 设置一个空对象</span></span><br><span class=\"line\"><span class=\"comment\">// 增加属性存取器方法getName()和setName()</span></span><br><span class=\"line\"><span class=\"comment\">// 确保只允许字符串值</span></span><br><span class=\"line\">addPrivatePropetry(o, <span class=\"string\">\"Name\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> x == <span class=\"string\">\"string\"</span>; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">o.setName(<span class=\"string\">\"Frank\"</span>); <span class=\"comment\">// 设置属性值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o.getName()); <span class=\"comment\">// 得到属性值</span></span><br><span class=\"line\">o.setName(o); <span class=\"comment\">// 设置一个错误类型的值</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;在同一个作用域中定义两个闭包，这两个闭包共享同样的私有变量或变量。这是很重要的一种方式，但要小心那些不希望共享的变量旺旺不经意间共享给了其他的闭包，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这个函数返回一个总是返回v的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">constfunc</span>(<span class=\"params\">v</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> v &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个数组用来存储常数函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> funcs = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  funcs[i] = constfunc(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在第五个位置的元素所表示的函数值返回5</span></span><br><span class=\"line\">funcs[<span class=\"number\">5</span>]() <span class=\"comment\">// =&gt; 5</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这段代码利用循环创建了很多歌闭包，当写类似这种代码的时候往往会犯一个错误：那就是师徒将循环代码移入定义这个闭包的函数之内，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回一个函数组成的数组，它们的返回值是0~9</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">constfunc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> funcs = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    funcs[i] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> i; &#125;; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> funcs;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> funcs = constfunc();</span><br><span class=\"line\">funcs[<span class=\"number\">5</span>]() <span class=\"comment\">// ??</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;上面这段代码创建了10个闭包，并将它们存储到一个数组中。这些闭包都是在同一个函数调用中定义的，因此它们可以共享变量i。当<code>constfunc()</code>返回时，变量i的值是10，所有的闭包都共享这一个值，因此，数组中的函数的返回值都是同一个值，这不是想要的结果。关联到闭包的作用域链都是“活动的”。嵌套的函数不会将作用域链内的私有成员复制一份，也不会对所绑定的变量生成静态快照。<br>&emsp;&emsp;<code>this</code>是JavaScript的关键字，而不是变量。每个函数调用都包含一个<code>this</code>值， 如果闭包在外部函数里是无法访问<code>this</code>的，除非外部函数将<code>this</code>转为一个变量：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>; <span class=\"comment\">// 将this保存至一个变量中，以便嵌套的函数能够访问它</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;绑定<code>arguments</code>的问题与之类似。<code>arguments</code>并不是一个关键字，但是在调用每个函数时都会自动声明它，由于闭包具有自己所绑定的<code>arguments</code>，因此闭包内无法直接访问外部函数的参数数组，除非外部函数将参数数组保存到另外一个变量中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> outerArguments = <span class=\"built_in\">arguments</span>; <span class=\"comment\">// 保存起来以便嵌套的函数能使用它</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>&emsp;&emsp;和大多数现代编程语言一样，JavaScript也采用词法作用域，也就是说，函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定的。为了实现这这种词法作用域，JavaScript函数对象的内部状态不仅包含函数的逻辑代码，还必须引用当前的<code>作用域链</code>。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性被称为<code>&quot;闭包&quot;</code>。</p>\n<blockquote>\n<p>&emsp;&emsp;作用域链：每一段JavaScript代码(全局代码或函数)都有一个与之关联的作用域链(scope chain)。这个作用域链是一个对象列表或者链表，这组对象定义了这段代码”作用域中”的变量。当JavaScript需要查找变量x的值的时候(这个过程称做”变量解析”)，它会从链中的第一个对象开始查找，如果这个对象有一个名为x的属性，则会直接使用这个属性的值，如果第一个对象中不存在名为x的属性，JavaScript会继续查找链上的下一个对象。如果第二个对象依然没有名为x的属性，则会继续查找下一个对象，以此类对。如果作用域链上没有任何一个对象含有属性x，那么久人为这段代码的作用域链上不存在x，并最终抛出一个引用错误异常。<br>&emsp;&emsp;在JavaScript最顶层代码中(也就是不包含在任何函数定义内的代码)，作用域链由一个全局对象组成。在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域链上至少有三个对象。当定义一个函数时，它实际上保存一个作用域链。当调用这个函数时，它穿件一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的”链”。对于嵌套函数来讲，每次调用外部函数时，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都有微妙的差别——在每次调用外部函数时，内部函数的代码都是相同的，而且关联这段代码的作用域链也不相同。</p>\n</blockquote>\n<p>&emsp;&emsp;所有的JavaScript函数都是闭包；他们都是对象，他们都关联到作用域链。定义大多数函数时的作用域链在调用函数时依然有效，但这并不影响闭包。当调用函数时闭包所指向的作用域链和定义函数时的作用域链不是同一个作用域链时，就会有一些微妙的变化。当一个函数潜逃了另外一个函数，外部函数将嵌套的函数对象作为返回值返回的时候往往会发生这种事情。有很多强大的编程技术都利用到了这类嵌套的函数闭包，以至于这种编程模式在JavaScript中非常常见。<br>&emsp;&emsp;理解闭包首先要了解嵌套函数的此法作用域规则:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">\"global scope\"</span>;  <span class=\"comment\">// 全局变量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkscope</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> scope = <span class=\"string\">\"local scope\"</span>;  <span class=\"comment\">// 局部变量</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> scope;   <span class=\"comment\">// 在作用域中返回这个值</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> f();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">checkscope()  <span class=\"comment\">// =&gt; \"local scope\"</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>checkscope()</code>函数声明了一个局部变量，并定义一个函数<code>f()</code>，函数<code>f()</code>返回了这个变量的值，最后将函数<code>f()</code>的执行结果返回。对上面的代码做一点改动：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">\"global scope\"</span>;  <span class=\"comment\">// 全局变量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkscope</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> scope = <span class=\"string\">\"local scope\"</span>;  <span class=\"comment\">// 局部变量</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> scope;   <span class=\"comment\">// 在作用域中返回这个值</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">checkscope()()</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这段代码中，函数内的一对圆括号移动到了<code>checkscope()</code>之后。<code>checkscope()</code>现在仅仅返回函数内嵌套的一个函数对象，而不是直接返回结果。在定义函数的作用域外面，调用这个嵌套的函数（包含最后一行代码的最后一对括号），最后仍会返回<code>&quot;local scope&quot;</code>。<br>&emsp;&emsp;词法作用域的基本规则：JavaScript函数的执行用到了作用域链，这个作用域链是函数定义的时候创建的。嵌套的函数<code>f()</code>定义在这个作用域链里，其中的变量scope一定是局部变量，不管在何时何地执行函数<code>f()</code>，这种绑定在执行<code>f()</code>时依然有效，因此最后一行代码返回<code>&quot;local scope&quot;</code>，而不是<code>&quot;global scope&quot;</code>。简言之，闭包这个特性很强大：它们可以捕捉到局部变量（和参数），并一直保存下来，看起来像这些变量绑定到了再其中定义它们的外部函数。<br>例如，定义一个<code>uniqueInteger</code>函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化函数对象的计数器属性</span></span><br><span class=\"line\"><span class=\"comment\">// 由于函数声明被提前，因此这里可以在函数声明前给它的成员赋值</span></span><br><span class=\"line\">uniqueInteger.counter = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 每次调用这个函数都会返回一个不同的整数</span></span><br><span class=\"line\"><span class=\"comment\">// 它使用一个属性来记住下一次将要返回的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uniqueInteger</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> uniqueInteger.counter++; <span class=\"comment\">// 先返回计数器的值，然后计数器自增1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这个函数使用自身的一个属性来保存每次返回的值，以便每次调用都能跟从上次的返回值。但这种做法有一个问题，就是恶意代码可能将计数器重置或者把一个非整数赋值给它，导致<code>uniqueInteger()</code>函数不一定能产生”唯一”的“整数”。而闭包可以捕捉到单个函数调用的局部变量，并将这些局部变量用作私有状态。利用闭包重写<code>uniqueInteger()</code>函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> uniqueInteger = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 定义函数并立即调用</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> counter = <span class=\"number\">0</span>;  <span class=\"comment\">// 函数的私有状态</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> counter++; &#125;</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;第一行代码看起来像将函数赋值给一个变量<code>uniqueInteger</code>，实际上，这段代码定义了一个立即调用函数（函数的开始带有左圆括号），因此是这个函数的返回值赋值给变量<code>uniqueInteger</code>。这个函数体返回另外一个函数，这是一个嵌套的函数，我们将它赋值给变量<code>uniqueInteger</code>，嵌套的函数是可以访问作用域内的变量的，而且可以访问外部函数中定义的<code>counter</code>变量。当外部函数返回值后，其他任何代码都无法访问<code>counter</code>变量，只有内部的函数才能访问到它。<br>&emsp;&emsp;像<code>counter</code>一样的私有变量不是只能用在一个单独的闭包内，在同一个外部函数内定义的多个嵌套函数也可以访问它，这多个嵌套函数都共享一个作用域链：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">counter</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">var</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    count: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> n++; &#125;,</span><br><span class=\"line\">    reset: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; n = <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = counter(), d = counter(); <span class=\"comment\">// 创建两个计数器</span></span><br><span class=\"line\">c.count(); <span class=\"comment\">// =&gt; 0</span></span><br><span class=\"line\">d.count(); <span class=\"comment\">// =&gt; 0:他们互不干扰</span></span><br><span class=\"line\">c.reset(); <span class=\"comment\">// reset()和count()方法共享状态</span></span><br><span class=\"line\">c.count(); <span class=\"comment\">// =&gt; 0:因为重置了c</span></span><br><span class=\"line\">d.count(); <span class=\"comment\">// =&gt; 1:没有重置d</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>counter()</code>函数返回了一个“计数器”对象，这个对象包含两个方法：<code>count()</code>返回下一个整数，<code>reset()</code>将计数器重置为内部状态。这两个方法都可以访问私有变量n。再者，每次调用counter()都会创建一个新的作用域链和一个新的私有变量。因此，如果调用<code>counter()</code>量词，则会得到两个计数器对象，而且彼此包含不同的私有变量，调用其中一个计数器对象的<code>count()</code>或<code>reset()</code>不会影响到另外一个对象。<br>&emsp;&emsp;其实可以将这个闭包合并为属性存取器方法<code>getter</code>和<code>setter</code>。如下，利用闭包实现<code>counter()</code>的私有状态：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">counter</span>(<span class=\"params\">n</span>) </span>&#123; <span class=\"comment\">// 函数参数n是一个私有变量</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 属性getter方法返回并给私有计数器var递增1</span></span><br><span class=\"line\">    <span class=\"keyword\">get</span> count() &#123; <span class=\"keyword\">return</span> n++; &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 属性setter不允许n递减</span></span><br><span class=\"line\">    <span class=\"keyword\">set</span> count(m) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (m&gt;=n) n = m;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">throw</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"count can only be set to a larger value\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = counter(<span class=\"number\">1000</span>);</span><br><span class=\"line\">c.count   <span class=\"comment\">// =&gt; 1000</span></span><br><span class=\"line\">c.count   <span class=\"comment\">// =&gt; 1000</span></span><br><span class=\"line\">c.count = <span class=\"number\">2000</span></span><br><span class=\"line\">c.count   <span class=\"comment\">// =&gt; 2000</span></span><br><span class=\"line\">c.count = <span class=\"number\">2000</span>  <span class=\"comment\">// =&gt; Error!</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这个<code>counter()</code>函数并为声明局部变量，而只是使用参数n来保存私有状态，属性存取器方法可以访问n。这样调用<code>counter()</code>的函数就可以指定私有变量的初始值了。<br>&emsp;&emsp;定义一个<code>addPrivatePropetry()</code>函数，这个函数定义一个私有变量，以及两个嵌套的函数用来获取和设置这个私有变量的值，它将这些嵌套函数添加为所指定对象的方法，利用闭包实现的私有属性存取器方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这个函数给对象o增加了属性存取器方法</span></span><br><span class=\"line\"><span class=\"comment\">// 方法名称为get&lt;name&gt;和set&lt;name&gt;。如果提供了一个判定函数</span></span><br><span class=\"line\"><span class=\"comment\">// setter方法就会用它来检测参数的合法性，然后在存储它</span></span><br><span class=\"line\"><span class=\"comment\">// 如果判定函数返回false，setter方法抛出一个异常</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这个函数不的getter和setter函数</span></span><br><span class=\"line\"><span class=\"comment\">// 所操作的属性值并没有存储在对象o中</span></span><br><span class=\"line\"><span class=\"comment\">// 相反，这个值仅仅是保存在函数中的局部变量中</span></span><br><span class=\"line\"><span class=\"comment\">// getter和setter方法同样是局部函数，因此可以访问这个局部变量</span></span><br><span class=\"line\"><span class=\"comment\">// 也就是说，对于两个存取器的方法来说这个变量是私有的</span></span><br><span class=\"line\"><span class=\"comment\">// 没有办法绕过存存取器来设置或修改这个值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addPrivatePropetry</span>(<span class=\"params\">o, name, predicate</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> value; <span class=\"comment\">// 这是一个属性值</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// getter方法简单地将其返回</span></span><br><span class=\"line\">  o[<span class=\"string\">\"get\"</span> + name] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> value; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// setter方法首先检查值是否合法，若不合法就抛出异常</span></span><br><span class=\"line\">  <span class=\"comment\">// 否则就将其存储</span></span><br><span class=\"line\">  o[<span class=\"string\">\"set\"</span> + name] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (predicate &amp;&amp; !predicate(v)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"set\"</span> + name + <span class=\"string\">\": invalid value\"</span> + v);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      value = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// addPrivatePropetry()方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;&#125;; <span class=\"comment\">// 设置一个空对象</span></span><br><span class=\"line\"><span class=\"comment\">// 增加属性存取器方法getName()和setName()</span></span><br><span class=\"line\"><span class=\"comment\">// 确保只允许字符串值</span></span><br><span class=\"line\">addPrivatePropetry(o, <span class=\"string\">\"Name\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> x == <span class=\"string\">\"string\"</span>; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">o.setName(<span class=\"string\">\"Frank\"</span>); <span class=\"comment\">// 设置属性值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o.getName()); <span class=\"comment\">// 得到属性值</span></span><br><span class=\"line\">o.setName(o); <span class=\"comment\">// 设置一个错误类型的值</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;在同一个作用域中定义两个闭包，这两个闭包共享同样的私有变量或变量。这是很重要的一种方式，但要小心那些不希望共享的变量旺旺不经意间共享给了其他的闭包，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这个函数返回一个总是返回v的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">constfunc</span>(<span class=\"params\">v</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> v &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个数组用来存储常数函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> funcs = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  funcs[i] = constfunc(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在第五个位置的元素所表示的函数值返回5</span></span><br><span class=\"line\">funcs[<span class=\"number\">5</span>]() <span class=\"comment\">// =&gt; 5</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这段代码利用循环创建了很多歌闭包，当写类似这种代码的时候往往会犯一个错误：那就是师徒将循环代码移入定义这个闭包的函数之内，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回一个函数组成的数组，它们的返回值是0~9</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">constfunc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> funcs = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    funcs[i] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> i; &#125;; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> funcs;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> funcs = constfunc();</span><br><span class=\"line\">funcs[<span class=\"number\">5</span>]() <span class=\"comment\">// ??</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;上面这段代码创建了10个闭包，并将它们存储到一个数组中。这些闭包都是在同一个函数调用中定义的，因此它们可以共享变量i。当<code>constfunc()</code>返回时，变量i的值是10，所有的闭包都共享这一个值，因此，数组中的函数的返回值都是同一个值，这不是想要的结果。关联到闭包的作用域链都是“活动的”。嵌套的函数不会将作用域链内的私有成员复制一份，也不会对所绑定的变量生成静态快照。<br>&emsp;&emsp;<code>this</code>是JavaScript的关键字，而不是变量。每个函数调用都包含一个<code>this</code>值， 如果闭包在外部函数里是无法访问<code>this</code>的，除非外部函数将<code>this</code>转为一个变量：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>; <span class=\"comment\">// 将this保存至一个变量中，以便嵌套的函数能够访问它</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;绑定<code>arguments</code>的问题与之类似。<code>arguments</code>并不是一个关键字，但是在调用每个函数时都会自动声明它，由于闭包具有自己所绑定的<code>arguments</code>，因此闭包内无法直接访问外部函数的参数数组，除非外部函数将参数数组保存到另外一个变量中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> outerArguments = <span class=\"built_in\">arguments</span>; <span class=\"comment\">// 保存起来以便嵌套的函数能使用它</span></span><br></pre></td></tr></table></figure>\n\n"},{"title":"《Just JavaScript》01. 思维模型","date":"2020-03-28T13:40:45.000Z","_content":"\n读以下代码：\n\n``` javascript\nlet a = 10;\nlet b = a;\na = 0;\n```\n\n当他们运行后a和b的值是多少？在你往下阅读之前，先在你的脑子中想出答案。\n\n如果你已经写了一段时间的JavaScript，你可能会想：“这比我每天写的代码简单多了，意义何在？”\n\n这个练习的目标不是向你介绍变量，我们认为你已经对这些很熟悉了。相反的，它是为了让你注意并反思你的思维模型。\n\n## 什么是思维模型\n\n再次阅读上面的代码，目的是真正确定结果是什么。（我们稍后看为什么这个目的很重要）\n\n当你第二次读它的时候，一步步地注意你脑子里发生的事，你可能会有这样的独白：\n\n``` javascript\n// 1.声明一个变量a,并给它赋值10\nlet a = 10;\n// 2.声明一个变量b,将a的值赋给它,a为10,所以b也为10\nlet b = a;\n// 3.将0赋给a\na = 0;\n// 4.所以最后的答案是a的值为0，b的值为10\n```\n\n可能你脑中想的会有点不一样，可能你想的是给a设置值而不是赋值，或者你可能用不同的顺序读它。甚至你最后得出了不同的结果。注意一下具体哪里不同，即使是这段独白也无法真正捕捉到你脑海中发生的事情。你可能会说“把b设为a”，但是设置一个变量意味着什么呢？\n\n你可能会发现，对每个熟悉的基本编程概念（比如变量）和操作（比如赋值），会有一套根深蒂固的类比与之相关。一些来自于现实的世界，其他的可能会从你最初学到的领域重新运用，比如数学中的数字。这些类比可能会部分重叠甚至矛盾，但是它们仍然帮助你理解在代码中发生了什么。\n\n举个例子，很多人最初把变量当做盒子来学习，你可以往里面放东西。当你看到一个变量的时候，尽管你并没有真正地想象出一个盒子，但是在你的脑海里它们可能仍表现得像一个盒子。这些在你脑海中相似的运作方式被我们称做思维模型。思维模型对编程很久的你来说可能有难度，但是你要尝试注意和反思它们。它们可能是视觉的、空间的和机械的思维捷径的组合。\n\n这些直觉（类似把变量比作盒子）在我们整个编程生涯中会影响我们如何读代码。但是有时候，我们的思维模型是错误的。可能我们早期读过的辅导课为了能简单的解释一些东西而牺牲了它的正确性。也许我们错误的从之前学过的另一种语言转移了关于特定语言特征的直觉。也许我们从某段代码推断出一种思维模型，但从未验证它是否准确。\n\n识别和解决这些问题就是这本书《Just JavaScript》的全部内容。我们将逐步构建（或者，可能的话，重新构建）你关于JavaScript的思维模型，使之准确而有用。一个好的思维模型将会帮助你更快的定位和修复bug，更好的理解别人的代码，对你自己写的代码更自信。\n\n（顺带一提，a的值为0，b的值为10是正确答案）。\n\n## 快慢编码\n\n丹尼尔·卡尼曼的《思考，快与慢》是一本广受欢迎的非小说类书籍。它的中心论点是，人类在思考时使用两种不同的“系统”。\n\n只要有可能，我们就依靠“快速”系统。我们与许多动物共享这个紫铜，这给我们惊人的力量，就像走路时不摔倒一样。这个“快速”系统擅长模式匹配（生存所必需！！）以及“内脏反应”。但是它并不擅长计划。\n\n独特的是，由于额叶的发育，人类也有一个“慢”思维系统。这个“慢”思维系统负责复杂的逐步的推理。它让我们计划未来的事件，参与争论或遵循数学证明。\n\n因为使用“慢”系统在精神上非常消耗，所以我们倾向于默认使用“快”系统，即使在处理诸如编码之类的智能任务时也是如此。\n\n想象你正忙于大量的工作，并且你希望快速识别此函数的功能，快速浏览以下代码：\n\n``` javascript\nfunction duplicateSpreadsheet(original) {\n    if (original.hasPendingChanges) {\n        throw new Error('You need to save the file before you can duplicate it.');\n    }\n    let copy = {\n        created: Date.now(),\n        author: original.author,\n        cells: original.cells,\n        metadata: original.metadata,\n    };\n    copy.metadata.title = 'Copy of ' + original.metadata.title;\n    return copy;\n}\n```\n\n你可能会思考：\n\n* 这个函数复制一个电子表格\n* 如果初始电子表格不存在它会抛出错误\n* 它给新的电子表格标题前加了“Copy of”\n\n你可能没有注意到（如果你注意到了，那就太好了！）这个函数也意外地改变了原始电子表格的标题。\n\n每个程序员每天都会遇到这样的错误。但是现在你知道bug存在了，你会换种方式读代码吗？如果你一直在使用“快”模式阅读代码，则很可能会切换到更费劲的“慢”模式来查找他。\n\n在“快”模式下，我们通过名字、注释和它总体的结构猜测代码干了什么。而在“慢”模式下，我们逐步追溯代码做了什么。\n\n这就是为什么正确的思维模式非常重要。在我们的脑海中模拟一台计算机已经够难了——而这种努力被错误的思维模式所浪费。\n\n如果你根本找不到bug，别担心，这意味着你会从这门课中得到最大的收获！在接下来的模块中，我们将一起重塑JavaScript的思维模型，以便你一目了然地看到bug。\n\n在下一个模块，我们将开始为一些最基本的JavaScript概念（值和变量）构建思维模型。\n","source":"_posts/《Just-JavaScript》01-思维模型.md","raw":"---\ntitle: 《Just JavaScript》01. 思维模型\ndate: 2020-03-28 21:40:45\ntags: JavaScript\n---\n\n读以下代码：\n\n``` javascript\nlet a = 10;\nlet b = a;\na = 0;\n```\n\n当他们运行后a和b的值是多少？在你往下阅读之前，先在你的脑子中想出答案。\n\n如果你已经写了一段时间的JavaScript，你可能会想：“这比我每天写的代码简单多了，意义何在？”\n\n这个练习的目标不是向你介绍变量，我们认为你已经对这些很熟悉了。相反的，它是为了让你注意并反思你的思维模型。\n\n## 什么是思维模型\n\n再次阅读上面的代码，目的是真正确定结果是什么。（我们稍后看为什么这个目的很重要）\n\n当你第二次读它的时候，一步步地注意你脑子里发生的事，你可能会有这样的独白：\n\n``` javascript\n// 1.声明一个变量a,并给它赋值10\nlet a = 10;\n// 2.声明一个变量b,将a的值赋给它,a为10,所以b也为10\nlet b = a;\n// 3.将0赋给a\na = 0;\n// 4.所以最后的答案是a的值为0，b的值为10\n```\n\n可能你脑中想的会有点不一样，可能你想的是给a设置值而不是赋值，或者你可能用不同的顺序读它。甚至你最后得出了不同的结果。注意一下具体哪里不同，即使是这段独白也无法真正捕捉到你脑海中发生的事情。你可能会说“把b设为a”，但是设置一个变量意味着什么呢？\n\n你可能会发现，对每个熟悉的基本编程概念（比如变量）和操作（比如赋值），会有一套根深蒂固的类比与之相关。一些来自于现实的世界，其他的可能会从你最初学到的领域重新运用，比如数学中的数字。这些类比可能会部分重叠甚至矛盾，但是它们仍然帮助你理解在代码中发生了什么。\n\n举个例子，很多人最初把变量当做盒子来学习，你可以往里面放东西。当你看到一个变量的时候，尽管你并没有真正地想象出一个盒子，但是在你的脑海里它们可能仍表现得像一个盒子。这些在你脑海中相似的运作方式被我们称做思维模型。思维模型对编程很久的你来说可能有难度，但是你要尝试注意和反思它们。它们可能是视觉的、空间的和机械的思维捷径的组合。\n\n这些直觉（类似把变量比作盒子）在我们整个编程生涯中会影响我们如何读代码。但是有时候，我们的思维模型是错误的。可能我们早期读过的辅导课为了能简单的解释一些东西而牺牲了它的正确性。也许我们错误的从之前学过的另一种语言转移了关于特定语言特征的直觉。也许我们从某段代码推断出一种思维模型，但从未验证它是否准确。\n\n识别和解决这些问题就是这本书《Just JavaScript》的全部内容。我们将逐步构建（或者，可能的话，重新构建）你关于JavaScript的思维模型，使之准确而有用。一个好的思维模型将会帮助你更快的定位和修复bug，更好的理解别人的代码，对你自己写的代码更自信。\n\n（顺带一提，a的值为0，b的值为10是正确答案）。\n\n## 快慢编码\n\n丹尼尔·卡尼曼的《思考，快与慢》是一本广受欢迎的非小说类书籍。它的中心论点是，人类在思考时使用两种不同的“系统”。\n\n只要有可能，我们就依靠“快速”系统。我们与许多动物共享这个紫铜，这给我们惊人的力量，就像走路时不摔倒一样。这个“快速”系统擅长模式匹配（生存所必需！！）以及“内脏反应”。但是它并不擅长计划。\n\n独特的是，由于额叶的发育，人类也有一个“慢”思维系统。这个“慢”思维系统负责复杂的逐步的推理。它让我们计划未来的事件，参与争论或遵循数学证明。\n\n因为使用“慢”系统在精神上非常消耗，所以我们倾向于默认使用“快”系统，即使在处理诸如编码之类的智能任务时也是如此。\n\n想象你正忙于大量的工作，并且你希望快速识别此函数的功能，快速浏览以下代码：\n\n``` javascript\nfunction duplicateSpreadsheet(original) {\n    if (original.hasPendingChanges) {\n        throw new Error('You need to save the file before you can duplicate it.');\n    }\n    let copy = {\n        created: Date.now(),\n        author: original.author,\n        cells: original.cells,\n        metadata: original.metadata,\n    };\n    copy.metadata.title = 'Copy of ' + original.metadata.title;\n    return copy;\n}\n```\n\n你可能会思考：\n\n* 这个函数复制一个电子表格\n* 如果初始电子表格不存在它会抛出错误\n* 它给新的电子表格标题前加了“Copy of”\n\n你可能没有注意到（如果你注意到了，那就太好了！）这个函数也意外地改变了原始电子表格的标题。\n\n每个程序员每天都会遇到这样的错误。但是现在你知道bug存在了，你会换种方式读代码吗？如果你一直在使用“快”模式阅读代码，则很可能会切换到更费劲的“慢”模式来查找他。\n\n在“快”模式下，我们通过名字、注释和它总体的结构猜测代码干了什么。而在“慢”模式下，我们逐步追溯代码做了什么。\n\n这就是为什么正确的思维模式非常重要。在我们的脑海中模拟一台计算机已经够难了——而这种努力被错误的思维模式所浪费。\n\n如果你根本找不到bug，别担心，这意味着你会从这门课中得到最大的收获！在接下来的模块中，我们将一起重塑JavaScript的思维模型，以便你一目了然地看到bug。\n\n在下一个模块，我们将开始为一些最基本的JavaScript概念（值和变量）构建思维模型。\n","slug":"《Just-JavaScript》01-思维模型","published":1,"updated":"2020-06-03T07:26:22.824Z","_id":"ckaz0p8zn0000s59h484eecox","comments":1,"layout":"post","photos":[],"link":"","content":"<p>读以下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = a;</span><br><span class=\"line\">a = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<p>当他们运行后a和b的值是多少？在你往下阅读之前，先在你的脑子中想出答案。</p>\n<p>如果你已经写了一段时间的JavaScript，你可能会想：“这比我每天写的代码简单多了，意义何在？”</p>\n<p>这个练习的目标不是向你介绍变量，我们认为你已经对这些很熟悉了。相反的，它是为了让你注意并反思你的思维模型。</p>\n<h2 id=\"什么是思维模型\"><a href=\"#什么是思维模型\" class=\"headerlink\" title=\"什么是思维模型\"></a>什么是思维模型</h2><p>再次阅读上面的代码，目的是真正确定结果是什么。（我们稍后看为什么这个目的很重要）</p>\n<p>当你第二次读它的时候，一步步地注意你脑子里发生的事，你可能会有这样的独白：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.声明一个变量a,并给它赋值10</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">// 2.声明一个变量b,将a的值赋给它,a为10,所以b也为10</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = a;</span><br><span class=\"line\"><span class=\"comment\">// 3.将0赋给a</span></span><br><span class=\"line\">a = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">// 4.所以最后的答案是a的值为0，b的值为10</span></span><br></pre></td></tr></table></figure>\n\n<p>可能你脑中想的会有点不一样，可能你想的是给a设置值而不是赋值，或者你可能用不同的顺序读它。甚至你最后得出了不同的结果。注意一下具体哪里不同，即使是这段独白也无法真正捕捉到你脑海中发生的事情。你可能会说“把b设为a”，但是设置一个变量意味着什么呢？</p>\n<p>你可能会发现，对每个熟悉的基本编程概念（比如变量）和操作（比如赋值），会有一套根深蒂固的类比与之相关。一些来自于现实的世界，其他的可能会从你最初学到的领域重新运用，比如数学中的数字。这些类比可能会部分重叠甚至矛盾，但是它们仍然帮助你理解在代码中发生了什么。</p>\n<p>举个例子，很多人最初把变量当做盒子来学习，你可以往里面放东西。当你看到一个变量的时候，尽管你并没有真正地想象出一个盒子，但是在你的脑海里它们可能仍表现得像一个盒子。这些在你脑海中相似的运作方式被我们称做思维模型。思维模型对编程很久的你来说可能有难度，但是你要尝试注意和反思它们。它们可能是视觉的、空间的和机械的思维捷径的组合。</p>\n<p>这些直觉（类似把变量比作盒子）在我们整个编程生涯中会影响我们如何读代码。但是有时候，我们的思维模型是错误的。可能我们早期读过的辅导课为了能简单的解释一些东西而牺牲了它的正确性。也许我们错误的从之前学过的另一种语言转移了关于特定语言特征的直觉。也许我们从某段代码推断出一种思维模型，但从未验证它是否准确。</p>\n<p>识别和解决这些问题就是这本书《Just JavaScript》的全部内容。我们将逐步构建（或者，可能的话，重新构建）你关于JavaScript的思维模型，使之准确而有用。一个好的思维模型将会帮助你更快的定位和修复bug，更好的理解别人的代码，对你自己写的代码更自信。</p>\n<p>（顺带一提，a的值为0，b的值为10是正确答案）。</p>\n<h2 id=\"快慢编码\"><a href=\"#快慢编码\" class=\"headerlink\" title=\"快慢编码\"></a>快慢编码</h2><p>丹尼尔·卡尼曼的《思考，快与慢》是一本广受欢迎的非小说类书籍。它的中心论点是，人类在思考时使用两种不同的“系统”。</p>\n<p>只要有可能，我们就依靠“快速”系统。我们与许多动物共享这个紫铜，这给我们惊人的力量，就像走路时不摔倒一样。这个“快速”系统擅长模式匹配（生存所必需！！）以及“内脏反应”。但是它并不擅长计划。</p>\n<p>独特的是，由于额叶的发育，人类也有一个“慢”思维系统。这个“慢”思维系统负责复杂的逐步的推理。它让我们计划未来的事件，参与争论或遵循数学证明。</p>\n<p>因为使用“慢”系统在精神上非常消耗，所以我们倾向于默认使用“快”系统，即使在处理诸如编码之类的智能任务时也是如此。</p>\n<p>想象你正忙于大量的工作，并且你希望快速识别此函数的功能，快速浏览以下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">duplicateSpreadsheet</span>(<span class=\"params\">original</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (original.hasPendingChanges) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'You need to save the file before you can duplicate it.'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> copy = &#123;</span><br><span class=\"line\">        created: <span class=\"built_in\">Date</span>.now(),</span><br><span class=\"line\">        author: original.author,</span><br><span class=\"line\">        cells: original.cells,</span><br><span class=\"line\">        metadata: original.metadata,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    copy.metadata.title = <span class=\"string\">'Copy of '</span> + original.metadata.title;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> copy;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可能会思考：</p>\n<ul>\n<li>这个函数复制一个电子表格</li>\n<li>如果初始电子表格不存在它会抛出错误</li>\n<li>它给新的电子表格标题前加了“Copy of”</li>\n</ul>\n<p>你可能没有注意到（如果你注意到了，那就太好了！）这个函数也意外地改变了原始电子表格的标题。</p>\n<p>每个程序员每天都会遇到这样的错误。但是现在你知道bug存在了，你会换种方式读代码吗？如果你一直在使用“快”模式阅读代码，则很可能会切换到更费劲的“慢”模式来查找他。</p>\n<p>在“快”模式下，我们通过名字、注释和它总体的结构猜测代码干了什么。而在“慢”模式下，我们逐步追溯代码做了什么。</p>\n<p>这就是为什么正确的思维模式非常重要。在我们的脑海中模拟一台计算机已经够难了——而这种努力被错误的思维模式所浪费。</p>\n<p>如果你根本找不到bug，别担心，这意味着你会从这门课中得到最大的收获！在接下来的模块中，我们将一起重塑JavaScript的思维模型，以便你一目了然地看到bug。</p>\n<p>在下一个模块，我们将开始为一些最基本的JavaScript概念（值和变量）构建思维模型。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>读以下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = a;</span><br><span class=\"line\">a = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<p>当他们运行后a和b的值是多少？在你往下阅读之前，先在你的脑子中想出答案。</p>\n<p>如果你已经写了一段时间的JavaScript，你可能会想：“这比我每天写的代码简单多了，意义何在？”</p>\n<p>这个练习的目标不是向你介绍变量，我们认为你已经对这些很熟悉了。相反的，它是为了让你注意并反思你的思维模型。</p>\n<h2 id=\"什么是思维模型\"><a href=\"#什么是思维模型\" class=\"headerlink\" title=\"什么是思维模型\"></a>什么是思维模型</h2><p>再次阅读上面的代码，目的是真正确定结果是什么。（我们稍后看为什么这个目的很重要）</p>\n<p>当你第二次读它的时候，一步步地注意你脑子里发生的事，你可能会有这样的独白：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.声明一个变量a,并给它赋值10</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">// 2.声明一个变量b,将a的值赋给它,a为10,所以b也为10</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = a;</span><br><span class=\"line\"><span class=\"comment\">// 3.将0赋给a</span></span><br><span class=\"line\">a = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">// 4.所以最后的答案是a的值为0，b的值为10</span></span><br></pre></td></tr></table></figure>\n\n<p>可能你脑中想的会有点不一样，可能你想的是给a设置值而不是赋值，或者你可能用不同的顺序读它。甚至你最后得出了不同的结果。注意一下具体哪里不同，即使是这段独白也无法真正捕捉到你脑海中发生的事情。你可能会说“把b设为a”，但是设置一个变量意味着什么呢？</p>\n<p>你可能会发现，对每个熟悉的基本编程概念（比如变量）和操作（比如赋值），会有一套根深蒂固的类比与之相关。一些来自于现实的世界，其他的可能会从你最初学到的领域重新运用，比如数学中的数字。这些类比可能会部分重叠甚至矛盾，但是它们仍然帮助你理解在代码中发生了什么。</p>\n<p>举个例子，很多人最初把变量当做盒子来学习，你可以往里面放东西。当你看到一个变量的时候，尽管你并没有真正地想象出一个盒子，但是在你的脑海里它们可能仍表现得像一个盒子。这些在你脑海中相似的运作方式被我们称做思维模型。思维模型对编程很久的你来说可能有难度，但是你要尝试注意和反思它们。它们可能是视觉的、空间的和机械的思维捷径的组合。</p>\n<p>这些直觉（类似把变量比作盒子）在我们整个编程生涯中会影响我们如何读代码。但是有时候，我们的思维模型是错误的。可能我们早期读过的辅导课为了能简单的解释一些东西而牺牲了它的正确性。也许我们错误的从之前学过的另一种语言转移了关于特定语言特征的直觉。也许我们从某段代码推断出一种思维模型，但从未验证它是否准确。</p>\n<p>识别和解决这些问题就是这本书《Just JavaScript》的全部内容。我们将逐步构建（或者，可能的话，重新构建）你关于JavaScript的思维模型，使之准确而有用。一个好的思维模型将会帮助你更快的定位和修复bug，更好的理解别人的代码，对你自己写的代码更自信。</p>\n<p>（顺带一提，a的值为0，b的值为10是正确答案）。</p>\n<h2 id=\"快慢编码\"><a href=\"#快慢编码\" class=\"headerlink\" title=\"快慢编码\"></a>快慢编码</h2><p>丹尼尔·卡尼曼的《思考，快与慢》是一本广受欢迎的非小说类书籍。它的中心论点是，人类在思考时使用两种不同的“系统”。</p>\n<p>只要有可能，我们就依靠“快速”系统。我们与许多动物共享这个紫铜，这给我们惊人的力量，就像走路时不摔倒一样。这个“快速”系统擅长模式匹配（生存所必需！！）以及“内脏反应”。但是它并不擅长计划。</p>\n<p>独特的是，由于额叶的发育，人类也有一个“慢”思维系统。这个“慢”思维系统负责复杂的逐步的推理。它让我们计划未来的事件，参与争论或遵循数学证明。</p>\n<p>因为使用“慢”系统在精神上非常消耗，所以我们倾向于默认使用“快”系统，即使在处理诸如编码之类的智能任务时也是如此。</p>\n<p>想象你正忙于大量的工作，并且你希望快速识别此函数的功能，快速浏览以下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">duplicateSpreadsheet</span>(<span class=\"params\">original</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (original.hasPendingChanges) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'You need to save the file before you can duplicate it.'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> copy = &#123;</span><br><span class=\"line\">        created: <span class=\"built_in\">Date</span>.now(),</span><br><span class=\"line\">        author: original.author,</span><br><span class=\"line\">        cells: original.cells,</span><br><span class=\"line\">        metadata: original.metadata,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    copy.metadata.title = <span class=\"string\">'Copy of '</span> + original.metadata.title;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> copy;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可能会思考：</p>\n<ul>\n<li>这个函数复制一个电子表格</li>\n<li>如果初始电子表格不存在它会抛出错误</li>\n<li>它给新的电子表格标题前加了“Copy of”</li>\n</ul>\n<p>你可能没有注意到（如果你注意到了，那就太好了！）这个函数也意外地改变了原始电子表格的标题。</p>\n<p>每个程序员每天都会遇到这样的错误。但是现在你知道bug存在了，你会换种方式读代码吗？如果你一直在使用“快”模式阅读代码，则很可能会切换到更费劲的“慢”模式来查找他。</p>\n<p>在“快”模式下，我们通过名字、注释和它总体的结构猜测代码干了什么。而在“慢”模式下，我们逐步追溯代码做了什么。</p>\n<p>这就是为什么正确的思维模式非常重要。在我们的脑海中模拟一台计算机已经够难了——而这种努力被错误的思维模式所浪费。</p>\n<p>如果你根本找不到bug，别担心，这意味着你会从这门课中得到最大的收获！在接下来的模块中，我们将一起重塑JavaScript的思维模型，以便你一目了然地看到bug。</p>\n<p>在下一个模块，我们将开始为一些最基本的JavaScript概念（值和变量）构建思维模型。</p>\n"},{"title":"《Just JavaScript》04. 计算数值","date":"2020-04-15T10:36:08.000Z","_content":"\n在本模块中，我们将更深入地了解JavaScript世界和其中的值。但在我们开始之前，我们需要先正视这个问题，JavaScript世界是真的吗？\n\n## JavaScript模式\n\n我住在JavaScript宇宙中的小行星上。\n\n当我问JavaScript世界一个问题时，它用一个值来回答我。这所有的值当然不是我一个人提出来的。变量，导线，值——它们都居住在我的世界。我周围的JavaScript世界对我来说是绝对真实的，就像你生活的世界对你来说是真实的一样。\n\n但有时，在下一行代码之前会有片刻的沉默。在下一个函数调用前的空闲时间，\n\n\n\n\n``` javascript\nlet reaction = 'yikes';\nreaction[0] = 'l';\nconsole.log(reaction);\n```\n\n你希望它做什么？我们还没有讲到这个，所以如果你不确定的话没关系。**试着用你目前的JavaScript知识来回答这个问题。**\n\n现在我想让你花点时间，一步一步地为这段代码的每一行写下你确切的思考过程。注意你现有的思维模型中的任何欠缺或不确定性，并把它们也写下来。如果你对此有任何疑问，尽可能清楚地将它表达出来。\n\n![](/blog_imgs/just_javascript/03/spoilers.jpg)\n\n在你写完之前你的思考前不要往下滚动。\n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n答案是这样的。此代码将打印“yikes”或抛出错误，具体取决于你是否处于严格模式。它永远不会印“likes”。\n\n## 原始值是不可改变的\n\n你答对了吗？这可能看起来像一个很小的问题，就像大家在JavaScript面试中问的那种问题，但在实际编码中并没有太多出现。即使如此，它也说明了关于原始值的一个重要特点。\n\n**我不能改变原始值。**\n\n我将使用一个很小的例子来解释这点。字符串（原始值）和数组（非原始值，对象）有一些表面上的相似之处。数组是项的序列，字符串是字符的序列。\n\n``` javascript\nlet arr = [212, 8, 506];\nlet str = 'hello';\n```\n\n你可以访问字符串的第一个字符就像访问数组项那样，几乎感觉字符串就是数组（但它们并不是！）：\n\n``` javascript\nconsole.log(arr[0]); // 212\nconsole.log(str[0]); // \"h\"\n```\n\n你可以改变数组的第一项：\n\n``` javascript\narr[0] = 420;\nconsole.log(arr); // [420, 8, 506]\n```\n\n所以凭直觉来说，很容易假设可以对字符串执行相同的操作：\n\n``` javascript\nstr[0] = 'j'; // ???\n```\n\n**但是你不能这样做。**\n\n这有一点很重要，我们需要添加到我们的思维模型。字符串是原始值，这是十分重要的。\n\n**所有的原始值都是不可改变的。**“Immutable”是拉丁语中一种奇特的说法“unchangeable”。只读的，你根本不能改变原始值。\n\n如果你尝试在一个原始值上设置属性，不管是字符串、数字还是其他什么，JavaScript不会允许你这样做。它是否会默默拒绝你的请求或报错取决于你的代码运行在[哪个模式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode)！\n\n但我向你保证，这永远行不通:\n\n``` javascript\nlet fifty = 50;\nfifty.shades = 'gray'; // No!\n```\n\n就像一些数组，50是一个原始值，你不能给它设置属性。\n\n在我的JavaScript宇宙里面，所有的原始值存在于离我的代码很远的外圆中——就像遥远的恒星。这提醒我，即使我可以从代码中引用它们，也无法更改它们。他们保持原样。\n\n我觉得这异常地令人安慰：\n\n![](/blog_imgs/just_javascript/03/unnamed.png)\n\n## 一个矛盾？\n\n我刚刚演示了原始值是只读的，或者用我们这个时代的话说，是不可变的。这里有一个片段来测试你的思维模型：\n\n``` javascript\nlet pet = 'Narwhal';\npet = 'The Kraken';\nconsole.log(pet); // ?\n```\n\n像以前一样，用几句话写下你的思考过程。别急着往前走。一步一步地关注你对每一行的想法。字符串的不变性在这里起作用吗？它起什么作用？\n\n\b\b![](/blog_imgs/just_javascript/03/spoilers.jpg)\n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n如果你认为我是在捣乱你的大脑，那你完全是对的！答案是“The Kraken”——字符串的不变性不起作用。\n\n如果你错了，不要气馁！最后这两个例子看起来肯定是相互矛盾的。\n\n这是一个很重要的领悟！\n\n当你对一门语言不熟悉时，你可能会倾向于忽略矛盾。毕竟，如果你追逐每一个矛盾，你会深陷入一个兔子洞深而学不到任何东西。\n\n但既然你决定建立思维模型，你就需要质疑矛盾，它们展示出了思维模型的缺口。\n\n## 变量是导线\n\n再看看这些例子：\n\n``` javascript\nlet pet = 'Narwhal';\npet = 'The Kraken';\nconsole.log(pet); // \"The Kraken\"\n```\n\n我们知道字符串不能改变因为它们是原始值。但是pet变量的确变成了“The Kraken”。发生了什么呢？\n\n这似乎是一个矛盾，但事实并非如此。我们只说原始值不能改变。我们对于变量什么都没说！\n\n当我们完善我们的思维模型时候，我们可能需要整理一下相关的概念。\n\n**变量不是值。**\n\n变量指向值。\n\n在我的宇宙，一个变量代表一根导线。它有两端和方向：它从我代码中的一个名字开始，最后指向我宇宙中的某个值。\n\n举个例子，我可以将pet变量指向“Narwhal”值：\n\n``` javascript\nlet pet = 'Narwhal';\n```\n\n\b\b![](/blog_imgs/just_javascript/03/unnamed.gif)\n\n之后可以对变量执行两项操作：\n\n### 给变量赋值\n\n我可以做的一件事是给我的变量赋值：\n\n``` javascript\npet = 'The Kraken';\n```\n\n\b\b![](/blog_imgs/just_javascript/03/unnamed1.gif)\n\n我在这里所做的只是告知JavaScript将左侧的“wire”（我的pet变量）指向右侧的值（“The Kraken”）。它将一直指向那个值，除非我之后重新分配它。\n\n注意，我不能在左边放任何东西：\n\n``` javascript\n'war' = 'peace'; // Nope.(Try it in the console.)\n```\n\n**赋值的左侧必须是导线。**目前，我们只知道变量是“导线”。但是还有另一种“导线”我们将在后面的模块中讨论。也许，你能猜出是什么？（提示：它包含方括号或点，我们已经见过几次了）。\n\n还有另外一条规则。\n\n**赋值的右侧必须是表达式。**它可以是简单的值，比如2或“hello”，也可以是更复杂的表达式：\n\n``` javascript\npet = count + ' Dalmatians';\n```\n\n在这里，count+“Dalmatians”是一个表达式——对JavaScript来说是一个问题。JavaScript将用一个值（例如，“101 Dalmatians”）来回答这个问题。从现在起，pet“导线”将开始指向这个值。\n\n如果右边必须是表达式，这是否意味着像2这样的数字或像用代码编写的'the Kraken'这样的字符串也是表达式？对！这样的表达式称为字面量——因为我们逐字记录它们的值。\n\n### 读取变量的值\n\n我还可以读取变量的值——例如，要记录它：\n\n``` \njavascript\nconsole.log(pet); \n```\n\n这并不奇怪。\n\n但是请注意，我们传递给console.log的不是pet变量。我们可以通俗地说，但是我们不能真的把变量传递给函数。我们传递的是pet变量的当前值。这是怎么工作的呢？\n\n原来，像pet这样的变量名也可以用作表达式！当我们编写pet时，我们在问JavaScript一个问题：“pet的当前价值是什么？”为了回答我们的问题，JavaScript跟随pet的“导线”，并在“导线”的末尾返回值。\n\n所以同一个表达式可以在不同的时间给我们不同的值！\n\n### 名词和动词\n\n谁在乎你说的是“传递变量”还是“传递值”？深究这点差别不是过于卖弄学问吗？我当然不会打断你的同事来纠正他们，甚至是你自己。那将会浪费大家的时间。\n\n但在你的头脑中，你需要清楚地知道你可以用每一个概念做什么。你不能骑自行车溜冰。你不能让鳄梨费气力啊。你不能像蚊子一样发嗖嗖声。而且你不能传递一个变量——至少在JavaScript中不能。\n\n这里有一个小例子说明为什么这些细节很重要。\n\n``` javascript\nfunction double(x) {\n\n    x = x * 2;\n\n}\n\nlet money = 10;\ndouble(money);\nconsole.log(money); // ?\n```\n\n如果我们认为double（money）传递了一个变量，那么我们可以预期x=x*2将使该变量加倍。但事情不是这样的。我们知道double（money）的意思是“计算出货币的价值，然后将其传递给double”。所以答案是10。真是个骗局！\n\n你脑子里有哪些不同的JavaScript名词和动词？他们之间有什么关系？将你最常使用的列一个清单。\n\n### 把它放在一起\n\n现在让我们重温一下来自思维模型的第一个例子：\n\n``` javascript\nlet x = 10;\nlet y = x;\nx = 0;\n```\n\n我建议你拿一张纸或一个绘图应用程序，一步一步地画出x和y变量的“连线”的情况图。\n\n**第一行的作用不大：**\n\n\b\b![](/blog_imgs/just_javascript/03/unnamed2.gif)\n\n* 声明一个x变量  \n  + 为x变量生成导线\n* 给x赋值10\n  + 让x的导线指向10\n\n**第二行很短，但它做了很多事情：**\n\n\b\b![](/blog_imgs/just_javascript/03/unnamed3.gif)\n\n* 声明一个y变量\n  + 为y变量生成导线\n* 把x的值赋给y\n  + 计算表达式：x\n\n    - 我们要回答的问题是“x”\n    - **跟随x的导线——答案是值10**\n\n  + x表达式结果是值10\n  + 因此，将10的值赋给y\n  + 把y的导线指向值10\n\n  **最后，我们进入第三行：**\n\n\b\b![](/blog_imgs/just_javascript/03/unnamed4.gif)\n\n* 将0的值赋给x\n  + 将x的导线指向值0\n\n最后，x变量指向值0，y变量指向值10。注意y=x并不意味着将y指向“x”。我们不能把变量指向彼此！**变量总是指向值**。当我们看到一个赋值时，我们“询问”右边的值，并将左边的“线”指向它。\n\n我在思维模型中提到，把变量看作盒子是相当常见的。我们要建造的宇宙根本就没有盒子。**它只有导线！**这看起来有点烦人。为什么我们不能“将0和10放入变量中，而是将变量指向它们？”\n\n使用导线对于解释许多其他概念将是非常重要的，就像严格的等式，对象标识和变动。我们要坚持使用导线，所以你最好现在就开始习惯。\n\n我的宇宙充满了导线。\n\n## 总结\n\n* **原始值是不可变的：**在我们的代码中，我们无法做任何事情来影响它们或以任何方式更改它们。他们保持原样。例如，不能对字符串值设置属性，因为它是原始值。数组不是原始值，所以我们可以设置它们的属性。\n\n* **变量不是值：**每个变量都指向一个特定的值。我们可以使用=赋值运算符来更改它指向的值。\n\n* **变量就像导线：**“导线”并不是JavaScript的概念——但是它帮助我们理解变量如何指向值。还有一种不同的“电线”，不是变量，但我们还没有讨论过。\n\n* **留意矛盾：**如果你学到的两件事似乎互相矛盾，不要灰心。通常这是一个迹象，表明下面隐藏着更深层次的真相。\n\n* **名词和动词很重要：**我们正在建立一个思维模型，这样我们就能对宇宙中可能发生或不可能发生的事情充满信心。随便马虎的说话是可以的，但我们的思维需要精确。\n\n## 练习\n\n本单元也有练习题供你练习！\n\n[点击这里，通过一些简短的练习巩固这个思维模型。](https://el2.convertkit-mail.com/c/o8u6klng6ncwu4e40piv/6gtehou6oom6de/aHR0cHM6Ly9lZ2doZWFkaW8udHlwZWZvcm0uY29tL3RvL1JXSmczbT9lbWFpbD1ha2loaTk1QGdtYWlsLmNvbQ==)\n\n**不要跳过它们！**\n\n即使你可能熟悉变量的概念，这些练习将帮助你巩固我们正在建立的思维模型。我们需要打好基础才能继续更复杂的话题。\n\n","source":"_posts/《Just-JavaScript》04-计算数值.md","raw":"---\ntitle: 《Just JavaScript》04. 计算数值\ndate: 2020-04-15 18:36:08  \ncategories: JavaScript\ntags:\n\n---\n\n在本模块中，我们将更深入地了解JavaScript世界和其中的值。但在我们开始之前，我们需要先正视这个问题，JavaScript世界是真的吗？\n\n## JavaScript模式\n\n我住在JavaScript宇宙中的小行星上。\n\n当我问JavaScript世界一个问题时，它用一个值来回答我。这所有的值当然不是我一个人提出来的。变量，导线，值——它们都居住在我的世界。我周围的JavaScript世界对我来说是绝对真实的，就像你生活的世界对你来说是真实的一样。\n\n但有时，在下一行代码之前会有片刻的沉默。在下一个函数调用前的空闲时间，\n\n\n\n\n``` javascript\nlet reaction = 'yikes';\nreaction[0] = 'l';\nconsole.log(reaction);\n```\n\n你希望它做什么？我们还没有讲到这个，所以如果你不确定的话没关系。**试着用你目前的JavaScript知识来回答这个问题。**\n\n现在我想让你花点时间，一步一步地为这段代码的每一行写下你确切的思考过程。注意你现有的思维模型中的任何欠缺或不确定性，并把它们也写下来。如果你对此有任何疑问，尽可能清楚地将它表达出来。\n\n![](/blog_imgs/just_javascript/03/spoilers.jpg)\n\n在你写完之前你的思考前不要往下滚动。\n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n答案是这样的。此代码将打印“yikes”或抛出错误，具体取决于你是否处于严格模式。它永远不会印“likes”。\n\n## 原始值是不可改变的\n\n你答对了吗？这可能看起来像一个很小的问题，就像大家在JavaScript面试中问的那种问题，但在实际编码中并没有太多出现。即使如此，它也说明了关于原始值的一个重要特点。\n\n**我不能改变原始值。**\n\n我将使用一个很小的例子来解释这点。字符串（原始值）和数组（非原始值，对象）有一些表面上的相似之处。数组是项的序列，字符串是字符的序列。\n\n``` javascript\nlet arr = [212, 8, 506];\nlet str = 'hello';\n```\n\n你可以访问字符串的第一个字符就像访问数组项那样，几乎感觉字符串就是数组（但它们并不是！）：\n\n``` javascript\nconsole.log(arr[0]); // 212\nconsole.log(str[0]); // \"h\"\n```\n\n你可以改变数组的第一项：\n\n``` javascript\narr[0] = 420;\nconsole.log(arr); // [420, 8, 506]\n```\n\n所以凭直觉来说，很容易假设可以对字符串执行相同的操作：\n\n``` javascript\nstr[0] = 'j'; // ???\n```\n\n**但是你不能这样做。**\n\n这有一点很重要，我们需要添加到我们的思维模型。字符串是原始值，这是十分重要的。\n\n**所有的原始值都是不可改变的。**“Immutable”是拉丁语中一种奇特的说法“unchangeable”。只读的，你根本不能改变原始值。\n\n如果你尝试在一个原始值上设置属性，不管是字符串、数字还是其他什么，JavaScript不会允许你这样做。它是否会默默拒绝你的请求或报错取决于你的代码运行在[哪个模式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode)！\n\n但我向你保证，这永远行不通:\n\n``` javascript\nlet fifty = 50;\nfifty.shades = 'gray'; // No!\n```\n\n就像一些数组，50是一个原始值，你不能给它设置属性。\n\n在我的JavaScript宇宙里面，所有的原始值存在于离我的代码很远的外圆中——就像遥远的恒星。这提醒我，即使我可以从代码中引用它们，也无法更改它们。他们保持原样。\n\n我觉得这异常地令人安慰：\n\n![](/blog_imgs/just_javascript/03/unnamed.png)\n\n## 一个矛盾？\n\n我刚刚演示了原始值是只读的，或者用我们这个时代的话说，是不可变的。这里有一个片段来测试你的思维模型：\n\n``` javascript\nlet pet = 'Narwhal';\npet = 'The Kraken';\nconsole.log(pet); // ?\n```\n\n像以前一样，用几句话写下你的思考过程。别急着往前走。一步一步地关注你对每一行的想法。字符串的不变性在这里起作用吗？它起什么作用？\n\n\b\b![](/blog_imgs/just_javascript/03/spoilers.jpg)\n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n如果你认为我是在捣乱你的大脑，那你完全是对的！答案是“The Kraken”——字符串的不变性不起作用。\n\n如果你错了，不要气馁！最后这两个例子看起来肯定是相互矛盾的。\n\n这是一个很重要的领悟！\n\n当你对一门语言不熟悉时，你可能会倾向于忽略矛盾。毕竟，如果你追逐每一个矛盾，你会深陷入一个兔子洞深而学不到任何东西。\n\n但既然你决定建立思维模型，你就需要质疑矛盾，它们展示出了思维模型的缺口。\n\n## 变量是导线\n\n再看看这些例子：\n\n``` javascript\nlet pet = 'Narwhal';\npet = 'The Kraken';\nconsole.log(pet); // \"The Kraken\"\n```\n\n我们知道字符串不能改变因为它们是原始值。但是pet变量的确变成了“The Kraken”。发生了什么呢？\n\n这似乎是一个矛盾，但事实并非如此。我们只说原始值不能改变。我们对于变量什么都没说！\n\n当我们完善我们的思维模型时候，我们可能需要整理一下相关的概念。\n\n**变量不是值。**\n\n变量指向值。\n\n在我的宇宙，一个变量代表一根导线。它有两端和方向：它从我代码中的一个名字开始，最后指向我宇宙中的某个值。\n\n举个例子，我可以将pet变量指向“Narwhal”值：\n\n``` javascript\nlet pet = 'Narwhal';\n```\n\n\b\b![](/blog_imgs/just_javascript/03/unnamed.gif)\n\n之后可以对变量执行两项操作：\n\n### 给变量赋值\n\n我可以做的一件事是给我的变量赋值：\n\n``` javascript\npet = 'The Kraken';\n```\n\n\b\b![](/blog_imgs/just_javascript/03/unnamed1.gif)\n\n我在这里所做的只是告知JavaScript将左侧的“wire”（我的pet变量）指向右侧的值（“The Kraken”）。它将一直指向那个值，除非我之后重新分配它。\n\n注意，我不能在左边放任何东西：\n\n``` javascript\n'war' = 'peace'; // Nope.(Try it in the console.)\n```\n\n**赋值的左侧必须是导线。**目前，我们只知道变量是“导线”。但是还有另一种“导线”我们将在后面的模块中讨论。也许，你能猜出是什么？（提示：它包含方括号或点，我们已经见过几次了）。\n\n还有另外一条规则。\n\n**赋值的右侧必须是表达式。**它可以是简单的值，比如2或“hello”，也可以是更复杂的表达式：\n\n``` javascript\npet = count + ' Dalmatians';\n```\n\n在这里，count+“Dalmatians”是一个表达式——对JavaScript来说是一个问题。JavaScript将用一个值（例如，“101 Dalmatians”）来回答这个问题。从现在起，pet“导线”将开始指向这个值。\n\n如果右边必须是表达式，这是否意味着像2这样的数字或像用代码编写的'the Kraken'这样的字符串也是表达式？对！这样的表达式称为字面量——因为我们逐字记录它们的值。\n\n### 读取变量的值\n\n我还可以读取变量的值——例如，要记录它：\n\n``` \njavascript\nconsole.log(pet); \n```\n\n这并不奇怪。\n\n但是请注意，我们传递给console.log的不是pet变量。我们可以通俗地说，但是我们不能真的把变量传递给函数。我们传递的是pet变量的当前值。这是怎么工作的呢？\n\n原来，像pet这样的变量名也可以用作表达式！当我们编写pet时，我们在问JavaScript一个问题：“pet的当前价值是什么？”为了回答我们的问题，JavaScript跟随pet的“导线”，并在“导线”的末尾返回值。\n\n所以同一个表达式可以在不同的时间给我们不同的值！\n\n### 名词和动词\n\n谁在乎你说的是“传递变量”还是“传递值”？深究这点差别不是过于卖弄学问吗？我当然不会打断你的同事来纠正他们，甚至是你自己。那将会浪费大家的时间。\n\n但在你的头脑中，你需要清楚地知道你可以用每一个概念做什么。你不能骑自行车溜冰。你不能让鳄梨费气力啊。你不能像蚊子一样发嗖嗖声。而且你不能传递一个变量——至少在JavaScript中不能。\n\n这里有一个小例子说明为什么这些细节很重要。\n\n``` javascript\nfunction double(x) {\n\n    x = x * 2;\n\n}\n\nlet money = 10;\ndouble(money);\nconsole.log(money); // ?\n```\n\n如果我们认为double（money）传递了一个变量，那么我们可以预期x=x*2将使该变量加倍。但事情不是这样的。我们知道double（money）的意思是“计算出货币的价值，然后将其传递给double”。所以答案是10。真是个骗局！\n\n你脑子里有哪些不同的JavaScript名词和动词？他们之间有什么关系？将你最常使用的列一个清单。\n\n### 把它放在一起\n\n现在让我们重温一下来自思维模型的第一个例子：\n\n``` javascript\nlet x = 10;\nlet y = x;\nx = 0;\n```\n\n我建议你拿一张纸或一个绘图应用程序，一步一步地画出x和y变量的“连线”的情况图。\n\n**第一行的作用不大：**\n\n\b\b![](/blog_imgs/just_javascript/03/unnamed2.gif)\n\n* 声明一个x变量  \n  + 为x变量生成导线\n* 给x赋值10\n  + 让x的导线指向10\n\n**第二行很短，但它做了很多事情：**\n\n\b\b![](/blog_imgs/just_javascript/03/unnamed3.gif)\n\n* 声明一个y变量\n  + 为y变量生成导线\n* 把x的值赋给y\n  + 计算表达式：x\n\n    - 我们要回答的问题是“x”\n    - **跟随x的导线——答案是值10**\n\n  + x表达式结果是值10\n  + 因此，将10的值赋给y\n  + 把y的导线指向值10\n\n  **最后，我们进入第三行：**\n\n\b\b![](/blog_imgs/just_javascript/03/unnamed4.gif)\n\n* 将0的值赋给x\n  + 将x的导线指向值0\n\n最后，x变量指向值0，y变量指向值10。注意y=x并不意味着将y指向“x”。我们不能把变量指向彼此！**变量总是指向值**。当我们看到一个赋值时，我们“询问”右边的值，并将左边的“线”指向它。\n\n我在思维模型中提到，把变量看作盒子是相当常见的。我们要建造的宇宙根本就没有盒子。**它只有导线！**这看起来有点烦人。为什么我们不能“将0和10放入变量中，而是将变量指向它们？”\n\n使用导线对于解释许多其他概念将是非常重要的，就像严格的等式，对象标识和变动。我们要坚持使用导线，所以你最好现在就开始习惯。\n\n我的宇宙充满了导线。\n\n## 总结\n\n* **原始值是不可变的：**在我们的代码中，我们无法做任何事情来影响它们或以任何方式更改它们。他们保持原样。例如，不能对字符串值设置属性，因为它是原始值。数组不是原始值，所以我们可以设置它们的属性。\n\n* **变量不是值：**每个变量都指向一个特定的值。我们可以使用=赋值运算符来更改它指向的值。\n\n* **变量就像导线：**“导线”并不是JavaScript的概念——但是它帮助我们理解变量如何指向值。还有一种不同的“电线”，不是变量，但我们还没有讨论过。\n\n* **留意矛盾：**如果你学到的两件事似乎互相矛盾，不要灰心。通常这是一个迹象，表明下面隐藏着更深层次的真相。\n\n* **名词和动词很重要：**我们正在建立一个思维模型，这样我们就能对宇宙中可能发生或不可能发生的事情充满信心。随便马虎的说话是可以的，但我们的思维需要精确。\n\n## 练习\n\n本单元也有练习题供你练习！\n\n[点击这里，通过一些简短的练习巩固这个思维模型。](https://el2.convertkit-mail.com/c/o8u6klng6ncwu4e40piv/6gtehou6oom6de/aHR0cHM6Ly9lZ2doZWFkaW8udHlwZWZvcm0uY29tL3RvL1JXSmczbT9lbWFpbD1ha2loaTk1QGdtYWlsLmNvbQ==)\n\n**不要跳过它们！**\n\n即使你可能熟悉变量的概念，这些练习将帮助你巩固我们正在建立的思维模型。我们需要打好基础才能继续更复杂的话题。\n\n","slug":"《Just-JavaScript》04-计算数值","published":1,"updated":"2020-06-03T07:14:49.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckaz13gpf0000gq9he9kbgthq","content":"<p>在本模块中，我们将更深入地了解JavaScript世界和其中的值。但在我们开始之前，我们需要先正视这个问题，JavaScript世界是真的吗？</p>\n<h2 id=\"JavaScript模式\"><a href=\"#JavaScript模式\" class=\"headerlink\" title=\"JavaScript模式\"></a>JavaScript模式</h2><p>我住在JavaScript宇宙中的小行星上。</p>\n<p>当我问JavaScript世界一个问题时，它用一个值来回答我。这所有的值当然不是我一个人提出来的。变量，导线，值——它们都居住在我的世界。我周围的JavaScript世界对我来说是绝对真实的，就像你生活的世界对你来说是真实的一样。</p>\n<p>但有时，在下一行代码之前会有片刻的沉默。在下一个函数调用前的空闲时间，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> reaction = <span class=\"string\">'yikes'</span>;</span><br><span class=\"line\">reaction[<span class=\"number\">0</span>] = <span class=\"string\">'l'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reaction);</span><br></pre></td></tr></table></figure>\n\n<p>你希望它做什么？我们还没有讲到这个，所以如果你不确定的话没关系。<strong>试着用你目前的JavaScript知识来回答这个问题。</strong></p>\n<p>现在我想让你花点时间，一步一步地为这段代码的每一行写下你确切的思考过程。注意你现有的思维模型中的任何欠缺或不确定性，并把它们也写下来。如果你对此有任何疑问，尽可能清楚地将它表达出来。</p>\n<p><img src=\"/blog_imgs/just_javascript/03/spoilers.jpg\" alt=\"\"></p>\n<p>在你写完之前你的思考前不要往下滚动。</p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p>答案是这样的。此代码将打印“yikes”或抛出错误，具体取决于你是否处于严格模式。它永远不会印“likes”。</p>\n<h2 id=\"原始值是不可改变的\"><a href=\"#原始值是不可改变的\" class=\"headerlink\" title=\"原始值是不可改变的\"></a>原始值是不可改变的</h2><p>你答对了吗？这可能看起来像一个很小的问题，就像大家在JavaScript面试中问的那种问题，但在实际编码中并没有太多出现。即使如此，它也说明了关于原始值的一个重要特点。</p>\n<p><strong>我不能改变原始值。</strong></p>\n<p>我将使用一个很小的例子来解释这点。字符串（原始值）和数组（非原始值，对象）有一些表面上的相似之处。数组是项的序列，字符串是字符的序列。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">212</span>, <span class=\"number\">8</span>, <span class=\"number\">506</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">'hello'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>你可以访问字符串的第一个字符就像访问数组项那样，几乎感觉字符串就是数组（但它们并不是！）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(arr[<span class=\"number\">0</span>]); <span class=\"comment\">// 212</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str[<span class=\"number\">0</span>]); <span class=\"comment\">// \"h\"</span></span><br></pre></td></tr></table></figure>\n\n<p>你可以改变数组的第一项：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"number\">420</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [420, 8, 506]</span></span><br></pre></td></tr></table></figure>\n\n<p>所以凭直觉来说，很容易假设可以对字符串执行相同的操作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str[<span class=\"number\">0</span>] = <span class=\"string\">'j'</span>; <span class=\"comment\">// ???</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>但是你不能这样做。</strong></p>\n<p>这有一点很重要，我们需要添加到我们的思维模型。字符串是原始值，这是十分重要的。</p>\n<p><strong>所有的原始值都是不可改变的。</strong>“Immutable”是拉丁语中一种奇特的说法“unchangeable”。只读的，你根本不能改变原始值。</p>\n<p>如果你尝试在一个原始值上设置属性，不管是字符串、数字还是其他什么，JavaScript不会允许你这样做。它是否会默默拒绝你的请求或报错取决于你的代码运行在<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode\" target=\"_blank\" rel=\"noopener\">哪个模式</a>！</p>\n<p>但我向你保证，这永远行不通:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> fifty = <span class=\"number\">50</span>;</span><br><span class=\"line\">fifty.shades = <span class=\"string\">'gray'</span>; <span class=\"comment\">// No!</span></span><br></pre></td></tr></table></figure>\n\n<p>就像一些数组，50是一个原始值，你不能给它设置属性。</p>\n<p>在我的JavaScript宇宙里面，所有的原始值存在于离我的代码很远的外圆中——就像遥远的恒星。这提醒我，即使我可以从代码中引用它们，也无法更改它们。他们保持原样。</p>\n<p>我觉得这异常地令人安慰：</p>\n<p><img src=\"/blog_imgs/just_javascript/03/unnamed.png\" alt=\"\"></p>\n<h2 id=\"一个矛盾？\"><a href=\"#一个矛盾？\" class=\"headerlink\" title=\"一个矛盾？\"></a>一个矛盾？</h2><p>我刚刚演示了原始值是只读的，或者用我们这个时代的话说，是不可变的。这里有一个片段来测试你的思维模型：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> pet = <span class=\"string\">'Narwhal'</span>;</span><br><span class=\"line\">pet = <span class=\"string\">'The Kraken'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(pet); <span class=\"comment\">// ?</span></span><br></pre></td></tr></table></figure>\n\n<p>像以前一样，用几句话写下你的思考过程。别急着往前走。一步一步地关注你对每一行的想法。字符串的不变性在这里起作用吗？它起什么作用？</p>\n<p>\b\b<img src=\"/blog_imgs/just_javascript/03/spoilers.jpg\" alt=\"\"></p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p>如果你认为我是在捣乱你的大脑，那你完全是对的！答案是“The Kraken”——字符串的不变性不起作用。</p>\n<p>如果你错了，不要气馁！最后这两个例子看起来肯定是相互矛盾的。</p>\n<p>这是一个很重要的领悟！</p>\n<p>当你对一门语言不熟悉时，你可能会倾向于忽略矛盾。毕竟，如果你追逐每一个矛盾，你会深陷入一个兔子洞深而学不到任何东西。</p>\n<p>但既然你决定建立思维模型，你就需要质疑矛盾，它们展示出了思维模型的缺口。</p>\n<h2 id=\"变量是导线\"><a href=\"#变量是导线\" class=\"headerlink\" title=\"变量是导线\"></a>变量是导线</h2><p>再看看这些例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> pet = <span class=\"string\">'Narwhal'</span>;</span><br><span class=\"line\">pet = <span class=\"string\">'The Kraken'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(pet); <span class=\"comment\">// \"The Kraken\"</span></span><br></pre></td></tr></table></figure>\n\n<p>我们知道字符串不能改变因为它们是原始值。但是pet变量的确变成了“The Kraken”。发生了什么呢？</p>\n<p>这似乎是一个矛盾，但事实并非如此。我们只说原始值不能改变。我们对于变量什么都没说！</p>\n<p>当我们完善我们的思维模型时候，我们可能需要整理一下相关的概念。</p>\n<p><strong>变量不是值。</strong></p>\n<p>变量指向值。</p>\n<p>在我的宇宙，一个变量代表一根导线。它有两端和方向：它从我代码中的一个名字开始，最后指向我宇宙中的某个值。</p>\n<p>举个例子，我可以将pet变量指向“Narwhal”值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> pet = <span class=\"string\">'Narwhal'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>\b\b<img src=\"/blog_imgs/just_javascript/03/unnamed.gif\" alt=\"\"></p>\n<p>之后可以对变量执行两项操作：</p>\n<h3 id=\"给变量赋值\"><a href=\"#给变量赋值\" class=\"headerlink\" title=\"给变量赋值\"></a>给变量赋值</h3><p>我可以做的一件事是给我的变量赋值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pet = <span class=\"string\">'The Kraken'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>\b\b<img src=\"/blog_imgs/just_javascript/03/unnamed1.gif\" alt=\"\"></p>\n<p>我在这里所做的只是告知JavaScript将左侧的“wire”（我的pet变量）指向右侧的值（“The Kraken”）。它将一直指向那个值，除非我之后重新分配它。</p>\n<p>注意，我不能在左边放任何东西：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'war'</span> = <span class=\"string\">'peace'</span>; <span class=\"comment\">// Nope.(Try it in the console.)</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>赋值的左侧必须是导线。</strong>目前，我们只知道变量是“导线”。但是还有另一种“导线”我们将在后面的模块中讨论。也许，你能猜出是什么？（提示：它包含方括号或点，我们已经见过几次了）。</p>\n<p>还有另外一条规则。</p>\n<p><strong>赋值的右侧必须是表达式。</strong>它可以是简单的值，比如2或“hello”，也可以是更复杂的表达式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pet = count + <span class=\"string\">' Dalmatians'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，count+“Dalmatians”是一个表达式——对JavaScript来说是一个问题。JavaScript将用一个值（例如，“101 Dalmatians”）来回答这个问题。从现在起，pet“导线”将开始指向这个值。</p>\n<p>如果右边必须是表达式，这是否意味着像2这样的数字或像用代码编写的’the Kraken’这样的字符串也是表达式？对！这样的表达式称为字面量——因为我们逐字记录它们的值。</p>\n<h3 id=\"读取变量的值\"><a href=\"#读取变量的值\" class=\"headerlink\" title=\"读取变量的值\"></a>读取变量的值</h3><p>我还可以读取变量的值——例如，要记录它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javascript</span><br><span class=\"line\">console.log(pet);</span><br></pre></td></tr></table></figure>\n\n<p>这并不奇怪。</p>\n<p>但是请注意，我们传递给console.log的不是pet变量。我们可以通俗地说，但是我们不能真的把变量传递给函数。我们传递的是pet变量的当前值。这是怎么工作的呢？</p>\n<p>原来，像pet这样的变量名也可以用作表达式！当我们编写pet时，我们在问JavaScript一个问题：“pet的当前价值是什么？”为了回答我们的问题，JavaScript跟随pet的“导线”，并在“导线”的末尾返回值。</p>\n<p>所以同一个表达式可以在不同的时间给我们不同的值！</p>\n<h3 id=\"名词和动词\"><a href=\"#名词和动词\" class=\"headerlink\" title=\"名词和动词\"></a>名词和动词</h3><p>谁在乎你说的是“传递变量”还是“传递值”？深究这点差别不是过于卖弄学问吗？我当然不会打断你的同事来纠正他们，甚至是你自己。那将会浪费大家的时间。</p>\n<p>但在你的头脑中，你需要清楚地知道你可以用每一个概念做什么。你不能骑自行车溜冰。你不能让鳄梨费气力啊。你不能像蚊子一样发嗖嗖声。而且你不能传递一个变量——至少在JavaScript中不能。</p>\n<p>这里有一个小例子说明为什么这些细节很重要。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">double</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    x = x * <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> money = <span class=\"number\">10</span>;</span><br><span class=\"line\">double(money);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(money); <span class=\"comment\">// ?</span></span><br></pre></td></tr></table></figure>\n\n<p>如果我们认为double（money）传递了一个变量，那么我们可以预期x=x*2将使该变量加倍。但事情不是这样的。我们知道double（money）的意思是“计算出货币的价值，然后将其传递给double”。所以答案是10。真是个骗局！</p>\n<p>你脑子里有哪些不同的JavaScript名词和动词？他们之间有什么关系？将你最常使用的列一个清单。</p>\n<h3 id=\"把它放在一起\"><a href=\"#把它放在一起\" class=\"headerlink\" title=\"把它放在一起\"></a>把它放在一起</h3><p>现在让我们重温一下来自思维模型的第一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y = x;</span><br><span class=\"line\">x = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<p>我建议你拿一张纸或一个绘图应用程序，一步一步地画出x和y变量的“连线”的情况图。</p>\n<p><strong>第一行的作用不大：</strong></p>\n<p>\b\b<img src=\"/blog_imgs/just_javascript/03/unnamed2.gif\" alt=\"\"></p>\n<ul>\n<li>声明一个x变量  <ul>\n<li>为x变量生成导线</li>\n</ul>\n</li>\n<li>给x赋值10<ul>\n<li>让x的导线指向10</li>\n</ul>\n</li>\n</ul>\n<p><strong>第二行很短，但它做了很多事情：</strong></p>\n<p>\b\b<img src=\"/blog_imgs/just_javascript/03/unnamed3.gif\" alt=\"\"></p>\n<ul>\n<li><p>声明一个y变量</p>\n<ul>\n<li>为y变量生成导线</li>\n</ul>\n</li>\n<li><p>把x的值赋给y</p>\n<ul>\n<li><p>计算表达式：x</p>\n<ul>\n<li>我们要回答的问题是“x”</li>\n<li><strong>跟随x的导线——答案是值10</strong></li>\n</ul>\n</li>\n<li><p>x表达式结果是值10</p>\n</li>\n<li><p>因此，将10的值赋给y</p>\n</li>\n<li><p>把y的导线指向值10</p>\n</li>\n</ul>\n<p><strong>最后，我们进入第三行：</strong></p>\n</li>\n</ul>\n<p>\b\b<img src=\"/blog_imgs/just_javascript/03/unnamed4.gif\" alt=\"\"></p>\n<ul>\n<li>将0的值赋给x<ul>\n<li>将x的导线指向值0</li>\n</ul>\n</li>\n</ul>\n<p>最后，x变量指向值0，y变量指向值10。注意y=x并不意味着将y指向“x”。我们不能把变量指向彼此！<strong>变量总是指向值</strong>。当我们看到一个赋值时，我们“询问”右边的值，并将左边的“线”指向它。</p>\n<p>我在思维模型中提到，把变量看作盒子是相当常见的。我们要建造的宇宙根本就没有盒子。<strong>它只有导线！</strong>这看起来有点烦人。为什么我们不能“将0和10放入变量中，而是将变量指向它们？”</p>\n<p>使用导线对于解释许多其他概念将是非常重要的，就像严格的等式，对象标识和变动。我们要坚持使用导线，所以你最好现在就开始习惯。</p>\n<p>我的宇宙充满了导线。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li><p><strong>原始值是不可变的：</strong>在我们的代码中，我们无法做任何事情来影响它们或以任何方式更改它们。他们保持原样。例如，不能对字符串值设置属性，因为它是原始值。数组不是原始值，所以我们可以设置它们的属性。</p>\n</li>\n<li><p><strong>变量不是值：</strong>每个变量都指向一个特定的值。我们可以使用=赋值运算符来更改它指向的值。</p>\n</li>\n<li><p><strong>变量就像导线：</strong>“导线”并不是JavaScript的概念——但是它帮助我们理解变量如何指向值。还有一种不同的“电线”，不是变量，但我们还没有讨论过。</p>\n</li>\n<li><p><strong>留意矛盾：</strong>如果你学到的两件事似乎互相矛盾，不要灰心。通常这是一个迹象，表明下面隐藏着更深层次的真相。</p>\n</li>\n<li><p><strong>名词和动词很重要：</strong>我们正在建立一个思维模型，这样我们就能对宇宙中可能发生或不可能发生的事情充满信心。随便马虎的说话是可以的，但我们的思维需要精确。</p>\n</li>\n</ul>\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p>本单元也有练习题供你练习！</p>\n<p><a href=\"https://el2.convertkit-mail.com/c/o8u6klng6ncwu4e40piv/6gtehou6oom6de/aHR0cHM6Ly9lZ2doZWFkaW8udHlwZWZvcm0uY29tL3RvL1JXSmczbT9lbWFpbD1ha2loaTk1QGdtYWlsLmNvbQ==\" target=\"_blank\" rel=\"noopener\">点击这里，通过一些简短的练习巩固这个思维模型。</a></p>\n<p><strong>不要跳过它们！</strong></p>\n<p>即使你可能熟悉变量的概念，这些练习将帮助你巩固我们正在建立的思维模型。我们需要打好基础才能继续更复杂的话题。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在本模块中，我们将更深入地了解JavaScript世界和其中的值。但在我们开始之前，我们需要先正视这个问题，JavaScript世界是真的吗？</p>\n<h2 id=\"JavaScript模式\"><a href=\"#JavaScript模式\" class=\"headerlink\" title=\"JavaScript模式\"></a>JavaScript模式</h2><p>我住在JavaScript宇宙中的小行星上。</p>\n<p>当我问JavaScript世界一个问题时，它用一个值来回答我。这所有的值当然不是我一个人提出来的。变量，导线，值——它们都居住在我的世界。我周围的JavaScript世界对我来说是绝对真实的，就像你生活的世界对你来说是真实的一样。</p>\n<p>但有时，在下一行代码之前会有片刻的沉默。在下一个函数调用前的空闲时间，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> reaction = <span class=\"string\">'yikes'</span>;</span><br><span class=\"line\">reaction[<span class=\"number\">0</span>] = <span class=\"string\">'l'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reaction);</span><br></pre></td></tr></table></figure>\n\n<p>你希望它做什么？我们还没有讲到这个，所以如果你不确定的话没关系。<strong>试着用你目前的JavaScript知识来回答这个问题。</strong></p>\n<p>现在我想让你花点时间，一步一步地为这段代码的每一行写下你确切的思考过程。注意你现有的思维模型中的任何欠缺或不确定性，并把它们也写下来。如果你对此有任何疑问，尽可能清楚地将它表达出来。</p>\n<p><img src=\"/blog_imgs/just_javascript/03/spoilers.jpg\" alt=\"\"></p>\n<p>在你写完之前你的思考前不要往下滚动。</p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p>答案是这样的。此代码将打印“yikes”或抛出错误，具体取决于你是否处于严格模式。它永远不会印“likes”。</p>\n<h2 id=\"原始值是不可改变的\"><a href=\"#原始值是不可改变的\" class=\"headerlink\" title=\"原始值是不可改变的\"></a>原始值是不可改变的</h2><p>你答对了吗？这可能看起来像一个很小的问题，就像大家在JavaScript面试中问的那种问题，但在实际编码中并没有太多出现。即使如此，它也说明了关于原始值的一个重要特点。</p>\n<p><strong>我不能改变原始值。</strong></p>\n<p>我将使用一个很小的例子来解释这点。字符串（原始值）和数组（非原始值，对象）有一些表面上的相似之处。数组是项的序列，字符串是字符的序列。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">212</span>, <span class=\"number\">8</span>, <span class=\"number\">506</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">'hello'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>你可以访问字符串的第一个字符就像访问数组项那样，几乎感觉字符串就是数组（但它们并不是！）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(arr[<span class=\"number\">0</span>]); <span class=\"comment\">// 212</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str[<span class=\"number\">0</span>]); <span class=\"comment\">// \"h\"</span></span><br></pre></td></tr></table></figure>\n\n<p>你可以改变数组的第一项：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"number\">420</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [420, 8, 506]</span></span><br></pre></td></tr></table></figure>\n\n<p>所以凭直觉来说，很容易假设可以对字符串执行相同的操作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str[<span class=\"number\">0</span>] = <span class=\"string\">'j'</span>; <span class=\"comment\">// ???</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>但是你不能这样做。</strong></p>\n<p>这有一点很重要，我们需要添加到我们的思维模型。字符串是原始值，这是十分重要的。</p>\n<p><strong>所有的原始值都是不可改变的。</strong>“Immutable”是拉丁语中一种奇特的说法“unchangeable”。只读的，你根本不能改变原始值。</p>\n<p>如果你尝试在一个原始值上设置属性，不管是字符串、数字还是其他什么，JavaScript不会允许你这样做。它是否会默默拒绝你的请求或报错取决于你的代码运行在<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode\" target=\"_blank\" rel=\"noopener\">哪个模式</a>！</p>\n<p>但我向你保证，这永远行不通:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> fifty = <span class=\"number\">50</span>;</span><br><span class=\"line\">fifty.shades = <span class=\"string\">'gray'</span>; <span class=\"comment\">// No!</span></span><br></pre></td></tr></table></figure>\n\n<p>就像一些数组，50是一个原始值，你不能给它设置属性。</p>\n<p>在我的JavaScript宇宙里面，所有的原始值存在于离我的代码很远的外圆中——就像遥远的恒星。这提醒我，即使我可以从代码中引用它们，也无法更改它们。他们保持原样。</p>\n<p>我觉得这异常地令人安慰：</p>\n<p><img src=\"/blog_imgs/just_javascript/03/unnamed.png\" alt=\"\"></p>\n<h2 id=\"一个矛盾？\"><a href=\"#一个矛盾？\" class=\"headerlink\" title=\"一个矛盾？\"></a>一个矛盾？</h2><p>我刚刚演示了原始值是只读的，或者用我们这个时代的话说，是不可变的。这里有一个片段来测试你的思维模型：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> pet = <span class=\"string\">'Narwhal'</span>;</span><br><span class=\"line\">pet = <span class=\"string\">'The Kraken'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(pet); <span class=\"comment\">// ?</span></span><br></pre></td></tr></table></figure>\n\n<p>像以前一样，用几句话写下你的思考过程。别急着往前走。一步一步地关注你对每一行的想法。字符串的不变性在这里起作用吗？它起什么作用？</p>\n<p>\b\b<img src=\"/blog_imgs/just_javascript/03/spoilers.jpg\" alt=\"\"></p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p>如果你认为我是在捣乱你的大脑，那你完全是对的！答案是“The Kraken”——字符串的不变性不起作用。</p>\n<p>如果你错了，不要气馁！最后这两个例子看起来肯定是相互矛盾的。</p>\n<p>这是一个很重要的领悟！</p>\n<p>当你对一门语言不熟悉时，你可能会倾向于忽略矛盾。毕竟，如果你追逐每一个矛盾，你会深陷入一个兔子洞深而学不到任何东西。</p>\n<p>但既然你决定建立思维模型，你就需要质疑矛盾，它们展示出了思维模型的缺口。</p>\n<h2 id=\"变量是导线\"><a href=\"#变量是导线\" class=\"headerlink\" title=\"变量是导线\"></a>变量是导线</h2><p>再看看这些例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> pet = <span class=\"string\">'Narwhal'</span>;</span><br><span class=\"line\">pet = <span class=\"string\">'The Kraken'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(pet); <span class=\"comment\">// \"The Kraken\"</span></span><br></pre></td></tr></table></figure>\n\n<p>我们知道字符串不能改变因为它们是原始值。但是pet变量的确变成了“The Kraken”。发生了什么呢？</p>\n<p>这似乎是一个矛盾，但事实并非如此。我们只说原始值不能改变。我们对于变量什么都没说！</p>\n<p>当我们完善我们的思维模型时候，我们可能需要整理一下相关的概念。</p>\n<p><strong>变量不是值。</strong></p>\n<p>变量指向值。</p>\n<p>在我的宇宙，一个变量代表一根导线。它有两端和方向：它从我代码中的一个名字开始，最后指向我宇宙中的某个值。</p>\n<p>举个例子，我可以将pet变量指向“Narwhal”值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> pet = <span class=\"string\">'Narwhal'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>\b\b<img src=\"/blog_imgs/just_javascript/03/unnamed.gif\" alt=\"\"></p>\n<p>之后可以对变量执行两项操作：</p>\n<h3 id=\"给变量赋值\"><a href=\"#给变量赋值\" class=\"headerlink\" title=\"给变量赋值\"></a>给变量赋值</h3><p>我可以做的一件事是给我的变量赋值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pet = <span class=\"string\">'The Kraken'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>\b\b<img src=\"/blog_imgs/just_javascript/03/unnamed1.gif\" alt=\"\"></p>\n<p>我在这里所做的只是告知JavaScript将左侧的“wire”（我的pet变量）指向右侧的值（“The Kraken”）。它将一直指向那个值，除非我之后重新分配它。</p>\n<p>注意，我不能在左边放任何东西：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'war'</span> = <span class=\"string\">'peace'</span>; <span class=\"comment\">// Nope.(Try it in the console.)</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>赋值的左侧必须是导线。</strong>目前，我们只知道变量是“导线”。但是还有另一种“导线”我们将在后面的模块中讨论。也许，你能猜出是什么？（提示：它包含方括号或点，我们已经见过几次了）。</p>\n<p>还有另外一条规则。</p>\n<p><strong>赋值的右侧必须是表达式。</strong>它可以是简单的值，比如2或“hello”，也可以是更复杂的表达式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pet = count + <span class=\"string\">' Dalmatians'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，count+“Dalmatians”是一个表达式——对JavaScript来说是一个问题。JavaScript将用一个值（例如，“101 Dalmatians”）来回答这个问题。从现在起，pet“导线”将开始指向这个值。</p>\n<p>如果右边必须是表达式，这是否意味着像2这样的数字或像用代码编写的’the Kraken’这样的字符串也是表达式？对！这样的表达式称为字面量——因为我们逐字记录它们的值。</p>\n<h3 id=\"读取变量的值\"><a href=\"#读取变量的值\" class=\"headerlink\" title=\"读取变量的值\"></a>读取变量的值</h3><p>我还可以读取变量的值——例如，要记录它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javascript</span><br><span class=\"line\">console.log(pet);</span><br></pre></td></tr></table></figure>\n\n<p>这并不奇怪。</p>\n<p>但是请注意，我们传递给console.log的不是pet变量。我们可以通俗地说，但是我们不能真的把变量传递给函数。我们传递的是pet变量的当前值。这是怎么工作的呢？</p>\n<p>原来，像pet这样的变量名也可以用作表达式！当我们编写pet时，我们在问JavaScript一个问题：“pet的当前价值是什么？”为了回答我们的问题，JavaScript跟随pet的“导线”，并在“导线”的末尾返回值。</p>\n<p>所以同一个表达式可以在不同的时间给我们不同的值！</p>\n<h3 id=\"名词和动词\"><a href=\"#名词和动词\" class=\"headerlink\" title=\"名词和动词\"></a>名词和动词</h3><p>谁在乎你说的是“传递变量”还是“传递值”？深究这点差别不是过于卖弄学问吗？我当然不会打断你的同事来纠正他们，甚至是你自己。那将会浪费大家的时间。</p>\n<p>但在你的头脑中，你需要清楚地知道你可以用每一个概念做什么。你不能骑自行车溜冰。你不能让鳄梨费气力啊。你不能像蚊子一样发嗖嗖声。而且你不能传递一个变量——至少在JavaScript中不能。</p>\n<p>这里有一个小例子说明为什么这些细节很重要。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">double</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    x = x * <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> money = <span class=\"number\">10</span>;</span><br><span class=\"line\">double(money);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(money); <span class=\"comment\">// ?</span></span><br></pre></td></tr></table></figure>\n\n<p>如果我们认为double（money）传递了一个变量，那么我们可以预期x=x*2将使该变量加倍。但事情不是这样的。我们知道double（money）的意思是“计算出货币的价值，然后将其传递给double”。所以答案是10。真是个骗局！</p>\n<p>你脑子里有哪些不同的JavaScript名词和动词？他们之间有什么关系？将你最常使用的列一个清单。</p>\n<h3 id=\"把它放在一起\"><a href=\"#把它放在一起\" class=\"headerlink\" title=\"把它放在一起\"></a>把它放在一起</h3><p>现在让我们重温一下来自思维模型的第一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y = x;</span><br><span class=\"line\">x = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<p>我建议你拿一张纸或一个绘图应用程序，一步一步地画出x和y变量的“连线”的情况图。</p>\n<p><strong>第一行的作用不大：</strong></p>\n<p>\b\b<img src=\"/blog_imgs/just_javascript/03/unnamed2.gif\" alt=\"\"></p>\n<ul>\n<li>声明一个x变量  <ul>\n<li>为x变量生成导线</li>\n</ul>\n</li>\n<li>给x赋值10<ul>\n<li>让x的导线指向10</li>\n</ul>\n</li>\n</ul>\n<p><strong>第二行很短，但它做了很多事情：</strong></p>\n<p>\b\b<img src=\"/blog_imgs/just_javascript/03/unnamed3.gif\" alt=\"\"></p>\n<ul>\n<li><p>声明一个y变量</p>\n<ul>\n<li>为y变量生成导线</li>\n</ul>\n</li>\n<li><p>把x的值赋给y</p>\n<ul>\n<li><p>计算表达式：x</p>\n<ul>\n<li>我们要回答的问题是“x”</li>\n<li><strong>跟随x的导线——答案是值10</strong></li>\n</ul>\n</li>\n<li><p>x表达式结果是值10</p>\n</li>\n<li><p>因此，将10的值赋给y</p>\n</li>\n<li><p>把y的导线指向值10</p>\n</li>\n</ul>\n<p><strong>最后，我们进入第三行：</strong></p>\n</li>\n</ul>\n<p>\b\b<img src=\"/blog_imgs/just_javascript/03/unnamed4.gif\" alt=\"\"></p>\n<ul>\n<li>将0的值赋给x<ul>\n<li>将x的导线指向值0</li>\n</ul>\n</li>\n</ul>\n<p>最后，x变量指向值0，y变量指向值10。注意y=x并不意味着将y指向“x”。我们不能把变量指向彼此！<strong>变量总是指向值</strong>。当我们看到一个赋值时，我们“询问”右边的值，并将左边的“线”指向它。</p>\n<p>我在思维模型中提到，把变量看作盒子是相当常见的。我们要建造的宇宙根本就没有盒子。<strong>它只有导线！</strong>这看起来有点烦人。为什么我们不能“将0和10放入变量中，而是将变量指向它们？”</p>\n<p>使用导线对于解释许多其他概念将是非常重要的，就像严格的等式，对象标识和变动。我们要坚持使用导线，所以你最好现在就开始习惯。</p>\n<p>我的宇宙充满了导线。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li><p><strong>原始值是不可变的：</strong>在我们的代码中，我们无法做任何事情来影响它们或以任何方式更改它们。他们保持原样。例如，不能对字符串值设置属性，因为它是原始值。数组不是原始值，所以我们可以设置它们的属性。</p>\n</li>\n<li><p><strong>变量不是值：</strong>每个变量都指向一个特定的值。我们可以使用=赋值运算符来更改它指向的值。</p>\n</li>\n<li><p><strong>变量就像导线：</strong>“导线”并不是JavaScript的概念——但是它帮助我们理解变量如何指向值。还有一种不同的“电线”，不是变量，但我们还没有讨论过。</p>\n</li>\n<li><p><strong>留意矛盾：</strong>如果你学到的两件事似乎互相矛盾，不要灰心。通常这是一个迹象，表明下面隐藏着更深层次的真相。</p>\n</li>\n<li><p><strong>名词和动词很重要：</strong>我们正在建立一个思维模型，这样我们就能对宇宙中可能发生或不可能发生的事情充满信心。随便马虎的说话是可以的，但我们的思维需要精确。</p>\n</li>\n</ul>\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p>本单元也有练习题供你练习！</p>\n<p><a href=\"https://el2.convertkit-mail.com/c/o8u6klng6ncwu4e40piv/6gtehou6oom6de/aHR0cHM6Ly9lZ2doZWFkaW8udHlwZWZvcm0uY29tL3RvL1JXSmczbT9lbWFpbD1ha2loaTk1QGdtYWlsLmNvbQ==\" target=\"_blank\" rel=\"noopener\">点击这里，通过一些简短的练习巩固这个思维模型。</a></p>\n<p><strong>不要跳过它们！</strong></p>\n<p>即使你可能熟悉变量的概念，这些练习将帮助你巩固我们正在建立的思维模型。我们需要打好基础才能继续更复杂的话题。</p>\n"},{"title":"《Just JavaScript》02. JavaScript宇宙","date":"2020-03-31T01:02:26.000Z","_content":"\n在JavaScript中，它的开始就是值。\n\n什么是指？这很难解释。\n\n这就好比问数学中的数字是什么，几何中的点是什么。值就是JavaScript中的类似这样的一个东西。\n\n数字是值，但其他东西也是值，比如对象和函数。但是很多东西，比如if语句或变量声明都不是值。\n\n## 值和代码\n\n为了将我们的JavaScript程序中的所有值与其他值区别开来，我想象一下安东尼画的小王子：\n\n![](/blog_imgs/just_javascript/02/little_prince.jpg)\n\n我站在一颗小行星上——这是我程序的代码。\n\n从表面上看，我看到了if语句和变量声明、逗号、大括号以及可能从JavaScript代码中找到的所有其他东西。\n\n我得代码包括“函数调用”或是“多次执行此操作”甚至“抛出错误”等指令。我一步一步地完成这些指令——在我的小行星上做着差事。\n\n但偶尔我会抬头看看。\n\n在一个晴朗的夜晚，我在JavaScript天空中到了不同的值：booleans、numbers、strings、symbols、functions、objects、null和undefined——天呐！我可以在代码中使用他们，但他们并不存在于代码中。\n\n在我的JavaScript宇宙中，值飘荡在太空。\n\n![](/blog_imgs/just_javascript/02/universe.png)\n\n“等等，”你可能会说，“我一直认为值存在于我的代码里！”。在这里，我请求你的认知发生飞跃性的变化。要想成功构建这样的思维模型，还需要几个模块。[Give It Five Minutes](https://www.jianshu.com/p/9adb15be9ac2)\n\n回到值上面。大体上，这有两种值。\n\n### 原始值\n\n**原始值**包括数字和字符串等。打开浏览器的控制台并使用 `console.log()` 打印以下原始值：\n\n``` javascript\nconsole.log(2)\nconsole.log(\"hello\")\nconsole.log(undefined)\n```\n\n所有的原始值都有一些共同点。**我的代码中没有什么可以影响他们**。这听起来有点模糊，所以我们将在下一个模块中具体探讨这是什么意思。现在，我要说的是，原始值就像星星一样——冰冷而遥远，但在我需要它们的时候总是在那里。\n\n这是第一种值。\n\n### 对象和函数\n\n**对象和函数**也是值，但他们不是原始值。这使他们变得特别。继续在控制台打印一些这样的值：\n\n``` javascript\nconsole.log({})\nconsole.log([])\nconsole.log(x => x * 2)\n```\n\n请注意，浏览器的控制台是如何以不同于原始值的方式显示它们的。有些浏览器可能会在他们前面显示一个箭头，或者单点击它们的时候执行一些特殊的操作。如果你安装了一些不同的浏览器（例如Chrome和Firefox），比较它们是如何可视化对象和函数的。\n\n对象和函数是特殊的，因为我可以从代码中操作它们。举个例子，我可以将它们与其他值连接起来。这也是模糊的——所以我们将在后面的模块中完善这个想法。现在，我可以说，\n如果原始值像遥远的恒星，那么对象和函数更像漂浮在代码附近的岩石。它们离得很近，我才能够操作它们。\n\n这就是第二种值。\n\n你可能有问题。很好。如果你问一个问题，JavaScript世界可能会回答它！当然前提是你知道怎么提问。\n\n## 表达式\n\n但也有很多问题JavaScript无法回答。如果你想知道是向你最好的朋友坦白你的真实感受，还是一直等到你俩变成骷髅，JavaScript不会有多大帮助。\n\n但是JavaScript很乐意回答这样的一些问题。这些问题有一个特殊的名字——表达式。\n\n如果我们“询问”表达式2+2，JavaScript将用4“回答”。\n\n``` javascript\nconsole.log(2 + 2); // 4\n```\n\n**表达式是JavaScript可以回答的问题。JavaScript使用它唯一知道的方式——值，回答表达式。**\n\n![](/blog_imgs/just_javascript/02/expression.gif)\n\n如果“表达式”这个词让你感到困惑，请将其视为一段表示值的代码。你可能会听到人们说2+2“结果”或“得到”4。这些都是说同一件事的不同方式。\n\n我们问JavaScript 2+2，它的答案是4。表达式总是得到一个值。现在我们对表达方式的了解已经足够危险了！\n\n我之前说JavaScript有多种值：numbers、strings、objects等等。我们如何知道每次说的是哪种值呢？\n\n这听起来是个问题。我们敢问吗？\n\n### 检查类型\n\n首先，JavaScript宇宙中的所有值可能看起来都一样——就像天空中的亮点。但是如果你仔细观察，你会发现只有不到十种不同类型的值。相同类型的值的行为方式类似。\n\n如果我们想检查一个值的类型，我们可以用typeof运算符。JavaScript将用一个预先确定的字符串值来回答我们的问题，比如“number”、“string”或“object”。\n\n![](/blog_imgs/just_javascript/02/telescope.png)\n\n下面是一些您可以在浏览器控制台中尝试的示例:\n\n``` javascript\nconsole.log(typeof(2)); // \"number\"\nconsole.log(typeof(\"hello\")); // \"string\"\nconsole.log(typeof(undefined)); // \"undefined\"\n```\n\n这里， `typeof(2)` 是一个表达式，它得到“number”值。\n\n严格的说，typeof不需要使用括号。例如， ` typeof 2` 和 `typeof(2)` 的工作原理是相同的。然而，有时需要括号来避免歧义。如果我们在typeof后面省略了括号，下面的一个例子就会中断。试着猜猜是哪一个：\n\n``` javascript\nconsole.log(typeof({})); // \"object\"\nconsole.log(typeof([])); // \"object\"\nconsole.log(typeof(x => x * 2)); // \"function\"\n```\n\n你可以在浏览器控制台中验证你的猜测。\n\n![](/blog_imgs/just_javascript/02/typeof.gif)\n\n现在再来看看最后三个例子——这次要密切关注它们的结果。你有没有发现这些结果令人惊讶？为什么？\n\n## 值的类型\n\n作为一个有抱负的天文学家，您可能想知道JavaScript宇宙中可以观察到的每一种类型的值。经过将近25年的JavaScript研究，科学家们只发现了9种类型。\n\n### 原始值\n\n* **Undefined**(undefined)，用于无意中丢失的值\n* **Null**(null), 用于故意丢失的值\n* **Booleans**(true or false)，用于逻辑操作\n* **Numbers**(-100, 3.14... )，用于数学计算\n* **Strings**(\"hello\", \"abracadabra\"... )，用于文本\n* **Symbols**(不常见)，用于隐藏实现的细节\n* **BigInts**(不常见、新的)，用于计算大数\n\n### 对象和函数\n\n* **Objects**({}... )，用于分组相关的数据和代码\n* **Functions**( `x => x * 2` ... )，用于引用代码\n\n### 没有别的类型了\n\n你可能会问：“那我使用的别的类型呢？比如数组？”\n\n**在JavaScript中，除了我们刚刚列举的值类型之外，没有其他基本值类型了**。剩下的都是对象！例如，甚至数组、日期和正则表达式基本上都是JavaScript中的对象：\n\n``` javascript\nconsole.log(typeof([])); // \"object\"\nconsole.log(typeof(new Date())); // \"object\"\nconsole.log(typeof(/(hello|goodbye)/)); // \"object\"\n```\n\n“我知道，”你可能会说，“这是因为一切都是对象！”。唉，这是一个流行的都市传说，但事实并非如此。尽管像 `\"hi\".toUpperCase()` 这样的代码使 `\"hi\"` 看起来像一个对象，但这只是一个幻觉。JavaScript会在执行此操作时创建包装器对象，然后立即将其丢弃。\n\n如果这个机制不太好明白也没事。**现在，你只需要记住原始值（如数字和字符串）不是对象。**\n\n## 总结\n\n让我们回顾一下我们目前所知道的：\n\n1. **除了值就是别的**：我们可以将值视为JavaScript雨中中“飘荡”的不同事物。它们不存在于我们的代码中，但我们可以从代码中引用它们。\n2. **有两种值**：它们是原始值，然后是对象和函数。总共有九种不同类型的值，每种类型都有特定的用途，但有些很少使用。\n3. **有些值很孤单**：比如null是Null类型的唯一的值，undefined也是Undefined类型的唯一值。我们之后会学习它，这两个孤独的值在很大程度上就是麻烦制造者。\n4. **我们可以使用表达式提问**：JavaScript将会用值来回答我们。例如，表达式2+2的答案是4。\n\n5.**我们可以通过typeof表达式来检测值的类型**：比如， `typeof(4)` 得到字符串“number”。\n\n## 练习\n\n是时候学以致用了。\n\n即使你已经有了相当丰富的JavaScript经验，也不要跳过练习题！就在几年前，我从其中学到了一些东西。\n\n[点击此处去做练习！](https://eggheadio.typeform.com/to/PLyTKB?email=akihi95@gmail.com&ck_subscriber_id=767004595)\n\n接下来我们将更详细地探讨原始值。我们看看这些不同的类型（比如数字和Null）有什么共同点，并学习相等在JavaScript中意味着什么。\n\n我们还将继续完善我们的思维模型。这部分提供了一个粗略的草图——一个近似值。我们将把焦点放在图片的不同部分，并用更多的细节填充它们，如[渐进式JPEG图像](https://www.liquidweb.com/kb/what-is-a-progressive-jpeg/?ck_subscriber_id=767004595)。\n\n这些看起来是很小的一步，但我们正在为未来的一切奠定基础。我们正在一起构建JavaScript宇宙。\n\n## 知识扩展\n\n1.[The history of “typeof null”](https://2ality.com/2013/10/typeof-null.html)\n\n","source":"_posts/《Just-JavaScript》02-JavaScript宇宙.md","raw":"---\ntitle: 《Just JavaScript》02. JavaScript宇宙\ndate: 2020-03-31 09:02:26\ntags:\n---\n\n在JavaScript中，它的开始就是值。\n\n什么是指？这很难解释。\n\n这就好比问数学中的数字是什么，几何中的点是什么。值就是JavaScript中的类似这样的一个东西。\n\n数字是值，但其他东西也是值，比如对象和函数。但是很多东西，比如if语句或变量声明都不是值。\n\n## 值和代码\n\n为了将我们的JavaScript程序中的所有值与其他值区别开来，我想象一下安东尼画的小王子：\n\n![](/blog_imgs/just_javascript/02/little_prince.jpg)\n\n我站在一颗小行星上——这是我程序的代码。\n\n从表面上看，我看到了if语句和变量声明、逗号、大括号以及可能从JavaScript代码中找到的所有其他东西。\n\n我得代码包括“函数调用”或是“多次执行此操作”甚至“抛出错误”等指令。我一步一步地完成这些指令——在我的小行星上做着差事。\n\n但偶尔我会抬头看看。\n\n在一个晴朗的夜晚，我在JavaScript天空中到了不同的值：booleans、numbers、strings、symbols、functions、objects、null和undefined——天呐！我可以在代码中使用他们，但他们并不存在于代码中。\n\n在我的JavaScript宇宙中，值飘荡在太空。\n\n![](/blog_imgs/just_javascript/02/universe.png)\n\n“等等，”你可能会说，“我一直认为值存在于我的代码里！”。在这里，我请求你的认知发生飞跃性的变化。要想成功构建这样的思维模型，还需要几个模块。[Give It Five Minutes](https://www.jianshu.com/p/9adb15be9ac2)\n\n回到值上面。大体上，这有两种值。\n\n### 原始值\n\n**原始值**包括数字和字符串等。打开浏览器的控制台并使用 `console.log()` 打印以下原始值：\n\n``` javascript\nconsole.log(2)\nconsole.log(\"hello\")\nconsole.log(undefined)\n```\n\n所有的原始值都有一些共同点。**我的代码中没有什么可以影响他们**。这听起来有点模糊，所以我们将在下一个模块中具体探讨这是什么意思。现在，我要说的是，原始值就像星星一样——冰冷而遥远，但在我需要它们的时候总是在那里。\n\n这是第一种值。\n\n### 对象和函数\n\n**对象和函数**也是值，但他们不是原始值。这使他们变得特别。继续在控制台打印一些这样的值：\n\n``` javascript\nconsole.log({})\nconsole.log([])\nconsole.log(x => x * 2)\n```\n\n请注意，浏览器的控制台是如何以不同于原始值的方式显示它们的。有些浏览器可能会在他们前面显示一个箭头，或者单点击它们的时候执行一些特殊的操作。如果你安装了一些不同的浏览器（例如Chrome和Firefox），比较它们是如何可视化对象和函数的。\n\n对象和函数是特殊的，因为我可以从代码中操作它们。举个例子，我可以将它们与其他值连接起来。这也是模糊的——所以我们将在后面的模块中完善这个想法。现在，我可以说，\n如果原始值像遥远的恒星，那么对象和函数更像漂浮在代码附近的岩石。它们离得很近，我才能够操作它们。\n\n这就是第二种值。\n\n你可能有问题。很好。如果你问一个问题，JavaScript世界可能会回答它！当然前提是你知道怎么提问。\n\n## 表达式\n\n但也有很多问题JavaScript无法回答。如果你想知道是向你最好的朋友坦白你的真实感受，还是一直等到你俩变成骷髅，JavaScript不会有多大帮助。\n\n但是JavaScript很乐意回答这样的一些问题。这些问题有一个特殊的名字——表达式。\n\n如果我们“询问”表达式2+2，JavaScript将用4“回答”。\n\n``` javascript\nconsole.log(2 + 2); // 4\n```\n\n**表达式是JavaScript可以回答的问题。JavaScript使用它唯一知道的方式——值，回答表达式。**\n\n![](/blog_imgs/just_javascript/02/expression.gif)\n\n如果“表达式”这个词让你感到困惑，请将其视为一段表示值的代码。你可能会听到人们说2+2“结果”或“得到”4。这些都是说同一件事的不同方式。\n\n我们问JavaScript 2+2，它的答案是4。表达式总是得到一个值。现在我们对表达方式的了解已经足够危险了！\n\n我之前说JavaScript有多种值：numbers、strings、objects等等。我们如何知道每次说的是哪种值呢？\n\n这听起来是个问题。我们敢问吗？\n\n### 检查类型\n\n首先，JavaScript宇宙中的所有值可能看起来都一样——就像天空中的亮点。但是如果你仔细观察，你会发现只有不到十种不同类型的值。相同类型的值的行为方式类似。\n\n如果我们想检查一个值的类型，我们可以用typeof运算符。JavaScript将用一个预先确定的字符串值来回答我们的问题，比如“number”、“string”或“object”。\n\n![](/blog_imgs/just_javascript/02/telescope.png)\n\n下面是一些您可以在浏览器控制台中尝试的示例:\n\n``` javascript\nconsole.log(typeof(2)); // \"number\"\nconsole.log(typeof(\"hello\")); // \"string\"\nconsole.log(typeof(undefined)); // \"undefined\"\n```\n\n这里， `typeof(2)` 是一个表达式，它得到“number”值。\n\n严格的说，typeof不需要使用括号。例如， ` typeof 2` 和 `typeof(2)` 的工作原理是相同的。然而，有时需要括号来避免歧义。如果我们在typeof后面省略了括号，下面的一个例子就会中断。试着猜猜是哪一个：\n\n``` javascript\nconsole.log(typeof({})); // \"object\"\nconsole.log(typeof([])); // \"object\"\nconsole.log(typeof(x => x * 2)); // \"function\"\n```\n\n你可以在浏览器控制台中验证你的猜测。\n\n![](/blog_imgs/just_javascript/02/typeof.gif)\n\n现在再来看看最后三个例子——这次要密切关注它们的结果。你有没有发现这些结果令人惊讶？为什么？\n\n## 值的类型\n\n作为一个有抱负的天文学家，您可能想知道JavaScript宇宙中可以观察到的每一种类型的值。经过将近25年的JavaScript研究，科学家们只发现了9种类型。\n\n### 原始值\n\n* **Undefined**(undefined)，用于无意中丢失的值\n* **Null**(null), 用于故意丢失的值\n* **Booleans**(true or false)，用于逻辑操作\n* **Numbers**(-100, 3.14... )，用于数学计算\n* **Strings**(\"hello\", \"abracadabra\"... )，用于文本\n* **Symbols**(不常见)，用于隐藏实现的细节\n* **BigInts**(不常见、新的)，用于计算大数\n\n### 对象和函数\n\n* **Objects**({}... )，用于分组相关的数据和代码\n* **Functions**( `x => x * 2` ... )，用于引用代码\n\n### 没有别的类型了\n\n你可能会问：“那我使用的别的类型呢？比如数组？”\n\n**在JavaScript中，除了我们刚刚列举的值类型之外，没有其他基本值类型了**。剩下的都是对象！例如，甚至数组、日期和正则表达式基本上都是JavaScript中的对象：\n\n``` javascript\nconsole.log(typeof([])); // \"object\"\nconsole.log(typeof(new Date())); // \"object\"\nconsole.log(typeof(/(hello|goodbye)/)); // \"object\"\n```\n\n“我知道，”你可能会说，“这是因为一切都是对象！”。唉，这是一个流行的都市传说，但事实并非如此。尽管像 `\"hi\".toUpperCase()` 这样的代码使 `\"hi\"` 看起来像一个对象，但这只是一个幻觉。JavaScript会在执行此操作时创建包装器对象，然后立即将其丢弃。\n\n如果这个机制不太好明白也没事。**现在，你只需要记住原始值（如数字和字符串）不是对象。**\n\n## 总结\n\n让我们回顾一下我们目前所知道的：\n\n1. **除了值就是别的**：我们可以将值视为JavaScript雨中中“飘荡”的不同事物。它们不存在于我们的代码中，但我们可以从代码中引用它们。\n2. **有两种值**：它们是原始值，然后是对象和函数。总共有九种不同类型的值，每种类型都有特定的用途，但有些很少使用。\n3. **有些值很孤单**：比如null是Null类型的唯一的值，undefined也是Undefined类型的唯一值。我们之后会学习它，这两个孤独的值在很大程度上就是麻烦制造者。\n4. **我们可以使用表达式提问**：JavaScript将会用值来回答我们。例如，表达式2+2的答案是4。\n\n5.**我们可以通过typeof表达式来检测值的类型**：比如， `typeof(4)` 得到字符串“number”。\n\n## 练习\n\n是时候学以致用了。\n\n即使你已经有了相当丰富的JavaScript经验，也不要跳过练习题！就在几年前，我从其中学到了一些东西。\n\n[点击此处去做练习！](https://eggheadio.typeform.com/to/PLyTKB?email=akihi95@gmail.com&ck_subscriber_id=767004595)\n\n接下来我们将更详细地探讨原始值。我们看看这些不同的类型（比如数字和Null）有什么共同点，并学习相等在JavaScript中意味着什么。\n\n我们还将继续完善我们的思维模型。这部分提供了一个粗略的草图——一个近似值。我们将把焦点放在图片的不同部分，并用更多的细节填充它们，如[渐进式JPEG图像](https://www.liquidweb.com/kb/what-is-a-progressive-jpeg/?ck_subscriber_id=767004595)。\n\n这些看起来是很小的一步，但我们正在为未来的一切奠定基础。我们正在一起构建JavaScript宇宙。\n\n## 知识扩展\n\n1.[The history of “typeof null”](https://2ality.com/2013/10/typeof-null.html)\n\n","slug":"《Just-JavaScript》02-JavaScript宇宙","published":1,"updated":"2020-06-03T07:28:34.826Z","_id":"ckaz13gph0001gq9h8it75jmx","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在JavaScript中，它的开始就是值。</p>\n<p>什么是指？这很难解释。</p>\n<p>这就好比问数学中的数字是什么，几何中的点是什么。值就是JavaScript中的类似这样的一个东西。</p>\n<p>数字是值，但其他东西也是值，比如对象和函数。但是很多东西，比如if语句或变量声明都不是值。</p>\n<h2 id=\"值和代码\"><a href=\"#值和代码\" class=\"headerlink\" title=\"值和代码\"></a>值和代码</h2><p>为了将我们的JavaScript程序中的所有值与其他值区别开来，我想象一下安东尼画的小王子：</p>\n<p><img src=\"/blog_imgs/just_javascript/02/little_prince.jpg\" alt=\"\"></p>\n<p>我站在一颗小行星上——这是我程序的代码。</p>\n<p>从表面上看，我看到了if语句和变量声明、逗号、大括号以及可能从JavaScript代码中找到的所有其他东西。</p>\n<p>我得代码包括“函数调用”或是“多次执行此操作”甚至“抛出错误”等指令。我一步一步地完成这些指令——在我的小行星上做着差事。</p>\n<p>但偶尔我会抬头看看。</p>\n<p>在一个晴朗的夜晚，我在JavaScript天空中到了不同的值：booleans、numbers、strings、symbols、functions、objects、null和undefined——天呐！我可以在代码中使用他们，但他们并不存在于代码中。</p>\n<p>在我的JavaScript宇宙中，值飘荡在太空。</p>\n<p><img src=\"/blog_imgs/just_javascript/02/universe.png\" alt=\"\"></p>\n<p>“等等，”你可能会说，“我一直认为值存在于我的代码里！”。在这里，我请求你的认知发生飞跃性的变化。要想成功构建这样的思维模型，还需要几个模块。<a href=\"https://www.jianshu.com/p/9adb15be9ac2\" target=\"_blank\" rel=\"noopener\">Give It Five Minutes</a></p>\n<p>回到值上面。大体上，这有两种值。</p>\n<h3 id=\"原始值\"><a href=\"#原始值\" class=\"headerlink\" title=\"原始值\"></a>原始值</h3><p><strong>原始值</strong>包括数字和字符串等。打开浏览器的控制台并使用 <code>console.log()</code> 打印以下原始值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello\"</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">undefined</span>)</span><br></pre></td></tr></table></figure>\n\n<p>所有的原始值都有一些共同点。<strong>我的代码中没有什么可以影响他们</strong>。这听起来有点模糊，所以我们将在下一个模块中具体探讨这是什么意思。现在，我要说的是，原始值就像星星一样——冰冷而遥远，但在我需要它们的时候总是在那里。</p>\n<p>这是第一种值。</p>\n<h3 id=\"对象和函数\"><a href=\"#对象和函数\" class=\"headerlink\" title=\"对象和函数\"></a>对象和函数</h3><p><strong>对象和函数</strong>也是值，但他们不是原始值。这使他们变得特别。继续在控制台打印一些这样的值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(&#123;&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([])</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n\n<p>请注意，浏览器的控制台是如何以不同于原始值的方式显示它们的。有些浏览器可能会在他们前面显示一个箭头，或者单点击它们的时候执行一些特殊的操作。如果你安装了一些不同的浏览器（例如Chrome和Firefox），比较它们是如何可视化对象和函数的。</p>\n<p>对象和函数是特殊的，因为我可以从代码中操作它们。举个例子，我可以将它们与其他值连接起来。这也是模糊的——所以我们将在后面的模块中完善这个想法。现在，我可以说，<br>如果原始值像遥远的恒星，那么对象和函数更像漂浮在代码附近的岩石。它们离得很近，我才能够操作它们。</p>\n<p>这就是第二种值。</p>\n<p>你可能有问题。很好。如果你问一个问题，JavaScript世界可能会回答它！当然前提是你知道怎么提问。</p>\n<h2 id=\"表达式\"><a href=\"#表达式\" class=\"headerlink\" title=\"表达式\"></a>表达式</h2><p>但也有很多问题JavaScript无法回答。如果你想知道是向你最好的朋友坦白你的真实感受，还是一直等到你俩变成骷髅，JavaScript不会有多大帮助。</p>\n<p>但是JavaScript很乐意回答这样的一些问题。这些问题有一个特殊的名字——表达式。</p>\n<p>如果我们“询问”表达式2+2，JavaScript将用4“回答”。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span> + <span class=\"number\">2</span>); <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>表达式是JavaScript可以回答的问题。JavaScript使用它唯一知道的方式——值，回答表达式。</strong></p>\n<p><img src=\"/blog_imgs/just_javascript/02/expression.gif\" alt=\"\"></p>\n<p>如果“表达式”这个词让你感到困惑，请将其视为一段表示值的代码。你可能会听到人们说2+2“结果”或“得到”4。这些都是说同一件事的不同方式。</p>\n<p>我们问JavaScript 2+2，它的答案是4。表达式总是得到一个值。现在我们对表达方式的了解已经足够危险了！</p>\n<p>我之前说JavaScript有多种值：numbers、strings、objects等等。我们如何知道每次说的是哪种值呢？</p>\n<p>这听起来是个问题。我们敢问吗？</p>\n<h3 id=\"检查类型\"><a href=\"#检查类型\" class=\"headerlink\" title=\"检查类型\"></a>检查类型</h3><p>首先，JavaScript宇宙中的所有值可能看起来都一样——就像天空中的亮点。但是如果你仔细观察，你会发现只有不到十种不同类型的值。相同类型的值的行为方式类似。</p>\n<p>如果我们想检查一个值的类型，我们可以用typeof运算符。JavaScript将用一个预先确定的字符串值来回答我们的问题，比如“number”、“string”或“object”。</p>\n<p><img src=\"/blog_imgs/just_javascript/02/telescope.png\" alt=\"\"></p>\n<p>下面是一些您可以在浏览器控制台中尝试的示例:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"number\">2</span>)); <span class=\"comment\">// \"number\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"string\">\"hello\"</span>)); <span class=\"comment\">// \"string\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"literal\">undefined</span>)); <span class=\"comment\">// \"undefined\"</span></span><br></pre></td></tr></table></figure>\n\n<p>这里， <code>typeof(2)</code> 是一个表达式，它得到“number”值。</p>\n<p>严格的说，typeof不需要使用括号。例如， <code>typeof 2</code> 和 <code>typeof(2)</code> 的工作原理是相同的。然而，有时需要括号来避免歧义。如果我们在typeof后面省略了括号，下面的一个例子就会中断。试着猜猜是哪一个：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(&#123;&#125;)); <span class=\"comment\">// \"object\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>([])); <span class=\"comment\">// \"object\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * <span class=\"number\">2</span>)); <span class=\"comment\">// \"function\"</span></span><br></pre></td></tr></table></figure>\n\n<p>你可以在浏览器控制台中验证你的猜测。</p>\n<p><img src=\"/blog_imgs/just_javascript/02/typeof.gif\" alt=\"\"></p>\n<p>现在再来看看最后三个例子——这次要密切关注它们的结果。你有没有发现这些结果令人惊讶？为什么？</p>\n<h2 id=\"值的类型\"><a href=\"#值的类型\" class=\"headerlink\" title=\"值的类型\"></a>值的类型</h2><p>作为一个有抱负的天文学家，您可能想知道JavaScript宇宙中可以观察到的每一种类型的值。经过将近25年的JavaScript研究，科学家们只发现了9种类型。</p>\n<h3 id=\"原始值-1\"><a href=\"#原始值-1\" class=\"headerlink\" title=\"原始值\"></a>原始值</h3><ul>\n<li><strong>Undefined</strong>(undefined)，用于无意中丢失的值</li>\n<li><strong>Null</strong>(null), 用于故意丢失的值</li>\n<li><strong>Booleans</strong>(true or false)，用于逻辑操作</li>\n<li><strong>Numbers</strong>(-100, 3.14… )，用于数学计算</li>\n<li><strong>Strings</strong>(“hello”, “abracadabra”… )，用于文本</li>\n<li><strong>Symbols</strong>(不常见)，用于隐藏实现的细节</li>\n<li><strong>BigInts</strong>(不常见、新的)，用于计算大数</li>\n</ul>\n<h3 id=\"对象和函数-1\"><a href=\"#对象和函数-1\" class=\"headerlink\" title=\"对象和函数\"></a>对象和函数</h3><ul>\n<li><strong>Objects</strong>({}… )，用于分组相关的数据和代码</li>\n<li><strong>Functions</strong>( <code>x =&gt; x * 2</code> … )，用于引用代码</li>\n</ul>\n<h3 id=\"没有别的类型了\"><a href=\"#没有别的类型了\" class=\"headerlink\" title=\"没有别的类型了\"></a>没有别的类型了</h3><p>你可能会问：“那我使用的别的类型呢？比如数组？”</p>\n<p><strong>在JavaScript中，除了我们刚刚列举的值类型之外，没有其他基本值类型了</strong>。剩下的都是对象！例如，甚至数组、日期和正则表达式基本上都是JavaScript中的对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>([])); <span class=\"comment\">// \"object\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>())); <span class=\"comment\">// \"object\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"regexp\">/(hello|goodbye)/</span>)); <span class=\"comment\">// \"object\"</span></span><br></pre></td></tr></table></figure>\n\n<p>“我知道，”你可能会说，“这是因为一切都是对象！”。唉，这是一个流行的都市传说，但事实并非如此。尽管像 <code>&quot;hi&quot;.toUpperCase()</code> 这样的代码使 <code>&quot;hi&quot;</code> 看起来像一个对象，但这只是一个幻觉。JavaScript会在执行此操作时创建包装器对象，然后立即将其丢弃。</p>\n<p>如果这个机制不太好明白也没事。<strong>现在，你只需要记住原始值（如数字和字符串）不是对象。</strong></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>让我们回顾一下我们目前所知道的：</p>\n<ol>\n<li><strong>除了值就是别的</strong>：我们可以将值视为JavaScript雨中中“飘荡”的不同事物。它们不存在于我们的代码中，但我们可以从代码中引用它们。</li>\n<li><strong>有两种值</strong>：它们是原始值，然后是对象和函数。总共有九种不同类型的值，每种类型都有特定的用途，但有些很少使用。</li>\n<li><strong>有些值很孤单</strong>：比如null是Null类型的唯一的值，undefined也是Undefined类型的唯一值。我们之后会学习它，这两个孤独的值在很大程度上就是麻烦制造者。</li>\n<li><strong>我们可以使用表达式提问</strong>：JavaScript将会用值来回答我们。例如，表达式2+2的答案是4。</li>\n</ol>\n<p>5.<strong>我们可以通过typeof表达式来检测值的类型</strong>：比如， <code>typeof(4)</code> 得到字符串“number”。</p>\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p>是时候学以致用了。</p>\n<p>即使你已经有了相当丰富的JavaScript经验，也不要跳过练习题！就在几年前，我从其中学到了一些东西。</p>\n<p><a href=\"https://eggheadio.typeform.com/to/PLyTKB?email=akihi95@gmail.com&ck_subscriber_id=767004595\" target=\"_blank\" rel=\"noopener\">点击此处去做练习！</a></p>\n<p>接下来我们将更详细地探讨原始值。我们看看这些不同的类型（比如数字和Null）有什么共同点，并学习相等在JavaScript中意味着什么。</p>\n<p>我们还将继续完善我们的思维模型。这部分提供了一个粗略的草图——一个近似值。我们将把焦点放在图片的不同部分，并用更多的细节填充它们，如<a href=\"https://www.liquidweb.com/kb/what-is-a-progressive-jpeg/?ck_subscriber_id=767004595\" target=\"_blank\" rel=\"noopener\">渐进式JPEG图像</a>。</p>\n<p>这些看起来是很小的一步，但我们正在为未来的一切奠定基础。我们正在一起构建JavaScript宇宙。</p>\n<h2 id=\"知识扩展\"><a href=\"#知识扩展\" class=\"headerlink\" title=\"知识扩展\"></a>知识扩展</h2><p>1.<a href=\"https://2ality.com/2013/10/typeof-null.html\" target=\"_blank\" rel=\"noopener\">The history of “typeof null”</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在JavaScript中，它的开始就是值。</p>\n<p>什么是指？这很难解释。</p>\n<p>这就好比问数学中的数字是什么，几何中的点是什么。值就是JavaScript中的类似这样的一个东西。</p>\n<p>数字是值，但其他东西也是值，比如对象和函数。但是很多东西，比如if语句或变量声明都不是值。</p>\n<h2 id=\"值和代码\"><a href=\"#值和代码\" class=\"headerlink\" title=\"值和代码\"></a>值和代码</h2><p>为了将我们的JavaScript程序中的所有值与其他值区别开来，我想象一下安东尼画的小王子：</p>\n<p><img src=\"/blog_imgs/just_javascript/02/little_prince.jpg\" alt=\"\"></p>\n<p>我站在一颗小行星上——这是我程序的代码。</p>\n<p>从表面上看，我看到了if语句和变量声明、逗号、大括号以及可能从JavaScript代码中找到的所有其他东西。</p>\n<p>我得代码包括“函数调用”或是“多次执行此操作”甚至“抛出错误”等指令。我一步一步地完成这些指令——在我的小行星上做着差事。</p>\n<p>但偶尔我会抬头看看。</p>\n<p>在一个晴朗的夜晚，我在JavaScript天空中到了不同的值：booleans、numbers、strings、symbols、functions、objects、null和undefined——天呐！我可以在代码中使用他们，但他们并不存在于代码中。</p>\n<p>在我的JavaScript宇宙中，值飘荡在太空。</p>\n<p><img src=\"/blog_imgs/just_javascript/02/universe.png\" alt=\"\"></p>\n<p>“等等，”你可能会说，“我一直认为值存在于我的代码里！”。在这里，我请求你的认知发生飞跃性的变化。要想成功构建这样的思维模型，还需要几个模块。<a href=\"https://www.jianshu.com/p/9adb15be9ac2\" target=\"_blank\" rel=\"noopener\">Give It Five Minutes</a></p>\n<p>回到值上面。大体上，这有两种值。</p>\n<h3 id=\"原始值\"><a href=\"#原始值\" class=\"headerlink\" title=\"原始值\"></a>原始值</h3><p><strong>原始值</strong>包括数字和字符串等。打开浏览器的控制台并使用 <code>console.log()</code> 打印以下原始值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello\"</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">undefined</span>)</span><br></pre></td></tr></table></figure>\n\n<p>所有的原始值都有一些共同点。<strong>我的代码中没有什么可以影响他们</strong>。这听起来有点模糊，所以我们将在下一个模块中具体探讨这是什么意思。现在，我要说的是，原始值就像星星一样——冰冷而遥远，但在我需要它们的时候总是在那里。</p>\n<p>这是第一种值。</p>\n<h3 id=\"对象和函数\"><a href=\"#对象和函数\" class=\"headerlink\" title=\"对象和函数\"></a>对象和函数</h3><p><strong>对象和函数</strong>也是值，但他们不是原始值。这使他们变得特别。继续在控制台打印一些这样的值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(&#123;&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([])</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n\n<p>请注意，浏览器的控制台是如何以不同于原始值的方式显示它们的。有些浏览器可能会在他们前面显示一个箭头，或者单点击它们的时候执行一些特殊的操作。如果你安装了一些不同的浏览器（例如Chrome和Firefox），比较它们是如何可视化对象和函数的。</p>\n<p>对象和函数是特殊的，因为我可以从代码中操作它们。举个例子，我可以将它们与其他值连接起来。这也是模糊的——所以我们将在后面的模块中完善这个想法。现在，我可以说，<br>如果原始值像遥远的恒星，那么对象和函数更像漂浮在代码附近的岩石。它们离得很近，我才能够操作它们。</p>\n<p>这就是第二种值。</p>\n<p>你可能有问题。很好。如果你问一个问题，JavaScript世界可能会回答它！当然前提是你知道怎么提问。</p>\n<h2 id=\"表达式\"><a href=\"#表达式\" class=\"headerlink\" title=\"表达式\"></a>表达式</h2><p>但也有很多问题JavaScript无法回答。如果你想知道是向你最好的朋友坦白你的真实感受，还是一直等到你俩变成骷髅，JavaScript不会有多大帮助。</p>\n<p>但是JavaScript很乐意回答这样的一些问题。这些问题有一个特殊的名字——表达式。</p>\n<p>如果我们“询问”表达式2+2，JavaScript将用4“回答”。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span> + <span class=\"number\">2</span>); <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>表达式是JavaScript可以回答的问题。JavaScript使用它唯一知道的方式——值，回答表达式。</strong></p>\n<p><img src=\"/blog_imgs/just_javascript/02/expression.gif\" alt=\"\"></p>\n<p>如果“表达式”这个词让你感到困惑，请将其视为一段表示值的代码。你可能会听到人们说2+2“结果”或“得到”4。这些都是说同一件事的不同方式。</p>\n<p>我们问JavaScript 2+2，它的答案是4。表达式总是得到一个值。现在我们对表达方式的了解已经足够危险了！</p>\n<p>我之前说JavaScript有多种值：numbers、strings、objects等等。我们如何知道每次说的是哪种值呢？</p>\n<p>这听起来是个问题。我们敢问吗？</p>\n<h3 id=\"检查类型\"><a href=\"#检查类型\" class=\"headerlink\" title=\"检查类型\"></a>检查类型</h3><p>首先，JavaScript宇宙中的所有值可能看起来都一样——就像天空中的亮点。但是如果你仔细观察，你会发现只有不到十种不同类型的值。相同类型的值的行为方式类似。</p>\n<p>如果我们想检查一个值的类型，我们可以用typeof运算符。JavaScript将用一个预先确定的字符串值来回答我们的问题，比如“number”、“string”或“object”。</p>\n<p><img src=\"/blog_imgs/just_javascript/02/telescope.png\" alt=\"\"></p>\n<p>下面是一些您可以在浏览器控制台中尝试的示例:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"number\">2</span>)); <span class=\"comment\">// \"number\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"string\">\"hello\"</span>)); <span class=\"comment\">// \"string\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"literal\">undefined</span>)); <span class=\"comment\">// \"undefined\"</span></span><br></pre></td></tr></table></figure>\n\n<p>这里， <code>typeof(2)</code> 是一个表达式，它得到“number”值。</p>\n<p>严格的说，typeof不需要使用括号。例如， <code>typeof 2</code> 和 <code>typeof(2)</code> 的工作原理是相同的。然而，有时需要括号来避免歧义。如果我们在typeof后面省略了括号，下面的一个例子就会中断。试着猜猜是哪一个：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(&#123;&#125;)); <span class=\"comment\">// \"object\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>([])); <span class=\"comment\">// \"object\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * <span class=\"number\">2</span>)); <span class=\"comment\">// \"function\"</span></span><br></pre></td></tr></table></figure>\n\n<p>你可以在浏览器控制台中验证你的猜测。</p>\n<p><img src=\"/blog_imgs/just_javascript/02/typeof.gif\" alt=\"\"></p>\n<p>现在再来看看最后三个例子——这次要密切关注它们的结果。你有没有发现这些结果令人惊讶？为什么？</p>\n<h2 id=\"值的类型\"><a href=\"#值的类型\" class=\"headerlink\" title=\"值的类型\"></a>值的类型</h2><p>作为一个有抱负的天文学家，您可能想知道JavaScript宇宙中可以观察到的每一种类型的值。经过将近25年的JavaScript研究，科学家们只发现了9种类型。</p>\n<h3 id=\"原始值-1\"><a href=\"#原始值-1\" class=\"headerlink\" title=\"原始值\"></a>原始值</h3><ul>\n<li><strong>Undefined</strong>(undefined)，用于无意中丢失的值</li>\n<li><strong>Null</strong>(null), 用于故意丢失的值</li>\n<li><strong>Booleans</strong>(true or false)，用于逻辑操作</li>\n<li><strong>Numbers</strong>(-100, 3.14… )，用于数学计算</li>\n<li><strong>Strings</strong>(“hello”, “abracadabra”… )，用于文本</li>\n<li><strong>Symbols</strong>(不常见)，用于隐藏实现的细节</li>\n<li><strong>BigInts</strong>(不常见、新的)，用于计算大数</li>\n</ul>\n<h3 id=\"对象和函数-1\"><a href=\"#对象和函数-1\" class=\"headerlink\" title=\"对象和函数\"></a>对象和函数</h3><ul>\n<li><strong>Objects</strong>({}… )，用于分组相关的数据和代码</li>\n<li><strong>Functions</strong>( <code>x =&gt; x * 2</code> … )，用于引用代码</li>\n</ul>\n<h3 id=\"没有别的类型了\"><a href=\"#没有别的类型了\" class=\"headerlink\" title=\"没有别的类型了\"></a>没有别的类型了</h3><p>你可能会问：“那我使用的别的类型呢？比如数组？”</p>\n<p><strong>在JavaScript中，除了我们刚刚列举的值类型之外，没有其他基本值类型了</strong>。剩下的都是对象！例如，甚至数组、日期和正则表达式基本上都是JavaScript中的对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>([])); <span class=\"comment\">// \"object\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>())); <span class=\"comment\">// \"object\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"regexp\">/(hello|goodbye)/</span>)); <span class=\"comment\">// \"object\"</span></span><br></pre></td></tr></table></figure>\n\n<p>“我知道，”你可能会说，“这是因为一切都是对象！”。唉，这是一个流行的都市传说，但事实并非如此。尽管像 <code>&quot;hi&quot;.toUpperCase()</code> 这样的代码使 <code>&quot;hi&quot;</code> 看起来像一个对象，但这只是一个幻觉。JavaScript会在执行此操作时创建包装器对象，然后立即将其丢弃。</p>\n<p>如果这个机制不太好明白也没事。<strong>现在，你只需要记住原始值（如数字和字符串）不是对象。</strong></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>让我们回顾一下我们目前所知道的：</p>\n<ol>\n<li><strong>除了值就是别的</strong>：我们可以将值视为JavaScript雨中中“飘荡”的不同事物。它们不存在于我们的代码中，但我们可以从代码中引用它们。</li>\n<li><strong>有两种值</strong>：它们是原始值，然后是对象和函数。总共有九种不同类型的值，每种类型都有特定的用途，但有些很少使用。</li>\n<li><strong>有些值很孤单</strong>：比如null是Null类型的唯一的值，undefined也是Undefined类型的唯一值。我们之后会学习它，这两个孤独的值在很大程度上就是麻烦制造者。</li>\n<li><strong>我们可以使用表达式提问</strong>：JavaScript将会用值来回答我们。例如，表达式2+2的答案是4。</li>\n</ol>\n<p>5.<strong>我们可以通过typeof表达式来检测值的类型</strong>：比如， <code>typeof(4)</code> 得到字符串“number”。</p>\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p>是时候学以致用了。</p>\n<p>即使你已经有了相当丰富的JavaScript经验，也不要跳过练习题！就在几年前，我从其中学到了一些东西。</p>\n<p><a href=\"https://eggheadio.typeform.com/to/PLyTKB?email=akihi95@gmail.com&ck_subscriber_id=767004595\" target=\"_blank\" rel=\"noopener\">点击此处去做练习！</a></p>\n<p>接下来我们将更详细地探讨原始值。我们看看这些不同的类型（比如数字和Null）有什么共同点，并学习相等在JavaScript中意味着什么。</p>\n<p>我们还将继续完善我们的思维模型。这部分提供了一个粗略的草图——一个近似值。我们将把焦点放在图片的不同部分，并用更多的细节填充它们，如<a href=\"https://www.liquidweb.com/kb/what-is-a-progressive-jpeg/?ck_subscriber_id=767004595\" target=\"_blank\" rel=\"noopener\">渐进式JPEG图像</a>。</p>\n<p>这些看起来是很小的一步，但我们正在为未来的一切奠定基础。我们正在一起构建JavaScript宇宙。</p>\n<h2 id=\"知识扩展\"><a href=\"#知识扩展\" class=\"headerlink\" title=\"知识扩展\"></a>知识扩展</h2><p>1.<a href=\"https://2ality.com/2013/10/typeof-null.html\" target=\"_blank\" rel=\"noopener\">The history of “typeof null”</a></p>\n"},{"title":"《Just JavaScript》03. 值和变量","date":"2020-04-01T09:36:08.000Z","_content":"\n我们将以一个小的代码片段开始这个模块。\n\n``` javascript\nlet reaction = 'yikes';\nreaction[0] = 'l';\nconsole.log(reaction);\n```\n\n你希望它做什么？我们还没有讲到这个，所以如果你不确定的话没关系。**试着用你目前的JavaScript知识来回答这个问题。**\n\n现在我想让你花点时间，一步一步地为这段代码的每一行写下你确切的思考过程。注意你现有的思维模型中的任何欠缺或不确定性，并把它们也写下来。如果你对此有任何疑问，尽可能清楚地将它表达出来。\n\n![](/blog_imgs/just_javascript/03/spoilers.jpg)\n\n在你写完之前你的思考前不要往下滚动。\n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n答案是这样的。此代码将打印“yikes”或抛出错误，具体取决于你是否处于严格模式。它永远不会印“likes”。\n\n## 原始值是不可改变的\n\n你答对了吗？这可能看起来像一个很小的问题，就像大家在JavaScript面试中问的那种问题，但在实际编码中并没有太多出现。即使如此，它也说明了关于原始值的一个重要特点。\n\n**我不能改变原始值。**\n\n我将使用一个很小的例子来解释这点。字符串（原始值）和数组（非原始值，对象）有一些表面上的相似之处。数组是项的序列，字符串是字符的序列。\n\n``` javascript\nlet arr = [212, 8, 506];\nlet str = 'hello';\n```\n\n你可以访问字符串的第一个字符就像访问数组项那样，几乎感觉字符串就是数组（但它们并不是！）：\n\n``` javascript\nconsole.log(arr[0]); // 212\nconsole.log(str[0]); // \"h\"\n```\n\n你可以改变数组的第一项：\n\n``` javascript\narr[0] = 420;\nconsole.log(arr); // [420, 8, 506]\n```\n\n所以凭直觉来说，很容易假设可以对字符串执行相同的操作：\n\n``` javascript\nstr[0] = 'j'; // ???\n```\n\n**但是你不能这样做。**\n\n这有一点很重要，我们需要添加到我们的思维模型。字符串是原始值，这是十分重要的。\n\n**所有的原始值都是不可改变的。**“Immutable”是拉丁语中一种奇特的说法“unchangeable”。只读的，你根本不能改变原始值。\n\n如果你尝试在一个原始值上设置属性，不管是字符串、数字还是其他什么，JavaScript不会允许你这样做。它是否会默默拒绝你的请求或报错取决于你的代码运行在[哪个模式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode)！\n\n但我向你保证，这永远行不通:\n\n``` javascript\nlet fifty = 50;\nfifty.shades = 'gray'; // No!\n```\n\n就像一些数组，50是一个原始值，你不能给它设置属性。\n\n在我的JavaScript宇宙里面，所有的原始值存在于离我的代码很远的外圆中——就像遥远的恒星。这提醒我，即使我可以从代码中引用它们，也无法更改它们。他们保持原样。\n\n我觉得这异常地令人安慰：\n\n![](/blog_imgs/just_javascript/03/unnamed.png)\n\n## 一个矛盾？\n\n我刚刚演示了原始值是只读的，或者用我们这个时代的话说，是不可变的。这里有一个片段来测试你的思维模型：\n\n``` javascript\nlet pet = 'Narwhal';\npet = 'The Kraken';\nconsole.log(pet); // ?\n```\n\n像以前一样，用几句话写下你的思考过程。别急着往前走。一步一步地关注你对每一行的想法。字符串的不变性在这里起作用吗？它起什么作用？\n\n\b\b![](/blog_imgs/just_javascript/03/spoilers.jpg)\n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n如果你认为我是在捣乱你的大脑，那你完全是对的！答案是“The Kraken”——字符串的不变性不起作用。\n\n如果你错了，不要气馁！最后这两个例子看起来肯定是相互矛盾的。\n\n这是一个很重要的领悟！\n\n当你对一门语言不熟悉时，你可能会倾向于忽略矛盾。毕竟，如果你追逐每一个矛盾，你会深陷入一个兔子洞深而学不到任何东西。\n\n但既然你决定建立思维模型，你就需要质疑矛盾，它们展示出了思维模型的缺口。\n\n## 变量是导线\n\n再看看这些例子：\n\n``` javascript\nlet pet = 'Narwhal';\npet = 'The Kraken';\nconsole.log(pet); // \"The Kraken\"\n```\n\n我们知道字符串不能改变因为它们是原始值。但是pet变量的确变成了“The Kraken”。发生了什么呢？\n\n这似乎是一个矛盾，但事实并非如此。我们只说原始值不能改变。我们对于变量什么都没说！\n\n当我们完善我们的思维模型时候，我们可能需要整理一下相关的概念。\n\n**变量不是值。**\n\n变量指向值。\n\n在我的宇宙，一个变量代表一根导线。它有两端和方向：它从我代码中的一个名字开始，最后指向我宇宙中的某个值。\n\n举个例子，我可以将pet变量指向“Narwhal”值：\n\n``` javascript\nlet pet = 'Narwhal';\n```\n\n\b\b![](/blog_imgs/just_javascript/03/unnamed.gif)\n\n之后可以对变量执行两项操作：\n\n### 给变量赋值\n\n我可以做的一件事是给我的变量赋值：\n\n``` javascript\npet = 'The Kraken';\n```\n\n\b\b![](/blog_imgs/just_javascript/03/unnamed1.gif)\n\n我在这里所做的只是告知JavaScript将左侧的“wire”（我的pet变量）指向右侧的值（“The Kraken”）。它将一直指向那个值，除非我之后重新分配它。\n\n注意，我不能在左边放任何东西：\n\n``` javascript\n'war' = 'peace'; // Nope. (Try it in the console.)\n```\n\n**赋值的左侧必须是导线。**目前，我们只知道变量是“导线”。但是还有另一种“导线”我们将在后面的模块中讨论。也许，你能猜出是什么？（提示：它包含方括号或点，我们已经见过几次了）。\n\n还有另外一条规则。\n\n**赋值的右侧必须是表达式。**它可以是简单的值，比如2或“hello”，也可以是更复杂的表达式：\n\n``` javascript\npet = count + ' Dalmatians';\n```\n\n在这里，count+“Dalmatians”是一个表达式——对JavaScript来说是一个问题。JavaScript将用一个值（例如，“101 Dalmatians”）来回答这个问题。从现在起，pet“导线”将开始指向这个值。\n\n如果右边必须是表达式，这是否意味着像2这样的数字或像用代码编写的'the Kraken'这样的字符串也是表达式？对！这样的表达式称为字面量——因为我们逐字记录它们的值。\n\n### 读取变量的值\n\n我还可以读取变量的值——例如，要记录它：\n\n``` \njavascript\nconsole.log(pet); \n```\n\n这并不奇怪。\n\n但是请注意，我们传递给console.log的不是pet变量。我们可以通俗地说，但是我们不能真的把变量传递给函数。我们传递的是pet变量的当前值。这是怎么工作的呢？\n\n原来，像pet这样的变量名也可以用作表达式！当我们编写pet时，我们在问JavaScript一个问题：“pet的当前价值是什么？”为了回答我们的问题，JavaScript跟随pet的“导线”，并在“导线”的末尾返回值。\n\n所以同一个表达式可以在不同的时间给我们不同的值！\n\n### 名词和动词\n\n谁在乎你说的是“传递变量”还是“传递值”？深究这点差别不是过于卖弄学问吗？我当然不会打断你的同事来纠正他们，甚至是你自己。那将会浪费大家的时间。\n\n但在你的头脑中，你需要清楚地知道你可以用每一个概念做什么。你不能骑自行车溜冰。你不能让鳄梨费气力啊。你不能像蚊子一样发嗖嗖声。而且你不能传递一个变量——至少在JavaScript中不能。\n\n这里有一个小例子说明为什么这些细节很重要。\n\n``` javascript\nfunction double(x) {\n    x = x * 2;\n}\n\nlet money = 10;\ndouble(money);\nconsole.log(money); // ?\n```\n\n如果我们认为double（money）传递了一个变量，那么我们可以预期x=x*2将使该变量加倍。但事情不是这样的。我们知道double（money）的意思是“计算出货币的价值，然后将其传递给double”。所以答案是10。真是个骗局！\n\n你脑子里有哪些不同的JavaScript名词和动词？他们之间有什么关系？将你最常使用的列一个清单。\n\n### 把它放在一起\n\n现在让我们重温一下来自思维模型的第一个例子：\n\n``` javascript\nlet x = 10;\nlet y = x;\nx = 0;\n```\n\n我建议你拿一张纸或一个绘图应用程序，一步一步地画出x和y变量的“连线”的情况图。\n\n**第一行的作用不大：**\n\n\b\b![](/blog_imgs/just_javascript/03/unnamed2.gif)\n\n* 声明一个x变量  \n  + 为x变量生成导线\n* 给x赋值10\n  + 让x的导线指向10\n\n**第二行很短，但它做了很多事情：**\n\n\b\b![](/blog_imgs/just_javascript/03/unnamed3.gif)\n\n* 声明一个y变量\n  + 为y变量生成导线\n* 把x的值赋给y\n  + 计算表达式：x\n    - 我们要回答的问题是“x”\n    - **跟随x的导线——答案是值10**\n  + x表达式结果是值10\n  + 因此，将10的值赋给y\n  + 把y的导线指向值10\n\n  **最后，我们进入第三行：**\n\n\b\b![](/blog_imgs/just_javascript/03/unnamed4.gif)\n\n* 将0的值赋给x\n  + 将x的导线指向值0\n\n最后，x变量指向值0，y变量指向值10。注意y=x并不意味着将y指向“x”。我们不能把变量指向彼此！**变量总是指向值**。当我们看到一个赋值时，我们“询问”右边的值，并将左边的“线”指向它。\n\n我在思维模型中提到，把变量看作盒子是相当常见的。我们要建造的宇宙根本就没有盒子。**它只有导线！**这看起来有点烦人。为什么我们不能“将0和10放入变量中，而是将变量指向它们？”\n\n使用导线对于解释许多其他概念将是非常重要的，就像严格的等式，对象标识和变动。我们要坚持使用导线，所以你最好现在就开始习惯。\n\n我的宇宙充满了导线。\n\n## 总结\n\n* **原始值是不可变的：**在我们的代码中，我们无法做任何事情来影响它们或以任何方式更改它们。他们保持原样。例如，不能对字符串值设置属性，因为它是原始值。数组不是原始值，所以我们可以设置它们的属性。\n\n* **变量不是值：**每个变量都指向一个特定的值。我们可以使用=赋值运算符来更改它指向的值。\n\n* **变量就像导线：**“导线”并不是JavaScript的概念——但是它帮助我们理解变量如何指向值。还有一种不同的“电线”，不是变量，但我们还没有讨论过。\n\n* **留意矛盾：**如果你学到的两件事似乎互相矛盾，不要灰心。通常这是一个迹象，表明下面隐藏着更深层次的真相。\n\n* **名词和动词很重要：**我们正在建立一个思维模型，这样我们就能对宇宙中可能发生或不可能发生的事情充满信心。随便马虎的说话是可以的，但我们的思维需要精确。\n\n## 练习\n\n本单元也有练习题供你练习！\n\n[点击这里，通过一些简短的练习巩固这个心理模型。](https://el2.convertkit-mail.com/c/o8u6klng6ncwu4e40piv/6gtehou6oom6de/aHR0cHM6Ly9lZ2doZWFkaW8udHlwZWZvcm0uY29tL3RvL1JXSmczbT9lbWFpbD1ha2loaTk1QGdtYWlsLmNvbQ==)\n\n**不要跳过它们！**\n\n即使你可能熟悉变量的概念，这些练习将帮助你巩固我们正在建立的心理模型。我们需要这个基础才能继续更复杂的话题。\n\n\n\n","source":"_posts/《Just-JavaScript》03-值和变量.md","raw":"---\ntitle: 《Just JavaScript》03. 值和变量\ndate: 2020-04-01 17:36:08  \ncategories: JavaScript\ntags:\n\n---\n\n我们将以一个小的代码片段开始这个模块。\n\n``` javascript\nlet reaction = 'yikes';\nreaction[0] = 'l';\nconsole.log(reaction);\n```\n\n你希望它做什么？我们还没有讲到这个，所以如果你不确定的话没关系。**试着用你目前的JavaScript知识来回答这个问题。**\n\n现在我想让你花点时间，一步一步地为这段代码的每一行写下你确切的思考过程。注意你现有的思维模型中的任何欠缺或不确定性，并把它们也写下来。如果你对此有任何疑问，尽可能清楚地将它表达出来。\n\n![](/blog_imgs/just_javascript/03/spoilers.jpg)\n\n在你写完之前你的思考前不要往下滚动。\n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n答案是这样的。此代码将打印“yikes”或抛出错误，具体取决于你是否处于严格模式。它永远不会印“likes”。\n\n## 原始值是不可改变的\n\n你答对了吗？这可能看起来像一个很小的问题，就像大家在JavaScript面试中问的那种问题，但在实际编码中并没有太多出现。即使如此，它也说明了关于原始值的一个重要特点。\n\n**我不能改变原始值。**\n\n我将使用一个很小的例子来解释这点。字符串（原始值）和数组（非原始值，对象）有一些表面上的相似之处。数组是项的序列，字符串是字符的序列。\n\n``` javascript\nlet arr = [212, 8, 506];\nlet str = 'hello';\n```\n\n你可以访问字符串的第一个字符就像访问数组项那样，几乎感觉字符串就是数组（但它们并不是！）：\n\n``` javascript\nconsole.log(arr[0]); // 212\nconsole.log(str[0]); // \"h\"\n```\n\n你可以改变数组的第一项：\n\n``` javascript\narr[0] = 420;\nconsole.log(arr); // [420, 8, 506]\n```\n\n所以凭直觉来说，很容易假设可以对字符串执行相同的操作：\n\n``` javascript\nstr[0] = 'j'; // ???\n```\n\n**但是你不能这样做。**\n\n这有一点很重要，我们需要添加到我们的思维模型。字符串是原始值，这是十分重要的。\n\n**所有的原始值都是不可改变的。**“Immutable”是拉丁语中一种奇特的说法“unchangeable”。只读的，你根本不能改变原始值。\n\n如果你尝试在一个原始值上设置属性，不管是字符串、数字还是其他什么，JavaScript不会允许你这样做。它是否会默默拒绝你的请求或报错取决于你的代码运行在[哪个模式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode)！\n\n但我向你保证，这永远行不通:\n\n``` javascript\nlet fifty = 50;\nfifty.shades = 'gray'; // No!\n```\n\n就像一些数组，50是一个原始值，你不能给它设置属性。\n\n在我的JavaScript宇宙里面，所有的原始值存在于离我的代码很远的外圆中——就像遥远的恒星。这提醒我，即使我可以从代码中引用它们，也无法更改它们。他们保持原样。\n\n我觉得这异常地令人安慰：\n\n![](/blog_imgs/just_javascript/03/unnamed.png)\n\n## 一个矛盾？\n\n我刚刚演示了原始值是只读的，或者用我们这个时代的话说，是不可变的。这里有一个片段来测试你的思维模型：\n\n``` javascript\nlet pet = 'Narwhal';\npet = 'The Kraken';\nconsole.log(pet); // ?\n```\n\n像以前一样，用几句话写下你的思考过程。别急着往前走。一步一步地关注你对每一行的想法。字符串的不变性在这里起作用吗？它起什么作用？\n\n\b\b![](/blog_imgs/just_javascript/03/spoilers.jpg)\n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n`...` \n\n如果你认为我是在捣乱你的大脑，那你完全是对的！答案是“The Kraken”——字符串的不变性不起作用。\n\n如果你错了，不要气馁！最后这两个例子看起来肯定是相互矛盾的。\n\n这是一个很重要的领悟！\n\n当你对一门语言不熟悉时，你可能会倾向于忽略矛盾。毕竟，如果你追逐每一个矛盾，你会深陷入一个兔子洞深而学不到任何东西。\n\n但既然你决定建立思维模型，你就需要质疑矛盾，它们展示出了思维模型的缺口。\n\n## 变量是导线\n\n再看看这些例子：\n\n``` javascript\nlet pet = 'Narwhal';\npet = 'The Kraken';\nconsole.log(pet); // \"The Kraken\"\n```\n\n我们知道字符串不能改变因为它们是原始值。但是pet变量的确变成了“The Kraken”。发生了什么呢？\n\n这似乎是一个矛盾，但事实并非如此。我们只说原始值不能改变。我们对于变量什么都没说！\n\n当我们完善我们的思维模型时候，我们可能需要整理一下相关的概念。\n\n**变量不是值。**\n\n变量指向值。\n\n在我的宇宙，一个变量代表一根导线。它有两端和方向：它从我代码中的一个名字开始，最后指向我宇宙中的某个值。\n\n举个例子，我可以将pet变量指向“Narwhal”值：\n\n``` javascript\nlet pet = 'Narwhal';\n```\n\n\b\b![](/blog_imgs/just_javascript/03/unnamed.gif)\n\n之后可以对变量执行两项操作：\n\n### 给变量赋值\n\n我可以做的一件事是给我的变量赋值：\n\n``` javascript\npet = 'The Kraken';\n```\n\n\b\b![](/blog_imgs/just_javascript/03/unnamed1.gif)\n\n我在这里所做的只是告知JavaScript将左侧的“wire”（我的pet变量）指向右侧的值（“The Kraken”）。它将一直指向那个值，除非我之后重新分配它。\n\n注意，我不能在左边放任何东西：\n\n``` javascript\n'war' = 'peace'; // Nope. (Try it in the console.)\n```\n\n**赋值的左侧必须是导线。**目前，我们只知道变量是“导线”。但是还有另一种“导线”我们将在后面的模块中讨论。也许，你能猜出是什么？（提示：它包含方括号或点，我们已经见过几次了）。\n\n还有另外一条规则。\n\n**赋值的右侧必须是表达式。**它可以是简单的值，比如2或“hello”，也可以是更复杂的表达式：\n\n``` javascript\npet = count + ' Dalmatians';\n```\n\n在这里，count+“Dalmatians”是一个表达式——对JavaScript来说是一个问题。JavaScript将用一个值（例如，“101 Dalmatians”）来回答这个问题。从现在起，pet“导线”将开始指向这个值。\n\n如果右边必须是表达式，这是否意味着像2这样的数字或像用代码编写的'the Kraken'这样的字符串也是表达式？对！这样的表达式称为字面量——因为我们逐字记录它们的值。\n\n### 读取变量的值\n\n我还可以读取变量的值——例如，要记录它：\n\n``` \njavascript\nconsole.log(pet); \n```\n\n这并不奇怪。\n\n但是请注意，我们传递给console.log的不是pet变量。我们可以通俗地说，但是我们不能真的把变量传递给函数。我们传递的是pet变量的当前值。这是怎么工作的呢？\n\n原来，像pet这样的变量名也可以用作表达式！当我们编写pet时，我们在问JavaScript一个问题：“pet的当前价值是什么？”为了回答我们的问题，JavaScript跟随pet的“导线”，并在“导线”的末尾返回值。\n\n所以同一个表达式可以在不同的时间给我们不同的值！\n\n### 名词和动词\n\n谁在乎你说的是“传递变量”还是“传递值”？深究这点差别不是过于卖弄学问吗？我当然不会打断你的同事来纠正他们，甚至是你自己。那将会浪费大家的时间。\n\n但在你的头脑中，你需要清楚地知道你可以用每一个概念做什么。你不能骑自行车溜冰。你不能让鳄梨费气力啊。你不能像蚊子一样发嗖嗖声。而且你不能传递一个变量——至少在JavaScript中不能。\n\n这里有一个小例子说明为什么这些细节很重要。\n\n``` javascript\nfunction double(x) {\n    x = x * 2;\n}\n\nlet money = 10;\ndouble(money);\nconsole.log(money); // ?\n```\n\n如果我们认为double（money）传递了一个变量，那么我们可以预期x=x*2将使该变量加倍。但事情不是这样的。我们知道double（money）的意思是“计算出货币的价值，然后将其传递给double”。所以答案是10。真是个骗局！\n\n你脑子里有哪些不同的JavaScript名词和动词？他们之间有什么关系？将你最常使用的列一个清单。\n\n### 把它放在一起\n\n现在让我们重温一下来自思维模型的第一个例子：\n\n``` javascript\nlet x = 10;\nlet y = x;\nx = 0;\n```\n\n我建议你拿一张纸或一个绘图应用程序，一步一步地画出x和y变量的“连线”的情况图。\n\n**第一行的作用不大：**\n\n\b\b![](/blog_imgs/just_javascript/03/unnamed2.gif)\n\n* 声明一个x变量  \n  + 为x变量生成导线\n* 给x赋值10\n  + 让x的导线指向10\n\n**第二行很短，但它做了很多事情：**\n\n\b\b![](/blog_imgs/just_javascript/03/unnamed3.gif)\n\n* 声明一个y变量\n  + 为y变量生成导线\n* 把x的值赋给y\n  + 计算表达式：x\n    - 我们要回答的问题是“x”\n    - **跟随x的导线——答案是值10**\n  + x表达式结果是值10\n  + 因此，将10的值赋给y\n  + 把y的导线指向值10\n\n  **最后，我们进入第三行：**\n\n\b\b![](/blog_imgs/just_javascript/03/unnamed4.gif)\n\n* 将0的值赋给x\n  + 将x的导线指向值0\n\n最后，x变量指向值0，y变量指向值10。注意y=x并不意味着将y指向“x”。我们不能把变量指向彼此！**变量总是指向值**。当我们看到一个赋值时，我们“询问”右边的值，并将左边的“线”指向它。\n\n我在思维模型中提到，把变量看作盒子是相当常见的。我们要建造的宇宙根本就没有盒子。**它只有导线！**这看起来有点烦人。为什么我们不能“将0和10放入变量中，而是将变量指向它们？”\n\n使用导线对于解释许多其他概念将是非常重要的，就像严格的等式，对象标识和变动。我们要坚持使用导线，所以你最好现在就开始习惯。\n\n我的宇宙充满了导线。\n\n## 总结\n\n* **原始值是不可变的：**在我们的代码中，我们无法做任何事情来影响它们或以任何方式更改它们。他们保持原样。例如，不能对字符串值设置属性，因为它是原始值。数组不是原始值，所以我们可以设置它们的属性。\n\n* **变量不是值：**每个变量都指向一个特定的值。我们可以使用=赋值运算符来更改它指向的值。\n\n* **变量就像导线：**“导线”并不是JavaScript的概念——但是它帮助我们理解变量如何指向值。还有一种不同的“电线”，不是变量，但我们还没有讨论过。\n\n* **留意矛盾：**如果你学到的两件事似乎互相矛盾，不要灰心。通常这是一个迹象，表明下面隐藏着更深层次的真相。\n\n* **名词和动词很重要：**我们正在建立一个思维模型，这样我们就能对宇宙中可能发生或不可能发生的事情充满信心。随便马虎的说话是可以的，但我们的思维需要精确。\n\n## 练习\n\n本单元也有练习题供你练习！\n\n[点击这里，通过一些简短的练习巩固这个心理模型。](https://el2.convertkit-mail.com/c/o8u6klng6ncwu4e40piv/6gtehou6oom6de/aHR0cHM6Ly9lZ2doZWFkaW8udHlwZWZvcm0uY29tL3RvL1JXSmczbT9lbWFpbD1ha2loaTk1QGdtYWlsLmNvbQ==)\n\n**不要跳过它们！**\n\n即使你可能熟悉变量的概念，这些练习将帮助你巩固我们正在建立的心理模型。我们需要这个基础才能继续更复杂的话题。\n\n\n\n","slug":"《Just-JavaScript》03-值和变量","published":1,"updated":"2020-06-03T07:28:36.833Z","_id":"ckaz13gpk0003gq9h4a7z41jp","comments":1,"layout":"post","photos":[],"link":"","content":"<p>我们将以一个小的代码片段开始这个模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> reaction = <span class=\"string\">'yikes'</span>;</span><br><span class=\"line\">reaction[<span class=\"number\">0</span>] = <span class=\"string\">'l'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reaction);</span><br></pre></td></tr></table></figure>\n\n<p>你希望它做什么？我们还没有讲到这个，所以如果你不确定的话没关系。<strong>试着用你目前的JavaScript知识来回答这个问题。</strong></p>\n<p>现在我想让你花点时间，一步一步地为这段代码的每一行写下你确切的思考过程。注意你现有的思维模型中的任何欠缺或不确定性，并把它们也写下来。如果你对此有任何疑问，尽可能清楚地将它表达出来。</p>\n<p><img src=\"/blog_imgs/just_javascript/03/spoilers.jpg\" alt=\"\"></p>\n<p>在你写完之前你的思考前不要往下滚动。</p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p>答案是这样的。此代码将打印“yikes”或抛出错误，具体取决于你是否处于严格模式。它永远不会印“likes”。</p>\n<h2 id=\"原始值是不可改变的\"><a href=\"#原始值是不可改变的\" class=\"headerlink\" title=\"原始值是不可改变的\"></a>原始值是不可改变的</h2><p>你答对了吗？这可能看起来像一个很小的问题，就像大家在JavaScript面试中问的那种问题，但在实际编码中并没有太多出现。即使如此，它也说明了关于原始值的一个重要特点。</p>\n<p><strong>我不能改变原始值。</strong></p>\n<p>我将使用一个很小的例子来解释这点。字符串（原始值）和数组（非原始值，对象）有一些表面上的相似之处。数组是项的序列，字符串是字符的序列。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">212</span>, <span class=\"number\">8</span>, <span class=\"number\">506</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">'hello'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>你可以访问字符串的第一个字符就像访问数组项那样，几乎感觉字符串就是数组（但它们并不是！）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(arr[<span class=\"number\">0</span>]); <span class=\"comment\">// 212</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str[<span class=\"number\">0</span>]); <span class=\"comment\">// \"h\"</span></span><br></pre></td></tr></table></figure>\n\n<p>你可以改变数组的第一项：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"number\">420</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [420, 8, 506]</span></span><br></pre></td></tr></table></figure>\n\n<p>所以凭直觉来说，很容易假设可以对字符串执行相同的操作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str[<span class=\"number\">0</span>] = <span class=\"string\">'j'</span>; <span class=\"comment\">// ???</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>但是你不能这样做。</strong></p>\n<p>这有一点很重要，我们需要添加到我们的思维模型。字符串是原始值，这是十分重要的。</p>\n<p><strong>所有的原始值都是不可改变的。</strong>“Immutable”是拉丁语中一种奇特的说法“unchangeable”。只读的，你根本不能改变原始值。</p>\n<p>如果你尝试在一个原始值上设置属性，不管是字符串、数字还是其他什么，JavaScript不会允许你这样做。它是否会默默拒绝你的请求或报错取决于你的代码运行在<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode\" target=\"_blank\" rel=\"noopener\">哪个模式</a>！</p>\n<p>但我向你保证，这永远行不通:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> fifty = <span class=\"number\">50</span>;</span><br><span class=\"line\">fifty.shades = <span class=\"string\">'gray'</span>; <span class=\"comment\">// No!</span></span><br></pre></td></tr></table></figure>\n\n<p>就像一些数组，50是一个原始值，你不能给它设置属性。</p>\n<p>在我的JavaScript宇宙里面，所有的原始值存在于离我的代码很远的外圆中——就像遥远的恒星。这提醒我，即使我可以从代码中引用它们，也无法更改它们。他们保持原样。</p>\n<p>我觉得这异常地令人安慰：</p>\n<p><img src=\"/blog_imgs/just_javascript/03/unnamed.png\" alt=\"\"></p>\n<h2 id=\"一个矛盾？\"><a href=\"#一个矛盾？\" class=\"headerlink\" title=\"一个矛盾？\"></a>一个矛盾？</h2><p>我刚刚演示了原始值是只读的，或者用我们这个时代的话说，是不可变的。这里有一个片段来测试你的思维模型：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> pet = <span class=\"string\">'Narwhal'</span>;</span><br><span class=\"line\">pet = <span class=\"string\">'The Kraken'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(pet); <span class=\"comment\">// ?</span></span><br></pre></td></tr></table></figure>\n\n<p>像以前一样，用几句话写下你的思考过程。别急着往前走。一步一步地关注你对每一行的想法。字符串的不变性在这里起作用吗？它起什么作用？</p>\n<p>\b\b<img src=\"/blog_imgs/just_javascript/03/spoilers.jpg\" alt=\"\"></p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p>如果你认为我是在捣乱你的大脑，那你完全是对的！答案是“The Kraken”——字符串的不变性不起作用。</p>\n<p>如果你错了，不要气馁！最后这两个例子看起来肯定是相互矛盾的。</p>\n<p>这是一个很重要的领悟！</p>\n<p>当你对一门语言不熟悉时，你可能会倾向于忽略矛盾。毕竟，如果你追逐每一个矛盾，你会深陷入一个兔子洞深而学不到任何东西。</p>\n<p>但既然你决定建立思维模型，你就需要质疑矛盾，它们展示出了思维模型的缺口。</p>\n<h2 id=\"变量是导线\"><a href=\"#变量是导线\" class=\"headerlink\" title=\"变量是导线\"></a>变量是导线</h2><p>再看看这些例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> pet = <span class=\"string\">'Narwhal'</span>;</span><br><span class=\"line\">pet = <span class=\"string\">'The Kraken'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(pet); <span class=\"comment\">// \"The Kraken\"</span></span><br></pre></td></tr></table></figure>\n\n<p>我们知道字符串不能改变因为它们是原始值。但是pet变量的确变成了“The Kraken”。发生了什么呢？</p>\n<p>这似乎是一个矛盾，但事实并非如此。我们只说原始值不能改变。我们对于变量什么都没说！</p>\n<p>当我们完善我们的思维模型时候，我们可能需要整理一下相关的概念。</p>\n<p><strong>变量不是值。</strong></p>\n<p>变量指向值。</p>\n<p>在我的宇宙，一个变量代表一根导线。它有两端和方向：它从我代码中的一个名字开始，最后指向我宇宙中的某个值。</p>\n<p>举个例子，我可以将pet变量指向“Narwhal”值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> pet = <span class=\"string\">'Narwhal'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>\b\b<img src=\"/blog_imgs/just_javascript/03/unnamed.gif\" alt=\"\"></p>\n<p>之后可以对变量执行两项操作：</p>\n<h3 id=\"给变量赋值\"><a href=\"#给变量赋值\" class=\"headerlink\" title=\"给变量赋值\"></a>给变量赋值</h3><p>我可以做的一件事是给我的变量赋值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pet = <span class=\"string\">'The Kraken'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>\b\b<img src=\"/blog_imgs/just_javascript/03/unnamed1.gif\" alt=\"\"></p>\n<p>我在这里所做的只是告知JavaScript将左侧的“wire”（我的pet变量）指向右侧的值（“The Kraken”）。它将一直指向那个值，除非我之后重新分配它。</p>\n<p>注意，我不能在左边放任何东西：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'war'</span> = <span class=\"string\">'peace'</span>; <span class=\"comment\">// Nope. (Try it in the console.)</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>赋值的左侧必须是导线。</strong>目前，我们只知道变量是“导线”。但是还有另一种“导线”我们将在后面的模块中讨论。也许，你能猜出是什么？（提示：它包含方括号或点，我们已经见过几次了）。</p>\n<p>还有另外一条规则。</p>\n<p><strong>赋值的右侧必须是表达式。</strong>它可以是简单的值，比如2或“hello”，也可以是更复杂的表达式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pet = count + <span class=\"string\">' Dalmatians'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，count+“Dalmatians”是一个表达式——对JavaScript来说是一个问题。JavaScript将用一个值（例如，“101 Dalmatians”）来回答这个问题。从现在起，pet“导线”将开始指向这个值。</p>\n<p>如果右边必须是表达式，这是否意味着像2这样的数字或像用代码编写的’the Kraken’这样的字符串也是表达式？对！这样的表达式称为字面量——因为我们逐字记录它们的值。</p>\n<h3 id=\"读取变量的值\"><a href=\"#读取变量的值\" class=\"headerlink\" title=\"读取变量的值\"></a>读取变量的值</h3><p>我还可以读取变量的值——例如，要记录它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javascript</span><br><span class=\"line\">console.log(pet);</span><br></pre></td></tr></table></figure>\n\n<p>这并不奇怪。</p>\n<p>但是请注意，我们传递给console.log的不是pet变量。我们可以通俗地说，但是我们不能真的把变量传递给函数。我们传递的是pet变量的当前值。这是怎么工作的呢？</p>\n<p>原来，像pet这样的变量名也可以用作表达式！当我们编写pet时，我们在问JavaScript一个问题：“pet的当前价值是什么？”为了回答我们的问题，JavaScript跟随pet的“导线”，并在“导线”的末尾返回值。</p>\n<p>所以同一个表达式可以在不同的时间给我们不同的值！</p>\n<h3 id=\"名词和动词\"><a href=\"#名词和动词\" class=\"headerlink\" title=\"名词和动词\"></a>名词和动词</h3><p>谁在乎你说的是“传递变量”还是“传递值”？深究这点差别不是过于卖弄学问吗？我当然不会打断你的同事来纠正他们，甚至是你自己。那将会浪费大家的时间。</p>\n<p>但在你的头脑中，你需要清楚地知道你可以用每一个概念做什么。你不能骑自行车溜冰。你不能让鳄梨费气力啊。你不能像蚊子一样发嗖嗖声。而且你不能传递一个变量——至少在JavaScript中不能。</p>\n<p>这里有一个小例子说明为什么这些细节很重要。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">double</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    x = x * <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> money = <span class=\"number\">10</span>;</span><br><span class=\"line\">double(money);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(money); <span class=\"comment\">// ?</span></span><br></pre></td></tr></table></figure>\n\n<p>如果我们认为double（money）传递了一个变量，那么我们可以预期x=x*2将使该变量加倍。但事情不是这样的。我们知道double（money）的意思是“计算出货币的价值，然后将其传递给double”。所以答案是10。真是个骗局！</p>\n<p>你脑子里有哪些不同的JavaScript名词和动词？他们之间有什么关系？将你最常使用的列一个清单。</p>\n<h3 id=\"把它放在一起\"><a href=\"#把它放在一起\" class=\"headerlink\" title=\"把它放在一起\"></a>把它放在一起</h3><p>现在让我们重温一下来自思维模型的第一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y = x;</span><br><span class=\"line\">x = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<p>我建议你拿一张纸或一个绘图应用程序，一步一步地画出x和y变量的“连线”的情况图。</p>\n<p><strong>第一行的作用不大：</strong></p>\n<p>\b\b<img src=\"/blog_imgs/just_javascript/03/unnamed2.gif\" alt=\"\"></p>\n<ul>\n<li>声明一个x变量  <ul>\n<li>为x变量生成导线</li>\n</ul>\n</li>\n<li>给x赋值10<ul>\n<li>让x的导线指向10</li>\n</ul>\n</li>\n</ul>\n<p><strong>第二行很短，但它做了很多事情：</strong></p>\n<p>\b\b<img src=\"/blog_imgs/just_javascript/03/unnamed3.gif\" alt=\"\"></p>\n<ul>\n<li><p>声明一个y变量</p>\n<ul>\n<li>为y变量生成导线</li>\n</ul>\n</li>\n<li><p>把x的值赋给y</p>\n<ul>\n<li>计算表达式：x<ul>\n<li>我们要回答的问题是“x”</li>\n<li><strong>跟随x的导线——答案是值10</strong></li>\n</ul>\n</li>\n<li>x表达式结果是值10</li>\n<li>因此，将10的值赋给y</li>\n<li>把y的导线指向值10</li>\n</ul>\n<p><strong>最后，我们进入第三行：</strong></p>\n</li>\n</ul>\n<p>\b\b<img src=\"/blog_imgs/just_javascript/03/unnamed4.gif\" alt=\"\"></p>\n<ul>\n<li>将0的值赋给x<ul>\n<li>将x的导线指向值0</li>\n</ul>\n</li>\n</ul>\n<p>最后，x变量指向值0，y变量指向值10。注意y=x并不意味着将y指向“x”。我们不能把变量指向彼此！<strong>变量总是指向值</strong>。当我们看到一个赋值时，我们“询问”右边的值，并将左边的“线”指向它。</p>\n<p>我在思维模型中提到，把变量看作盒子是相当常见的。我们要建造的宇宙根本就没有盒子。<strong>它只有导线！</strong>这看起来有点烦人。为什么我们不能“将0和10放入变量中，而是将变量指向它们？”</p>\n<p>使用导线对于解释许多其他概念将是非常重要的，就像严格的等式，对象标识和变动。我们要坚持使用导线，所以你最好现在就开始习惯。</p>\n<p>我的宇宙充满了导线。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li><p><strong>原始值是不可变的：</strong>在我们的代码中，我们无法做任何事情来影响它们或以任何方式更改它们。他们保持原样。例如，不能对字符串值设置属性，因为它是原始值。数组不是原始值，所以我们可以设置它们的属性。</p>\n</li>\n<li><p><strong>变量不是值：</strong>每个变量都指向一个特定的值。我们可以使用=赋值运算符来更改它指向的值。</p>\n</li>\n<li><p><strong>变量就像导线：</strong>“导线”并不是JavaScript的概念——但是它帮助我们理解变量如何指向值。还有一种不同的“电线”，不是变量，但我们还没有讨论过。</p>\n</li>\n<li><p><strong>留意矛盾：</strong>如果你学到的两件事似乎互相矛盾，不要灰心。通常这是一个迹象，表明下面隐藏着更深层次的真相。</p>\n</li>\n<li><p><strong>名词和动词很重要：</strong>我们正在建立一个思维模型，这样我们就能对宇宙中可能发生或不可能发生的事情充满信心。随便马虎的说话是可以的，但我们的思维需要精确。</p>\n</li>\n</ul>\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p>本单元也有练习题供你练习！</p>\n<p><a href=\"https://el2.convertkit-mail.com/c/o8u6klng6ncwu4e40piv/6gtehou6oom6de/aHR0cHM6Ly9lZ2doZWFkaW8udHlwZWZvcm0uY29tL3RvL1JXSmczbT9lbWFpbD1ha2loaTk1QGdtYWlsLmNvbQ==\" target=\"_blank\" rel=\"noopener\">点击这里，通过一些简短的练习巩固这个心理模型。</a></p>\n<p><strong>不要跳过它们！</strong></p>\n<p>即使你可能熟悉变量的概念，这些练习将帮助你巩固我们正在建立的心理模型。我们需要这个基础才能继续更复杂的话题。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>我们将以一个小的代码片段开始这个模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> reaction = <span class=\"string\">'yikes'</span>;</span><br><span class=\"line\">reaction[<span class=\"number\">0</span>] = <span class=\"string\">'l'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reaction);</span><br></pre></td></tr></table></figure>\n\n<p>你希望它做什么？我们还没有讲到这个，所以如果你不确定的话没关系。<strong>试着用你目前的JavaScript知识来回答这个问题。</strong></p>\n<p>现在我想让你花点时间，一步一步地为这段代码的每一行写下你确切的思考过程。注意你现有的思维模型中的任何欠缺或不确定性，并把它们也写下来。如果你对此有任何疑问，尽可能清楚地将它表达出来。</p>\n<p><img src=\"/blog_imgs/just_javascript/03/spoilers.jpg\" alt=\"\"></p>\n<p>在你写完之前你的思考前不要往下滚动。</p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p>答案是这样的。此代码将打印“yikes”或抛出错误，具体取决于你是否处于严格模式。它永远不会印“likes”。</p>\n<h2 id=\"原始值是不可改变的\"><a href=\"#原始值是不可改变的\" class=\"headerlink\" title=\"原始值是不可改变的\"></a>原始值是不可改变的</h2><p>你答对了吗？这可能看起来像一个很小的问题，就像大家在JavaScript面试中问的那种问题，但在实际编码中并没有太多出现。即使如此，它也说明了关于原始值的一个重要特点。</p>\n<p><strong>我不能改变原始值。</strong></p>\n<p>我将使用一个很小的例子来解释这点。字符串（原始值）和数组（非原始值，对象）有一些表面上的相似之处。数组是项的序列，字符串是字符的序列。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">212</span>, <span class=\"number\">8</span>, <span class=\"number\">506</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">'hello'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>你可以访问字符串的第一个字符就像访问数组项那样，几乎感觉字符串就是数组（但它们并不是！）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(arr[<span class=\"number\">0</span>]); <span class=\"comment\">// 212</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str[<span class=\"number\">0</span>]); <span class=\"comment\">// \"h\"</span></span><br></pre></td></tr></table></figure>\n\n<p>你可以改变数组的第一项：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"number\">420</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [420, 8, 506]</span></span><br></pre></td></tr></table></figure>\n\n<p>所以凭直觉来说，很容易假设可以对字符串执行相同的操作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str[<span class=\"number\">0</span>] = <span class=\"string\">'j'</span>; <span class=\"comment\">// ???</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>但是你不能这样做。</strong></p>\n<p>这有一点很重要，我们需要添加到我们的思维模型。字符串是原始值，这是十分重要的。</p>\n<p><strong>所有的原始值都是不可改变的。</strong>“Immutable”是拉丁语中一种奇特的说法“unchangeable”。只读的，你根本不能改变原始值。</p>\n<p>如果你尝试在一个原始值上设置属性，不管是字符串、数字还是其他什么，JavaScript不会允许你这样做。它是否会默默拒绝你的请求或报错取决于你的代码运行在<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode\" target=\"_blank\" rel=\"noopener\">哪个模式</a>！</p>\n<p>但我向你保证，这永远行不通:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> fifty = <span class=\"number\">50</span>;</span><br><span class=\"line\">fifty.shades = <span class=\"string\">'gray'</span>; <span class=\"comment\">// No!</span></span><br></pre></td></tr></table></figure>\n\n<p>就像一些数组，50是一个原始值，你不能给它设置属性。</p>\n<p>在我的JavaScript宇宙里面，所有的原始值存在于离我的代码很远的外圆中——就像遥远的恒星。这提醒我，即使我可以从代码中引用它们，也无法更改它们。他们保持原样。</p>\n<p>我觉得这异常地令人安慰：</p>\n<p><img src=\"/blog_imgs/just_javascript/03/unnamed.png\" alt=\"\"></p>\n<h2 id=\"一个矛盾？\"><a href=\"#一个矛盾？\" class=\"headerlink\" title=\"一个矛盾？\"></a>一个矛盾？</h2><p>我刚刚演示了原始值是只读的，或者用我们这个时代的话说，是不可变的。这里有一个片段来测试你的思维模型：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> pet = <span class=\"string\">'Narwhal'</span>;</span><br><span class=\"line\">pet = <span class=\"string\">'The Kraken'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(pet); <span class=\"comment\">// ?</span></span><br></pre></td></tr></table></figure>\n\n<p>像以前一样，用几句话写下你的思考过程。别急着往前走。一步一步地关注你对每一行的想法。字符串的不变性在这里起作用吗？它起什么作用？</p>\n<p>\b\b<img src=\"/blog_imgs/just_javascript/03/spoilers.jpg\" alt=\"\"></p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p>如果你认为我是在捣乱你的大脑，那你完全是对的！答案是“The Kraken”——字符串的不变性不起作用。</p>\n<p>如果你错了，不要气馁！最后这两个例子看起来肯定是相互矛盾的。</p>\n<p>这是一个很重要的领悟！</p>\n<p>当你对一门语言不熟悉时，你可能会倾向于忽略矛盾。毕竟，如果你追逐每一个矛盾，你会深陷入一个兔子洞深而学不到任何东西。</p>\n<p>但既然你决定建立思维模型，你就需要质疑矛盾，它们展示出了思维模型的缺口。</p>\n<h2 id=\"变量是导线\"><a href=\"#变量是导线\" class=\"headerlink\" title=\"变量是导线\"></a>变量是导线</h2><p>再看看这些例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> pet = <span class=\"string\">'Narwhal'</span>;</span><br><span class=\"line\">pet = <span class=\"string\">'The Kraken'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(pet); <span class=\"comment\">// \"The Kraken\"</span></span><br></pre></td></tr></table></figure>\n\n<p>我们知道字符串不能改变因为它们是原始值。但是pet变量的确变成了“The Kraken”。发生了什么呢？</p>\n<p>这似乎是一个矛盾，但事实并非如此。我们只说原始值不能改变。我们对于变量什么都没说！</p>\n<p>当我们完善我们的思维模型时候，我们可能需要整理一下相关的概念。</p>\n<p><strong>变量不是值。</strong></p>\n<p>变量指向值。</p>\n<p>在我的宇宙，一个变量代表一根导线。它有两端和方向：它从我代码中的一个名字开始，最后指向我宇宙中的某个值。</p>\n<p>举个例子，我可以将pet变量指向“Narwhal”值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> pet = <span class=\"string\">'Narwhal'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>\b\b<img src=\"/blog_imgs/just_javascript/03/unnamed.gif\" alt=\"\"></p>\n<p>之后可以对变量执行两项操作：</p>\n<h3 id=\"给变量赋值\"><a href=\"#给变量赋值\" class=\"headerlink\" title=\"给变量赋值\"></a>给变量赋值</h3><p>我可以做的一件事是给我的变量赋值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pet = <span class=\"string\">'The Kraken'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>\b\b<img src=\"/blog_imgs/just_javascript/03/unnamed1.gif\" alt=\"\"></p>\n<p>我在这里所做的只是告知JavaScript将左侧的“wire”（我的pet变量）指向右侧的值（“The Kraken”）。它将一直指向那个值，除非我之后重新分配它。</p>\n<p>注意，我不能在左边放任何东西：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'war'</span> = <span class=\"string\">'peace'</span>; <span class=\"comment\">// Nope. (Try it in the console.)</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>赋值的左侧必须是导线。</strong>目前，我们只知道变量是“导线”。但是还有另一种“导线”我们将在后面的模块中讨论。也许，你能猜出是什么？（提示：它包含方括号或点，我们已经见过几次了）。</p>\n<p>还有另外一条规则。</p>\n<p><strong>赋值的右侧必须是表达式。</strong>它可以是简单的值，比如2或“hello”，也可以是更复杂的表达式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pet = count + <span class=\"string\">' Dalmatians'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，count+“Dalmatians”是一个表达式——对JavaScript来说是一个问题。JavaScript将用一个值（例如，“101 Dalmatians”）来回答这个问题。从现在起，pet“导线”将开始指向这个值。</p>\n<p>如果右边必须是表达式，这是否意味着像2这样的数字或像用代码编写的’the Kraken’这样的字符串也是表达式？对！这样的表达式称为字面量——因为我们逐字记录它们的值。</p>\n<h3 id=\"读取变量的值\"><a href=\"#读取变量的值\" class=\"headerlink\" title=\"读取变量的值\"></a>读取变量的值</h3><p>我还可以读取变量的值——例如，要记录它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javascript</span><br><span class=\"line\">console.log(pet);</span><br></pre></td></tr></table></figure>\n\n<p>这并不奇怪。</p>\n<p>但是请注意，我们传递给console.log的不是pet变量。我们可以通俗地说，但是我们不能真的把变量传递给函数。我们传递的是pet变量的当前值。这是怎么工作的呢？</p>\n<p>原来，像pet这样的变量名也可以用作表达式！当我们编写pet时，我们在问JavaScript一个问题：“pet的当前价值是什么？”为了回答我们的问题，JavaScript跟随pet的“导线”，并在“导线”的末尾返回值。</p>\n<p>所以同一个表达式可以在不同的时间给我们不同的值！</p>\n<h3 id=\"名词和动词\"><a href=\"#名词和动词\" class=\"headerlink\" title=\"名词和动词\"></a>名词和动词</h3><p>谁在乎你说的是“传递变量”还是“传递值”？深究这点差别不是过于卖弄学问吗？我当然不会打断你的同事来纠正他们，甚至是你自己。那将会浪费大家的时间。</p>\n<p>但在你的头脑中，你需要清楚地知道你可以用每一个概念做什么。你不能骑自行车溜冰。你不能让鳄梨费气力啊。你不能像蚊子一样发嗖嗖声。而且你不能传递一个变量——至少在JavaScript中不能。</p>\n<p>这里有一个小例子说明为什么这些细节很重要。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">double</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    x = x * <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> money = <span class=\"number\">10</span>;</span><br><span class=\"line\">double(money);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(money); <span class=\"comment\">// ?</span></span><br></pre></td></tr></table></figure>\n\n<p>如果我们认为double（money）传递了一个变量，那么我们可以预期x=x*2将使该变量加倍。但事情不是这样的。我们知道double（money）的意思是“计算出货币的价值，然后将其传递给double”。所以答案是10。真是个骗局！</p>\n<p>你脑子里有哪些不同的JavaScript名词和动词？他们之间有什么关系？将你最常使用的列一个清单。</p>\n<h3 id=\"把它放在一起\"><a href=\"#把它放在一起\" class=\"headerlink\" title=\"把它放在一起\"></a>把它放在一起</h3><p>现在让我们重温一下来自思维模型的第一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y = x;</span><br><span class=\"line\">x = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<p>我建议你拿一张纸或一个绘图应用程序，一步一步地画出x和y变量的“连线”的情况图。</p>\n<p><strong>第一行的作用不大：</strong></p>\n<p>\b\b<img src=\"/blog_imgs/just_javascript/03/unnamed2.gif\" alt=\"\"></p>\n<ul>\n<li>声明一个x变量  <ul>\n<li>为x变量生成导线</li>\n</ul>\n</li>\n<li>给x赋值10<ul>\n<li>让x的导线指向10</li>\n</ul>\n</li>\n</ul>\n<p><strong>第二行很短，但它做了很多事情：</strong></p>\n<p>\b\b<img src=\"/blog_imgs/just_javascript/03/unnamed3.gif\" alt=\"\"></p>\n<ul>\n<li><p>声明一个y变量</p>\n<ul>\n<li>为y变量生成导线</li>\n</ul>\n</li>\n<li><p>把x的值赋给y</p>\n<ul>\n<li>计算表达式：x<ul>\n<li>我们要回答的问题是“x”</li>\n<li><strong>跟随x的导线——答案是值10</strong></li>\n</ul>\n</li>\n<li>x表达式结果是值10</li>\n<li>因此，将10的值赋给y</li>\n<li>把y的导线指向值10</li>\n</ul>\n<p><strong>最后，我们进入第三行：</strong></p>\n</li>\n</ul>\n<p>\b\b<img src=\"/blog_imgs/just_javascript/03/unnamed4.gif\" alt=\"\"></p>\n<ul>\n<li>将0的值赋给x<ul>\n<li>将x的导线指向值0</li>\n</ul>\n</li>\n</ul>\n<p>最后，x变量指向值0，y变量指向值10。注意y=x并不意味着将y指向“x”。我们不能把变量指向彼此！<strong>变量总是指向值</strong>。当我们看到一个赋值时，我们“询问”右边的值，并将左边的“线”指向它。</p>\n<p>我在思维模型中提到，把变量看作盒子是相当常见的。我们要建造的宇宙根本就没有盒子。<strong>它只有导线！</strong>这看起来有点烦人。为什么我们不能“将0和10放入变量中，而是将变量指向它们？”</p>\n<p>使用导线对于解释许多其他概念将是非常重要的，就像严格的等式，对象标识和变动。我们要坚持使用导线，所以你最好现在就开始习惯。</p>\n<p>我的宇宙充满了导线。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li><p><strong>原始值是不可变的：</strong>在我们的代码中，我们无法做任何事情来影响它们或以任何方式更改它们。他们保持原样。例如，不能对字符串值设置属性，因为它是原始值。数组不是原始值，所以我们可以设置它们的属性。</p>\n</li>\n<li><p><strong>变量不是值：</strong>每个变量都指向一个特定的值。我们可以使用=赋值运算符来更改它指向的值。</p>\n</li>\n<li><p><strong>变量就像导线：</strong>“导线”并不是JavaScript的概念——但是它帮助我们理解变量如何指向值。还有一种不同的“电线”，不是变量，但我们还没有讨论过。</p>\n</li>\n<li><p><strong>留意矛盾：</strong>如果你学到的两件事似乎互相矛盾，不要灰心。通常这是一个迹象，表明下面隐藏着更深层次的真相。</p>\n</li>\n<li><p><strong>名词和动词很重要：</strong>我们正在建立一个思维模型，这样我们就能对宇宙中可能发生或不可能发生的事情充满信心。随便马虎的说话是可以的，但我们的思维需要精确。</p>\n</li>\n</ul>\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p>本单元也有练习题供你练习！</p>\n<p><a href=\"https://el2.convertkit-mail.com/c/o8u6klng6ncwu4e40piv/6gtehou6oom6de/aHR0cHM6Ly9lZ2doZWFkaW8udHlwZWZvcm0uY29tL3RvL1JXSmczbT9lbWFpbD1ha2loaTk1QGdtYWlsLmNvbQ==\" target=\"_blank\" rel=\"noopener\">点击这里，通过一些简短的练习巩固这个心理模型。</a></p>\n<p><strong>不要跳过它们！</strong></p>\n<p>即使你可能熟悉变量的概念，这些练习将帮助你巩固我们正在建立的心理模型。我们需要这个基础才能继续更复杂的话题。</p>\n"},{"title":"《Just JavaScript》05. 计算数值2","date":"2020-05-18T09:36:08.000Z","_content":"\n事不宜迟，让我们继续我们的JavaScript之旅吧！\n\n![](/blog_imgs/just_javascript/05/type.png)\n\n在前面的模块中，我们研究了undefined、null、boolean和number。我们现在将继续计算数值——从bigint开始。\n\n## BigInts\n\n![](/blog_imgs/just_javascript/05/bigints.png)\n\nBigInts只是最近才添加到JavaScript中，所以你还不会看到它们被广泛使用。如果你使用版本较低的浏览器，它们将不起作用。常规数字不能精确地表示大整数，因此大整数填补了这一空白（字面上）：\n\n``` javascript\nlet alot = 9007199254740991n; // Notice n at the end \nconsole.log(alot + 1n); // 9007199254740992n \nconsole.log(alot + 2n); // 9007199254740993n \nconsole.log(alot + 3n); // 9007199254740994n \nconsole.log(alot + 4n); // 9007199254740995n \nconsole.log(alot + 5n); // 9007199254740996n \n```\n\n四舍五入可不是闹着玩的！这对于财务计算来说是非常重要的，因为精确性尤其重要。请记住，没有什么是免费的。真正数量庞大的操作可能需要时间和资源。\n\n我们的宇宙中有多少个BigInts？明确地说它们有任意的精度。这意味着**在我们的JavaScript世界中，有无限多个BigInts——数学中每个整数对应一个。**\n\n是吗？\n\n如果这听起来很奇怪，考虑一下你已经习惯了数学中存在无限整数的想法。（如果不是，请稍等片刻！）从“数学世界”到“JavaScript世界”并不是什么飞跃。\n\n（从那里，我们可以直接进入百事世界。）\n\n当然，在实践中，我们不可能把所有可能的高精度计算放进计算机内存。如果我们尝试，在某些时候，它会崩溃或冻结。但从概念上讲，计算伯爵(个人理解指计算机程序)可能永远忙着计算，从未停止过。\n\n## Strings\n\n![](/blog_imgs/just_javascript/05/string.png)\n\n在JavaScript用字符串表示文本。有三种方法可以可以写字符串（单引号、双引号和反引号），但结果是一样的：\n\n``` javascript\nconsole.log(typeof(\"こんにちは\")); // \"string\" \nconsole.log(typeof('こんにちは')); // \"string\" \nconsole.log(typeof( `こんにちは` )); // \"string\" \n```\n\n``` javascript\nconsole.log(2)\nconsole.log(\"hello\")\nconsole.log(undefined)\n```\n\n空字符串也是字符串：\n\n``` javascript\nconsole.log(typeof('')); // \"string\"\n```\n\n### 字符串不是对象\n\n所有字符串都有一些内置属性。\n\n``` javascript\nlet cat = 'Cheshire';\nconsole.log(cat.length); // 8\nconsole.log(cat[0]); // \"C\"\nconsole.log(cat[1]); // \"h\"\n```\n\n这并不意味着字符串就是对象！字符串属性是特殊的，其行为与对象属性不同。例如，不能将任何内容分配给cat[0]。字符串是原始值，所有原始值都是不可变的。\n\n### 每个可能的字符串的值\n\n**在我们的宇宙中，每个可能的字符串都有一个不同的值**。是的，这包括你祖母的娘家姓，十年前你用化名发表的同人小说，和还没有写完的《黑客帝国5》的剧本。\n\n当然，所有可能的字符串都不能完全放在计算机内存芯片中。但是每一个可能的字符串都可以放在你的脑子里。我们的JavaScript宇宙是人类的模型，而不是计算机的模型！\n\n这可能会引发一个问题。此代码是否创建字符串？\n\n``` javascript\n// Try it in your console\nlet answer = prompt('Enter your name');\nconsole.log(answer); // ?\n```\n\n或者它只是召唤一个已经存在于我们宇宙中的字符串？\n\n这个问题的答案取决于我们是“从外部”还是“从内部”学习JavaScript。\n\n在我们的思维模型之外，答案取决于具体的实现。字符串是表示为单个内存块、多个块还是串在一起的相似的东西，取决于JavaScript引擎。\n\n但在我们的思维模式中，这个问题并不意味着什么。我们不能建立一个实验来说明在我们的JavaScript宇宙中字符串是“被创建”还是“被调用”。\n\n为了保持我们的思维模型简单，我们将**所有可能的字符串值从一开始就保存了它们——每个不同的字符串都有一个值。**\n\n## Symbols\n\nSymbols是最近才加到JavaScript中的。\n\n``` javascript\nlet alohomora = Symbol();\nconsole.log(typeof(alohomora)); // \"symbol\"\n```\n\n如果不深入研究对象和属性，很难解释它们的目的和行为，所以现在我们将跳过它们。对不起，symbols！\n\n![](/blog_imgs/just_javascript/05/sym.png)\n\n## Objects\n\n最后，我们来说说对象。\n\n![](/blog_imgs/just_javascript/05/bracket.png)\n\n对象包括arrays, dates, RegExps和其他非原始值。\n\n``` javascript\nconsole.log(typeof({})); // \"object\"\nconsole.log(typeof([])); // \"object\"\nconsole.log(typeof(new Date())); // \"object\"\nconsole.log(typeof(/\\d+/)); // \"object\"\nconsole.log(typeof(Math)); // \"object\"\n```\n\n与之前的一切不同，对象不是原始值。这也意味着默认情况下，它们是可变的。我们可以通过. 或者[]访问他们的属性：\n\n``` javascript\nlet rapper = {\n    name: 'Malicious'\n};\nrapper.name = 'Malice'; // Dot notation\nrapper['name'] = 'No Malice'; // Bracket notation\n```\n\n我们还没有详细讨论属性，所以你对它们的思维模型可能是模糊的。我们将在未来的模块中讨论属性。\n\n### 创建我们自己的对象\n\n有一件事特别使计算伯爵对对象象感到兴奋。**我们可以创建更多对象，我们可以创建自己的对象。**\n\n在我们的思维模型中，我们讨论过的所有原始值——null, undefined, booleans, numbers和strings——塔门都“一直存在”。我们不能“制造”一个新字符串或一个新数字，我们只能“转换”那个值。\n\n``` javascript\nlet sisters = 3;\nlet musketeers = 3;\n```\n\n![](/blog_imgs/just_javascript/05/primitive.png)\n\n使对象区别于其他的是我们可以创建更多的对象。每次使用{}对象文本时，我们都会创建一个全新的对象值：\n\n``` javascript\nlet shrek = {};\nlet donkey = {};\n```\n\n![](/blog_imgs/just_javascript/05/obj.png)\n\n数组、日期和任何其他对象也是如此。例如，[]数组确实创建了一个新的数组值——以前从未存在过的值。\n\n### 对象消失了吗？\n\n你可能会想：”对象会永远消失，还是永远在周围徘徊？JavaScript的设计方式是从我们的代码中我们不知道是怎么回事”。例如，我们不能销毁对象：\n\n``` javascript\nlet junk = {};\njunk = null; // Doesn't necessarily destroy an object\n```\n\n而且，JavaScript是一们拥有垃圾回收功能的语言。\n\n这意味着尽管我们不能销毁一个对象，如果无法通过代码中的导线跟踪它，它最终可能消失。\n\n![](/blog_imgs/just_javascript/05/obj1.gif)\n\nJavaScript不能保证垃圾收集何时发生。\n\n除非你想弄清楚为什么一个应用程序使用了太多的内存，否则你不需要经常考虑垃圾收集。我在这里只提到它是为了让你知道我们可以创造对象，但我们不能销毁它们。\n\n在我的宇宙中，对象和函数漂浮在离我的代码最近的地方。这提醒我，我可以操纵他们，甚至更多地使用它们。\n\n## Functions\n\n![](/blog_imgs/just_javascript/05/fun.png)\n\n将函数看作与代码分离的值是特别奇怪的。毕竟，它们也是我写的代码。不是吗？\n\n### 函数也是值\n\n我们定义函数，以便以后调用它们并在其中运行代码。然而，要真正理解JavaScript中的函数，我们需要暂时忘记它们为什么有用。相反，我们将函数看作是另一种值：一个数字、一个对象、一个函数。\n\n为了理解函数，我们将它们与数字和对象进行比较。\n\n首先，考虑运行 `console.log(2)` 七次的循环： \n\n``` javascript\nfor (let i = 0; i < 7; i++) {\n    console.log(2)\n}\n```\n\n它给 `console.log()` 传递给多少不同的值。为了回答这个问题，让我们回忆一下当我们写下2时是什么意思。字面上它是一个数字，文字是一种表达式——这对我们宇宙来说是个问题。在我们宇宙中，每个数字只有一个值，所以它通过每次“调用”相同的值——数字2的来“回答”我们的问题。**所以答案是一个值，**我们将看到七次打印，但每次调用都传递相同的值。\n\n现在来简单的复习一下对象。\n\n下面是运行 `console.log({})` 七次的另一个for循环：\n\n``` javascript\nfor(let i = 0; i < 7; i++) {\n    console.log({})\n}\n```\n\n现在它传递给多少不同的值给 `console.log()？` 在这里， `{}` 也是一个文本——不同的是它是一个对象文本。正如我们刚刚了解到的，JavaScript宇宙不会通过调用任何东西来“回答”一个对象。相反，他会创建新的对象值——这是 `{}` 对象文本的结果。**所以上面的代码创建并记录了七个完全不同的对象值。**\n\n先把它抛之脑后。\n\n现在让我们来看看函数。\n\n``` javascript\nfor (let i = 0; i < 7; i++) {\n    console.log(function() {});\n}\n```\n\n**现在它传递给多少不同的值给 `console.log()` ？**\n\n![](/blog_imgs/just_javascript//03/spoilers.jpg)\n\n在你决定答案之前不要再滚动。\n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n答案是7。\n\n**每当我们执行一行包含函数表达式的代码时，一个全新的函数值就会出现在我们的宇宙中。**\n\n![](/blog_imgs/just_javascript/05/fun1.gif)\n\n**这里， `function(){}` 也是一个表达式**。与任何表达式一样，函数表达式向JavaScript宇宙提出一个“问题”——它通过每次我们提问时创建一个新的函数值来回答我们。这与 `{}` 在执行时创建新对象值的方式非常相似。函数就像对象！\n\n严格来说，函数是JavaScript中的对象。我们将继续将它们视为单独的基本类型，因为它们与常规对象相比具有独特的功能。但是，一般来说，如果你能对一个对象做些什么，你也可以对一个函数做。它们是非常特殊的对象。\n\n### 调用函数\n\n下面的代码打印什么？\n\n``` javascript\nlet countDwarves = function() {\n    return 7;\n};\nlet dwarves = countDwarves;\nconsole.log(dwarves);\n```\n\n你可能认为它打印7，特别是如果你不仔细看的话。\n\n现在检查控制台中的这个片段！它打印的确切内容取决于浏览器，但您将看到函数本身，而不是那里的数字7。\n\n如果你遵循我们的思维模型，这种表现应该是有道理的：\n\n1. 首先，我们用一个 `function(){}` 表达式创建了一个新的函数值，并将 `countdwaves` 变量指向这个值。\n2. 接下来，我们将 `dwarves` 变量指向 `countDwarves` 所指向的值——这是相同的函数值\n3. 最后，我们输出了 `dwarves` 当前指向的值。\n\n在任何时候，我们都没有调用函数！\n\n结果， `countDwarves` 和 `dwarves` 都指向同一个值，这恰好是一个函数。所以，函数是值，我们可以将变量指向它们，就像处理数字或对象一样。\n\n**当然，如果我们想调用函数，我们也可以这样做：**\n\n``` javascript\nlet countDwarves = function() {\n    return 7;\n};\nlet dwarves = countDwarves(); // () is a function call\nconsole.log(dwarves);\n```\n\n注意，let声明和=赋值都与函数调用无关。是 `()` 执行函数调用——而且是单独执行的！\n\n添加 `()` 改变了代码的含义：\n\n* 让 `dwarves=countDwarves` 意味着“将 `dwarves` 指向 `countDwarves` 所指向的值”\n\n* let `dwarves=countDwarves()` 表示“将 `dwarves` 指向 `countDwarves` 所指向的函数**返回的值**。”\n\n实际上， `countDwarves()` 也是一个表达式。它被称为调用表达式。为了“应答”调用表达式，JavaScript在函数内部运行代码，并将返回的值作为结果（在本例中是7）。\n\n我们将在未来的模块中更详细地研究函数调用。\n\n# 总结\n\n那真是一段不同寻常的旅程！在最后两个模块中，我们看了JavaScript中的每个值类型。让我们结合计算伯爵来概括每种类型有多少个值，从不同的原始类型开始：\n\n![](/blog_imgs/just_javascript/05/primitive-type.png)\n\n* `Undefined` ：仅仅只是个值，表示没有定义。\n* `Null` ：一个值，空。\n* `Booleans` ：两个值: true 和 false。\n* `Numbers` ： 数学中每个浮点数的值。\n* `BigInts` ：每一个可能的整数的值。\n* `Strings` ：每个可能的字符串的值。\n* `Symbols` ：我们暂时跳过了Symbols，但总有一天我们会讨论到它们的！\n\n以下类型是特殊的，因为它们让我们可以创造自己的价值：\n\n![](/blog_imgs/just_javascript/05/special-type.png)\n\n* `Objects` ：表示执行的每个对象文本都的值。\n* `Function` ：执行的每个函数表达式的值。\n\n访问JavaScript的不同“天体”很有趣。现在我们已经计算了所有的值，我们也了解了是什么使它们彼此不同。例如，写2或“hello”总是“调用”相同的数字或字符串值。但是编写 `{}` 或 `function()` {}`总是会创建一个全新的、不同的值。这个概念对于理解JavaScript中的相等至关重要，这将是下一个模块的主题。\n\n# 练习\n\n本单元也有练习题供你练习！\n\n[点击这里，通过一些简短的练习巩固这个思维模型。](https://el2.convertkit-mail.com/c/r8up8kx6pxc9u0274lh2/mot7h6u0zplx4n/aHR0cHM6Ly9lZ2doZWFkaW8udHlwZWZvcm0uY29tL3RvL1NURWVNeT9lbWFpbD1ha2loaTk1QGdtYWlsLmNvbQ==)\n\n**不要跳过它们！**\n\n即使你可能熟悉不同类型的值，这些练习将帮助你巩固我们正在建立的思维模型。我们需要打好基础才能继续更复杂的话题。\n","source":"_posts/《Just-JavaScript》05-计算数值2.md","raw":"---\ntitle: 《Just JavaScript》05. 计算数值2\ndate: 2020-05-18 17:36:08  \ntags:\n---\n\n事不宜迟，让我们继续我们的JavaScript之旅吧！\n\n![](/blog_imgs/just_javascript/05/type.png)\n\n在前面的模块中，我们研究了undefined、null、boolean和number。我们现在将继续计算数值——从bigint开始。\n\n## BigInts\n\n![](/blog_imgs/just_javascript/05/bigints.png)\n\nBigInts只是最近才添加到JavaScript中，所以你还不会看到它们被广泛使用。如果你使用版本较低的浏览器，它们将不起作用。常规数字不能精确地表示大整数，因此大整数填补了这一空白（字面上）：\n\n``` javascript\nlet alot = 9007199254740991n; // Notice n at the end \nconsole.log(alot + 1n); // 9007199254740992n \nconsole.log(alot + 2n); // 9007199254740993n \nconsole.log(alot + 3n); // 9007199254740994n \nconsole.log(alot + 4n); // 9007199254740995n \nconsole.log(alot + 5n); // 9007199254740996n \n```\n\n四舍五入可不是闹着玩的！这对于财务计算来说是非常重要的，因为精确性尤其重要。请记住，没有什么是免费的。真正数量庞大的操作可能需要时间和资源。\n\n我们的宇宙中有多少个BigInts？明确地说它们有任意的精度。这意味着**在我们的JavaScript世界中，有无限多个BigInts——数学中每个整数对应一个。**\n\n是吗？\n\n如果这听起来很奇怪，考虑一下你已经习惯了数学中存在无限整数的想法。（如果不是，请稍等片刻！）从“数学世界”到“JavaScript世界”并不是什么飞跃。\n\n（从那里，我们可以直接进入百事世界。）\n\n当然，在实践中，我们不可能把所有可能的高精度计算放进计算机内存。如果我们尝试，在某些时候，它会崩溃或冻结。但从概念上讲，计算伯爵(个人理解指计算机程序)可能永远忙着计算，从未停止过。\n\n## Strings\n\n![](/blog_imgs/just_javascript/05/string.png)\n\n在JavaScript用字符串表示文本。有三种方法可以可以写字符串（单引号、双引号和反引号），但结果是一样的：\n\n``` javascript\nconsole.log(typeof(\"こんにちは\")); // \"string\" \nconsole.log(typeof('こんにちは')); // \"string\" \nconsole.log(typeof( `こんにちは` )); // \"string\" \n```\n\n``` javascript\nconsole.log(2)\nconsole.log(\"hello\")\nconsole.log(undefined)\n```\n\n空字符串也是字符串：\n\n``` javascript\nconsole.log(typeof('')); // \"string\"\n```\n\n### 字符串不是对象\n\n所有字符串都有一些内置属性。\n\n``` javascript\nlet cat = 'Cheshire';\nconsole.log(cat.length); // 8\nconsole.log(cat[0]); // \"C\"\nconsole.log(cat[1]); // \"h\"\n```\n\n这并不意味着字符串就是对象！字符串属性是特殊的，其行为与对象属性不同。例如，不能将任何内容分配给cat[0]。字符串是原始值，所有原始值都是不可变的。\n\n### 每个可能的字符串的值\n\n**在我们的宇宙中，每个可能的字符串都有一个不同的值**。是的，这包括你祖母的娘家姓，十年前你用化名发表的同人小说，和还没有写完的《黑客帝国5》的剧本。\n\n当然，所有可能的字符串都不能完全放在计算机内存芯片中。但是每一个可能的字符串都可以放在你的脑子里。我们的JavaScript宇宙是人类的模型，而不是计算机的模型！\n\n这可能会引发一个问题。此代码是否创建字符串？\n\n``` javascript\n// Try it in your console\nlet answer = prompt('Enter your name');\nconsole.log(answer); // ?\n```\n\n或者它只是召唤一个已经存在于我们宇宙中的字符串？\n\n这个问题的答案取决于我们是“从外部”还是“从内部”学习JavaScript。\n\n在我们的思维模型之外，答案取决于具体的实现。字符串是表示为单个内存块、多个块还是串在一起的相似的东西，取决于JavaScript引擎。\n\n但在我们的思维模式中，这个问题并不意味着什么。我们不能建立一个实验来说明在我们的JavaScript宇宙中字符串是“被创建”还是“被调用”。\n\n为了保持我们的思维模型简单，我们将**所有可能的字符串值从一开始就保存了它们——每个不同的字符串都有一个值。**\n\n## Symbols\n\nSymbols是最近才加到JavaScript中的。\n\n``` javascript\nlet alohomora = Symbol();\nconsole.log(typeof(alohomora)); // \"symbol\"\n```\n\n如果不深入研究对象和属性，很难解释它们的目的和行为，所以现在我们将跳过它们。对不起，symbols！\n\n![](/blog_imgs/just_javascript/05/sym.png)\n\n## Objects\n\n最后，我们来说说对象。\n\n![](/blog_imgs/just_javascript/05/bracket.png)\n\n对象包括arrays, dates, RegExps和其他非原始值。\n\n``` javascript\nconsole.log(typeof({})); // \"object\"\nconsole.log(typeof([])); // \"object\"\nconsole.log(typeof(new Date())); // \"object\"\nconsole.log(typeof(/\\d+/)); // \"object\"\nconsole.log(typeof(Math)); // \"object\"\n```\n\n与之前的一切不同，对象不是原始值。这也意味着默认情况下，它们是可变的。我们可以通过. 或者[]访问他们的属性：\n\n``` javascript\nlet rapper = {\n    name: 'Malicious'\n};\nrapper.name = 'Malice'; // Dot notation\nrapper['name'] = 'No Malice'; // Bracket notation\n```\n\n我们还没有详细讨论属性，所以你对它们的思维模型可能是模糊的。我们将在未来的模块中讨论属性。\n\n### 创建我们自己的对象\n\n有一件事特别使计算伯爵对对象象感到兴奋。**我们可以创建更多对象，我们可以创建自己的对象。**\n\n在我们的思维模型中，我们讨论过的所有原始值——null, undefined, booleans, numbers和strings——塔门都“一直存在”。我们不能“制造”一个新字符串或一个新数字，我们只能“转换”那个值。\n\n``` javascript\nlet sisters = 3;\nlet musketeers = 3;\n```\n\n![](/blog_imgs/just_javascript/05/primitive.png)\n\n使对象区别于其他的是我们可以创建更多的对象。每次使用{}对象文本时，我们都会创建一个全新的对象值：\n\n``` javascript\nlet shrek = {};\nlet donkey = {};\n```\n\n![](/blog_imgs/just_javascript/05/obj.png)\n\n数组、日期和任何其他对象也是如此。例如，[]数组确实创建了一个新的数组值——以前从未存在过的值。\n\n### 对象消失了吗？\n\n你可能会想：”对象会永远消失，还是永远在周围徘徊？JavaScript的设计方式是从我们的代码中我们不知道是怎么回事”。例如，我们不能销毁对象：\n\n``` javascript\nlet junk = {};\njunk = null; // Doesn't necessarily destroy an object\n```\n\n而且，JavaScript是一们拥有垃圾回收功能的语言。\n\n这意味着尽管我们不能销毁一个对象，如果无法通过代码中的导线跟踪它，它最终可能消失。\n\n![](/blog_imgs/just_javascript/05/obj1.gif)\n\nJavaScript不能保证垃圾收集何时发生。\n\n除非你想弄清楚为什么一个应用程序使用了太多的内存，否则你不需要经常考虑垃圾收集。我在这里只提到它是为了让你知道我们可以创造对象，但我们不能销毁它们。\n\n在我的宇宙中，对象和函数漂浮在离我的代码最近的地方。这提醒我，我可以操纵他们，甚至更多地使用它们。\n\n## Functions\n\n![](/blog_imgs/just_javascript/05/fun.png)\n\n将函数看作与代码分离的值是特别奇怪的。毕竟，它们也是我写的代码。不是吗？\n\n### 函数也是值\n\n我们定义函数，以便以后调用它们并在其中运行代码。然而，要真正理解JavaScript中的函数，我们需要暂时忘记它们为什么有用。相反，我们将函数看作是另一种值：一个数字、一个对象、一个函数。\n\n为了理解函数，我们将它们与数字和对象进行比较。\n\n首先，考虑运行 `console.log(2)` 七次的循环： \n\n``` javascript\nfor (let i = 0; i < 7; i++) {\n    console.log(2)\n}\n```\n\n它给 `console.log()` 传递给多少不同的值。为了回答这个问题，让我们回忆一下当我们写下2时是什么意思。字面上它是一个数字，文字是一种表达式——这对我们宇宙来说是个问题。在我们宇宙中，每个数字只有一个值，所以它通过每次“调用”相同的值——数字2的来“回答”我们的问题。**所以答案是一个值，**我们将看到七次打印，但每次调用都传递相同的值。\n\n现在来简单的复习一下对象。\n\n下面是运行 `console.log({})` 七次的另一个for循环：\n\n``` javascript\nfor(let i = 0; i < 7; i++) {\n    console.log({})\n}\n```\n\n现在它传递给多少不同的值给 `console.log()？` 在这里， `{}` 也是一个文本——不同的是它是一个对象文本。正如我们刚刚了解到的，JavaScript宇宙不会通过调用任何东西来“回答”一个对象。相反，他会创建新的对象值——这是 `{}` 对象文本的结果。**所以上面的代码创建并记录了七个完全不同的对象值。**\n\n先把它抛之脑后。\n\n现在让我们来看看函数。\n\n``` javascript\nfor (let i = 0; i < 7; i++) {\n    console.log(function() {});\n}\n```\n\n**现在它传递给多少不同的值给 `console.log()` ？**\n\n![](/blog_imgs/just_javascript//03/spoilers.jpg)\n\n在你决定答案之前不要再滚动。\n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n`... ` \n\n答案是7。\n\n**每当我们执行一行包含函数表达式的代码时，一个全新的函数值就会出现在我们的宇宙中。**\n\n![](/blog_imgs/just_javascript/05/fun1.gif)\n\n**这里， `function(){}` 也是一个表达式**。与任何表达式一样，函数表达式向JavaScript宇宙提出一个“问题”——它通过每次我们提问时创建一个新的函数值来回答我们。这与 `{}` 在执行时创建新对象值的方式非常相似。函数就像对象！\n\n严格来说，函数是JavaScript中的对象。我们将继续将它们视为单独的基本类型，因为它们与常规对象相比具有独特的功能。但是，一般来说，如果你能对一个对象做些什么，你也可以对一个函数做。它们是非常特殊的对象。\n\n### 调用函数\n\n下面的代码打印什么？\n\n``` javascript\nlet countDwarves = function() {\n    return 7;\n};\nlet dwarves = countDwarves;\nconsole.log(dwarves);\n```\n\n你可能认为它打印7，特别是如果你不仔细看的话。\n\n现在检查控制台中的这个片段！它打印的确切内容取决于浏览器，但您将看到函数本身，而不是那里的数字7。\n\n如果你遵循我们的思维模型，这种表现应该是有道理的：\n\n1. 首先，我们用一个 `function(){}` 表达式创建了一个新的函数值，并将 `countdwaves` 变量指向这个值。\n2. 接下来，我们将 `dwarves` 变量指向 `countDwarves` 所指向的值——这是相同的函数值\n3. 最后，我们输出了 `dwarves` 当前指向的值。\n\n在任何时候，我们都没有调用函数！\n\n结果， `countDwarves` 和 `dwarves` 都指向同一个值，这恰好是一个函数。所以，函数是值，我们可以将变量指向它们，就像处理数字或对象一样。\n\n**当然，如果我们想调用函数，我们也可以这样做：**\n\n``` javascript\nlet countDwarves = function() {\n    return 7;\n};\nlet dwarves = countDwarves(); // () is a function call\nconsole.log(dwarves);\n```\n\n注意，let声明和=赋值都与函数调用无关。是 `()` 执行函数调用——而且是单独执行的！\n\n添加 `()` 改变了代码的含义：\n\n* 让 `dwarves=countDwarves` 意味着“将 `dwarves` 指向 `countDwarves` 所指向的值”\n\n* let `dwarves=countDwarves()` 表示“将 `dwarves` 指向 `countDwarves` 所指向的函数**返回的值**。”\n\n实际上， `countDwarves()` 也是一个表达式。它被称为调用表达式。为了“应答”调用表达式，JavaScript在函数内部运行代码，并将返回的值作为结果（在本例中是7）。\n\n我们将在未来的模块中更详细地研究函数调用。\n\n# 总结\n\n那真是一段不同寻常的旅程！在最后两个模块中，我们看了JavaScript中的每个值类型。让我们结合计算伯爵来概括每种类型有多少个值，从不同的原始类型开始：\n\n![](/blog_imgs/just_javascript/05/primitive-type.png)\n\n* `Undefined` ：仅仅只是个值，表示没有定义。\n* `Null` ：一个值，空。\n* `Booleans` ：两个值: true 和 false。\n* `Numbers` ： 数学中每个浮点数的值。\n* `BigInts` ：每一个可能的整数的值。\n* `Strings` ：每个可能的字符串的值。\n* `Symbols` ：我们暂时跳过了Symbols，但总有一天我们会讨论到它们的！\n\n以下类型是特殊的，因为它们让我们可以创造自己的价值：\n\n![](/blog_imgs/just_javascript/05/special-type.png)\n\n* `Objects` ：表示执行的每个对象文本都的值。\n* `Function` ：执行的每个函数表达式的值。\n\n访问JavaScript的不同“天体”很有趣。现在我们已经计算了所有的值，我们也了解了是什么使它们彼此不同。例如，写2或“hello”总是“调用”相同的数字或字符串值。但是编写 `{}` 或 `function()` {}`总是会创建一个全新的、不同的值。这个概念对于理解JavaScript中的相等至关重要，这将是下一个模块的主题。\n\n# 练习\n\n本单元也有练习题供你练习！\n\n[点击这里，通过一些简短的练习巩固这个思维模型。](https://el2.convertkit-mail.com/c/r8up8kx6pxc9u0274lh2/mot7h6u0zplx4n/aHR0cHM6Ly9lZ2doZWFkaW8udHlwZWZvcm0uY29tL3RvL1NURWVNeT9lbWFpbD1ha2loaTk1QGdtYWlsLmNvbQ==)\n\n**不要跳过它们！**\n\n即使你可能熟悉不同类型的值，这些练习将帮助你巩固我们正在建立的思维模型。我们需要打好基础才能继续更复杂的话题。\n","slug":"《Just-JavaScript》05-计算数值2","published":1,"updated":"2020-06-03T08:58:56.533Z","_id":"ckaz22df10000sz9hd5r66b3q","comments":1,"layout":"post","photos":[],"link":"","content":"<p>事不宜迟，让我们继续我们的JavaScript之旅吧！</p>\n<p><img src=\"/blog_imgs/just_javascript/05/type.png\" alt=\"\"></p>\n<p>在前面的模块中，我们研究了undefined、null、boolean和number。我们现在将继续计算数值——从bigint开始。</p>\n<h2 id=\"BigInts\"><a href=\"#BigInts\" class=\"headerlink\" title=\"BigInts\"></a>BigInts</h2><p><img src=\"/blog_imgs/just_javascript/05/bigints.png\" alt=\"\"></p>\n<p>BigInts只是最近才添加到JavaScript中，所以你还不会看到它们被广泛使用。如果你使用版本较低的浏览器，它们将不起作用。常规数字不能精确地表示大整数，因此大整数填补了这一空白（字面上）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> alot = <span class=\"number\">9007199254740991n</span>; <span class=\"comment\">// Notice n at the end </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(alot + <span class=\"number\">1n</span>); <span class=\"comment\">// 9007199254740992n </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(alot + <span class=\"number\">2n</span>); <span class=\"comment\">// 9007199254740993n </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(alot + <span class=\"number\">3n</span>); <span class=\"comment\">// 9007199254740994n </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(alot + <span class=\"number\">4n</span>); <span class=\"comment\">// 9007199254740995n </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(alot + <span class=\"number\">5n</span>); <span class=\"comment\">// 9007199254740996n</span></span><br></pre></td></tr></table></figure>\n\n<p>四舍五入可不是闹着玩的！这对于财务计算来说是非常重要的，因为精确性尤其重要。请记住，没有什么是免费的。真正数量庞大的操作可能需要时间和资源。</p>\n<p>我们的宇宙中有多少个BigInts？明确地说它们有任意的精度。这意味着<strong>在我们的JavaScript世界中，有无限多个BigInts——数学中每个整数对应一个。</strong></p>\n<p>是吗？</p>\n<p>如果这听起来很奇怪，考虑一下你已经习惯了数学中存在无限整数的想法。（如果不是，请稍等片刻！）从“数学世界”到“JavaScript世界”并不是什么飞跃。</p>\n<p>（从那里，我们可以直接进入百事世界。）</p>\n<p>当然，在实践中，我们不可能把所有可能的高精度计算放进计算机内存。如果我们尝试，在某些时候，它会崩溃或冻结。但从概念上讲，计算伯爵(个人理解指计算机程序)可能永远忙着计算，从未停止过。</p>\n<h2 id=\"Strings\"><a href=\"#Strings\" class=\"headerlink\" title=\"Strings\"></a>Strings</h2><p><img src=\"/blog_imgs/just_javascript/05/string.png\" alt=\"\"></p>\n<p>在JavaScript用字符串表示文本。有三种方法可以可以写字符串（单引号、双引号和反引号），但结果是一样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"string\">\"こんにちは\"</span>)); <span class=\"comment\">// \"string\" </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"string\">'こんにちは'</span>)); <span class=\"comment\">// \"string\" </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>( <span class=\"string\">`こんにちは`</span> )); <span class=\"comment\">// \"string\"</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello\"</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">undefined</span>)</span><br></pre></td></tr></table></figure>\n\n<p>空字符串也是字符串：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"string\">''</span>)); <span class=\"comment\">// \"string\"</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字符串不是对象\"><a href=\"#字符串不是对象\" class=\"headerlink\" title=\"字符串不是对象\"></a>字符串不是对象</h3><p>所有字符串都有一些内置属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> cat = <span class=\"string\">'Cheshire'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.length); <span class=\"comment\">// 8</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat[<span class=\"number\">0</span>]); <span class=\"comment\">// \"C\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat[<span class=\"number\">1</span>]); <span class=\"comment\">// \"h\"</span></span><br></pre></td></tr></table></figure>\n\n<p>这并不意味着字符串就是对象！字符串属性是特殊的，其行为与对象属性不同。例如，不能将任何内容分配给cat[0]。字符串是原始值，所有原始值都是不可变的。</p>\n<h3 id=\"每个可能的字符串的值\"><a href=\"#每个可能的字符串的值\" class=\"headerlink\" title=\"每个可能的字符串的值\"></a>每个可能的字符串的值</h3><p><strong>在我们的宇宙中，每个可能的字符串都有一个不同的值</strong>。是的，这包括你祖母的娘家姓，十年前你用化名发表的同人小说，和还没有写完的《黑客帝国5》的剧本。</p>\n<p>当然，所有可能的字符串都不能完全放在计算机内存芯片中。但是每一个可能的字符串都可以放在你的脑子里。我们的JavaScript宇宙是人类的模型，而不是计算机的模型！</p>\n<p>这可能会引发一个问题。此代码是否创建字符串？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Try it in your console</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> answer = prompt(<span class=\"string\">'Enter your name'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(answer); <span class=\"comment\">// ?</span></span><br></pre></td></tr></table></figure>\n\n<p>或者它只是召唤一个已经存在于我们宇宙中的字符串？</p>\n<p>这个问题的答案取决于我们是“从外部”还是“从内部”学习JavaScript。</p>\n<p>在我们的思维模型之外，答案取决于具体的实现。字符串是表示为单个内存块、多个块还是串在一起的相似的东西，取决于JavaScript引擎。</p>\n<p>但在我们的思维模式中，这个问题并不意味着什么。我们不能建立一个实验来说明在我们的JavaScript宇宙中字符串是“被创建”还是“被调用”。</p>\n<p>为了保持我们的思维模型简单，我们将<strong>所有可能的字符串值从一开始就保存了它们——每个不同的字符串都有一个值。</strong></p>\n<h2 id=\"Symbols\"><a href=\"#Symbols\" class=\"headerlink\" title=\"Symbols\"></a>Symbols</h2><p>Symbols是最近才加到JavaScript中的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> alohomora = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(alohomora)); <span class=\"comment\">// \"symbol\"</span></span><br></pre></td></tr></table></figure>\n\n<p>如果不深入研究对象和属性，很难解释它们的目的和行为，所以现在我们将跳过它们。对不起，symbols！</p>\n<p><img src=\"/blog_imgs/just_javascript/05/sym.png\" alt=\"\"></p>\n<h2 id=\"Objects\"><a href=\"#Objects\" class=\"headerlink\" title=\"Objects\"></a>Objects</h2><p>最后，我们来说说对象。</p>\n<p><img src=\"/blog_imgs/just_javascript/05/bracket.png\" alt=\"\"></p>\n<p>对象包括arrays, dates, RegExps和其他非原始值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(&#123;&#125;)); <span class=\"comment\">// \"object\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>([])); <span class=\"comment\">// \"object\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>())); <span class=\"comment\">// \"object\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"regexp\">/\\d+/</span>)); <span class=\"comment\">// \"object\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"built_in\">Math</span>)); <span class=\"comment\">// \"object\"</span></span><br></pre></td></tr></table></figure>\n\n<p>与之前的一切不同，对象不是原始值。这也意味着默认情况下，它们是可变的。我们可以通过. 或者[]访问他们的属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> rapper = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'Malicious'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">rapper.name = <span class=\"string\">'Malice'</span>; <span class=\"comment\">// Dot notation</span></span><br><span class=\"line\">rapper[<span class=\"string\">'name'</span>] = <span class=\"string\">'No Malice'</span>; <span class=\"comment\">// Bracket notation</span></span><br></pre></td></tr></table></figure>\n\n<p>我们还没有详细讨论属性，所以你对它们的思维模型可能是模糊的。我们将在未来的模块中讨论属性。</p>\n<h3 id=\"创建我们自己的对象\"><a href=\"#创建我们自己的对象\" class=\"headerlink\" title=\"创建我们自己的对象\"></a>创建我们自己的对象</h3><p>有一件事特别使计算伯爵对对象象感到兴奋。<strong>我们可以创建更多对象，我们可以创建自己的对象。</strong></p>\n<p>在我们的思维模型中，我们讨论过的所有原始值——null, undefined, booleans, numbers和strings——塔门都“一直存在”。我们不能“制造”一个新字符串或一个新数字，我们只能“转换”那个值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sisters = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> musketeers = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/blog_imgs/just_javascript/05/primitive.png\" alt=\"\"></p>\n<p>使对象区别于其他的是我们可以创建更多的对象。每次使用{}对象文本时，我们都会创建一个全新的对象值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> shrek = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> donkey = &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/blog_imgs/just_javascript/05/obj.png\" alt=\"\"></p>\n<p>数组、日期和任何其他对象也是如此。例如，[]数组确实创建了一个新的数组值——以前从未存在过的值。</p>\n<h3 id=\"对象消失了吗？\"><a href=\"#对象消失了吗？\" class=\"headerlink\" title=\"对象消失了吗？\"></a>对象消失了吗？</h3><p>你可能会想：”对象会永远消失，还是永远在周围徘徊？JavaScript的设计方式是从我们的代码中我们不知道是怎么回事”。例如，我们不能销毁对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> junk = &#123;&#125;;</span><br><span class=\"line\">junk = <span class=\"literal\">null</span>; <span class=\"comment\">// Doesn't necessarily destroy an object</span></span><br></pre></td></tr></table></figure>\n\n<p>而且，JavaScript是一们拥有垃圾回收功能的语言。</p>\n<p>这意味着尽管我们不能销毁一个对象，如果无法通过代码中的导线跟踪它，它最终可能消失。</p>\n<p><img src=\"/blog_imgs/just_javascript/05/obj1.gif\" alt=\"\"></p>\n<p>JavaScript不能保证垃圾收集何时发生。</p>\n<p>除非你想弄清楚为什么一个应用程序使用了太多的内存，否则你不需要经常考虑垃圾收集。我在这里只提到它是为了让你知道我们可以创造对象，但我们不能销毁它们。</p>\n<p>在我的宇宙中，对象和函数漂浮在离我的代码最近的地方。这提醒我，我可以操纵他们，甚至更多地使用它们。</p>\n<h2 id=\"Functions\"><a href=\"#Functions\" class=\"headerlink\" title=\"Functions\"></a>Functions</h2><p><img src=\"/blog_imgs/just_javascript/05/fun.png\" alt=\"\"></p>\n<p>将函数看作与代码分离的值是特别奇怪的。毕竟，它们也是我写的代码。不是吗？</p>\n<h3 id=\"函数也是值\"><a href=\"#函数也是值\" class=\"headerlink\" title=\"函数也是值\"></a>函数也是值</h3><p>我们定义函数，以便以后调用它们并在其中运行代码。然而，要真正理解JavaScript中的函数，我们需要暂时忘记它们为什么有用。相反，我们将函数看作是另一种值：一个数字、一个对象、一个函数。</p>\n<p>为了理解函数，我们将它们与数字和对象进行比较。</p>\n<p>首先，考虑运行 <code>console.log(2)</code> 七次的循环： </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">7</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它给 <code>console.log()</code> 传递给多少不同的值。为了回答这个问题，让我们回忆一下当我们写下2时是什么意思。字面上它是一个数字，文字是一种表达式——这对我们宇宙来说是个问题。在我们宇宙中，每个数字只有一个值，所以它通过每次“调用”相同的值——数字2的来“回答”我们的问题。<strong>所以答案是一个值，</strong>我们将看到七次打印，但每次调用都传递相同的值。</p>\n<p>现在来简单的复习一下对象。</p>\n<p>下面是运行 <code>console.log({})</code> 七次的另一个for循环：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">7</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(&#123;&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在它传递给多少不同的值给 <code>console.log()？</code> 在这里， <code>{}</code> 也是一个文本——不同的是它是一个对象文本。正如我们刚刚了解到的，JavaScript宇宙不会通过调用任何东西来“回答”一个对象。相反，他会创建新的对象值——这是 <code>{}</code> 对象文本的结果。<strong>所以上面的代码创建并记录了七个完全不同的对象值。</strong></p>\n<p>先把它抛之脑后。</p>\n<p>现在让我们来看看函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">7</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>现在它传递给多少不同的值给 <code>console.log()</code> ？</strong></p>\n<p><img src=\"/blog_imgs/just_javascript//03/spoilers.jpg\" alt=\"\"></p>\n<p>在你决定答案之前不要再滚动。</p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p>答案是7。</p>\n<p><strong>每当我们执行一行包含函数表达式的代码时，一个全新的函数值就会出现在我们的宇宙中。</strong></p>\n<p><img src=\"/blog_imgs/just_javascript/05/fun1.gif\" alt=\"\"></p>\n<p><strong>这里， <code>function(){}</code> 也是一个表达式</strong>。与任何表达式一样，函数表达式向JavaScript宇宙提出一个“问题”——它通过每次我们提问时创建一个新的函数值来回答我们。这与 <code>{}</code> 在执行时创建新对象值的方式非常相似。函数就像对象！</p>\n<p>严格来说，函数是JavaScript中的对象。我们将继续将它们视为单独的基本类型，因为它们与常规对象相比具有独特的功能。但是，一般来说，如果你能对一个对象做些什么，你也可以对一个函数做。它们是非常特殊的对象。</p>\n<h3 id=\"调用函数\"><a href=\"#调用函数\" class=\"headerlink\" title=\"调用函数\"></a>调用函数</h3><p>下面的代码打印什么？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> countDwarves = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">7</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dwarves = countDwarves;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dwarves);</span><br></pre></td></tr></table></figure>\n\n<p>你可能认为它打印7，特别是如果你不仔细看的话。</p>\n<p>现在检查控制台中的这个片段！它打印的确切内容取决于浏览器，但您将看到函数本身，而不是那里的数字7。</p>\n<p>如果你遵循我们的思维模型，这种表现应该是有道理的：</p>\n<ol>\n<li>首先，我们用一个 <code>function(){}</code> 表达式创建了一个新的函数值，并将 <code>countdwaves</code> 变量指向这个值。</li>\n<li>接下来，我们将 <code>dwarves</code> 变量指向 <code>countDwarves</code> 所指向的值——这是相同的函数值</li>\n<li>最后，我们输出了 <code>dwarves</code> 当前指向的值。</li>\n</ol>\n<p>在任何时候，我们都没有调用函数！</p>\n<p>结果， <code>countDwarves</code> 和 <code>dwarves</code> 都指向同一个值，这恰好是一个函数。所以，函数是值，我们可以将变量指向它们，就像处理数字或对象一样。</p>\n<p><strong>当然，如果我们想调用函数，我们也可以这样做：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> countDwarves = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">7</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dwarves = countDwarves(); <span class=\"comment\">// () is a function call</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dwarves);</span><br></pre></td></tr></table></figure>\n\n<p>注意，let声明和=赋值都与函数调用无关。是 <code>()</code> 执行函数调用——而且是单独执行的！</p>\n<p>添加 <code>()</code> 改变了代码的含义：</p>\n<ul>\n<li><p>让 <code>dwarves=countDwarves</code> 意味着“将 <code>dwarves</code> 指向 <code>countDwarves</code> 所指向的值”</p>\n</li>\n<li><p>let <code>dwarves=countDwarves()</code> 表示“将 <code>dwarves</code> 指向 <code>countDwarves</code> 所指向的函数<strong>返回的值</strong>。”</p>\n</li>\n</ul>\n<p>实际上， <code>countDwarves()</code> 也是一个表达式。它被称为调用表达式。为了“应答”调用表达式，JavaScript在函数内部运行代码，并将返回的值作为结果（在本例中是7）。</p>\n<p>我们将在未来的模块中更详细地研究函数调用。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>那真是一段不同寻常的旅程！在最后两个模块中，我们看了JavaScript中的每个值类型。让我们结合计算伯爵来概括每种类型有多少个值，从不同的原始类型开始：</p>\n<p><img src=\"/blog_imgs/just_javascript/05/primitive-type.png\" alt=\"\"></p>\n<ul>\n<li><code>Undefined</code> ：仅仅只是个值，表示没有定义。</li>\n<li><code>Null</code> ：一个值，空。</li>\n<li><code>Booleans</code> ：两个值: true 和 false。</li>\n<li><code>Numbers</code> ： 数学中每个浮点数的值。</li>\n<li><code>BigInts</code> ：每一个可能的整数的值。</li>\n<li><code>Strings</code> ：每个可能的字符串的值。</li>\n<li><code>Symbols</code> ：我们暂时跳过了Symbols，但总有一天我们会讨论到它们的！</li>\n</ul>\n<p>以下类型是特殊的，因为它们让我们可以创造自己的价值：</p>\n<p><img src=\"/blog_imgs/just_javascript/05/special-type.png\" alt=\"\"></p>\n<ul>\n<li><code>Objects</code> ：表示执行的每个对象文本都的值。</li>\n<li><code>Function</code> ：执行的每个函数表达式的值。</li>\n</ul>\n<p>访问JavaScript的不同“天体”很有趣。现在我们已经计算了所有的值，我们也了解了是什么使它们彼此不同。例如，写2或“hello”总是“调用”相同的数字或字符串值。但是编写 <code>{}</code> 或 <code>function()</code> {}`总是会创建一个全新的、不同的值。这个概念对于理解JavaScript中的相等至关重要，这将是下一个模块的主题。</p>\n<h1 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h1><p>本单元也有练习题供你练习！</p>\n<p><a href=\"https://el2.convertkit-mail.com/c/r8up8kx6pxc9u0274lh2/mot7h6u0zplx4n/aHR0cHM6Ly9lZ2doZWFkaW8udHlwZWZvcm0uY29tL3RvL1NURWVNeT9lbWFpbD1ha2loaTk1QGdtYWlsLmNvbQ==\" target=\"_blank\" rel=\"noopener\">点击这里，通过一些简短的练习巩固这个思维模型。</a></p>\n<p><strong>不要跳过它们！</strong></p>\n<p>即使你可能熟悉不同类型的值，这些练习将帮助你巩固我们正在建立的思维模型。我们需要打好基础才能继续更复杂的话题。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>事不宜迟，让我们继续我们的JavaScript之旅吧！</p>\n<p><img src=\"/blog_imgs/just_javascript/05/type.png\" alt=\"\"></p>\n<p>在前面的模块中，我们研究了undefined、null、boolean和number。我们现在将继续计算数值——从bigint开始。</p>\n<h2 id=\"BigInts\"><a href=\"#BigInts\" class=\"headerlink\" title=\"BigInts\"></a>BigInts</h2><p><img src=\"/blog_imgs/just_javascript/05/bigints.png\" alt=\"\"></p>\n<p>BigInts只是最近才添加到JavaScript中，所以你还不会看到它们被广泛使用。如果你使用版本较低的浏览器，它们将不起作用。常规数字不能精确地表示大整数，因此大整数填补了这一空白（字面上）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> alot = <span class=\"number\">9007199254740991n</span>; <span class=\"comment\">// Notice n at the end </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(alot + <span class=\"number\">1n</span>); <span class=\"comment\">// 9007199254740992n </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(alot + <span class=\"number\">2n</span>); <span class=\"comment\">// 9007199254740993n </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(alot + <span class=\"number\">3n</span>); <span class=\"comment\">// 9007199254740994n </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(alot + <span class=\"number\">4n</span>); <span class=\"comment\">// 9007199254740995n </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(alot + <span class=\"number\">5n</span>); <span class=\"comment\">// 9007199254740996n</span></span><br></pre></td></tr></table></figure>\n\n<p>四舍五入可不是闹着玩的！这对于财务计算来说是非常重要的，因为精确性尤其重要。请记住，没有什么是免费的。真正数量庞大的操作可能需要时间和资源。</p>\n<p>我们的宇宙中有多少个BigInts？明确地说它们有任意的精度。这意味着<strong>在我们的JavaScript世界中，有无限多个BigInts——数学中每个整数对应一个。</strong></p>\n<p>是吗？</p>\n<p>如果这听起来很奇怪，考虑一下你已经习惯了数学中存在无限整数的想法。（如果不是，请稍等片刻！）从“数学世界”到“JavaScript世界”并不是什么飞跃。</p>\n<p>（从那里，我们可以直接进入百事世界。）</p>\n<p>当然，在实践中，我们不可能把所有可能的高精度计算放进计算机内存。如果我们尝试，在某些时候，它会崩溃或冻结。但从概念上讲，计算伯爵(个人理解指计算机程序)可能永远忙着计算，从未停止过。</p>\n<h2 id=\"Strings\"><a href=\"#Strings\" class=\"headerlink\" title=\"Strings\"></a>Strings</h2><p><img src=\"/blog_imgs/just_javascript/05/string.png\" alt=\"\"></p>\n<p>在JavaScript用字符串表示文本。有三种方法可以可以写字符串（单引号、双引号和反引号），但结果是一样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"string\">\"こんにちは\"</span>)); <span class=\"comment\">// \"string\" </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"string\">'こんにちは'</span>)); <span class=\"comment\">// \"string\" </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>( <span class=\"string\">`こんにちは`</span> )); <span class=\"comment\">// \"string\"</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello\"</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">undefined</span>)</span><br></pre></td></tr></table></figure>\n\n<p>空字符串也是字符串：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"string\">''</span>)); <span class=\"comment\">// \"string\"</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字符串不是对象\"><a href=\"#字符串不是对象\" class=\"headerlink\" title=\"字符串不是对象\"></a>字符串不是对象</h3><p>所有字符串都有一些内置属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> cat = <span class=\"string\">'Cheshire'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.length); <span class=\"comment\">// 8</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat[<span class=\"number\">0</span>]); <span class=\"comment\">// \"C\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat[<span class=\"number\">1</span>]); <span class=\"comment\">// \"h\"</span></span><br></pre></td></tr></table></figure>\n\n<p>这并不意味着字符串就是对象！字符串属性是特殊的，其行为与对象属性不同。例如，不能将任何内容分配给cat[0]。字符串是原始值，所有原始值都是不可变的。</p>\n<h3 id=\"每个可能的字符串的值\"><a href=\"#每个可能的字符串的值\" class=\"headerlink\" title=\"每个可能的字符串的值\"></a>每个可能的字符串的值</h3><p><strong>在我们的宇宙中，每个可能的字符串都有一个不同的值</strong>。是的，这包括你祖母的娘家姓，十年前你用化名发表的同人小说，和还没有写完的《黑客帝国5》的剧本。</p>\n<p>当然，所有可能的字符串都不能完全放在计算机内存芯片中。但是每一个可能的字符串都可以放在你的脑子里。我们的JavaScript宇宙是人类的模型，而不是计算机的模型！</p>\n<p>这可能会引发一个问题。此代码是否创建字符串？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Try it in your console</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> answer = prompt(<span class=\"string\">'Enter your name'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(answer); <span class=\"comment\">// ?</span></span><br></pre></td></tr></table></figure>\n\n<p>或者它只是召唤一个已经存在于我们宇宙中的字符串？</p>\n<p>这个问题的答案取决于我们是“从外部”还是“从内部”学习JavaScript。</p>\n<p>在我们的思维模型之外，答案取决于具体的实现。字符串是表示为单个内存块、多个块还是串在一起的相似的东西，取决于JavaScript引擎。</p>\n<p>但在我们的思维模式中，这个问题并不意味着什么。我们不能建立一个实验来说明在我们的JavaScript宇宙中字符串是“被创建”还是“被调用”。</p>\n<p>为了保持我们的思维模型简单，我们将<strong>所有可能的字符串值从一开始就保存了它们——每个不同的字符串都有一个值。</strong></p>\n<h2 id=\"Symbols\"><a href=\"#Symbols\" class=\"headerlink\" title=\"Symbols\"></a>Symbols</h2><p>Symbols是最近才加到JavaScript中的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> alohomora = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(alohomora)); <span class=\"comment\">// \"symbol\"</span></span><br></pre></td></tr></table></figure>\n\n<p>如果不深入研究对象和属性，很难解释它们的目的和行为，所以现在我们将跳过它们。对不起，symbols！</p>\n<p><img src=\"/blog_imgs/just_javascript/05/sym.png\" alt=\"\"></p>\n<h2 id=\"Objects\"><a href=\"#Objects\" class=\"headerlink\" title=\"Objects\"></a>Objects</h2><p>最后，我们来说说对象。</p>\n<p><img src=\"/blog_imgs/just_javascript/05/bracket.png\" alt=\"\"></p>\n<p>对象包括arrays, dates, RegExps和其他非原始值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(&#123;&#125;)); <span class=\"comment\">// \"object\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>([])); <span class=\"comment\">// \"object\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>())); <span class=\"comment\">// \"object\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"regexp\">/\\d+/</span>)); <span class=\"comment\">// \"object\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"built_in\">Math</span>)); <span class=\"comment\">// \"object\"</span></span><br></pre></td></tr></table></figure>\n\n<p>与之前的一切不同，对象不是原始值。这也意味着默认情况下，它们是可变的。我们可以通过. 或者[]访问他们的属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> rapper = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'Malicious'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">rapper.name = <span class=\"string\">'Malice'</span>; <span class=\"comment\">// Dot notation</span></span><br><span class=\"line\">rapper[<span class=\"string\">'name'</span>] = <span class=\"string\">'No Malice'</span>; <span class=\"comment\">// Bracket notation</span></span><br></pre></td></tr></table></figure>\n\n<p>我们还没有详细讨论属性，所以你对它们的思维模型可能是模糊的。我们将在未来的模块中讨论属性。</p>\n<h3 id=\"创建我们自己的对象\"><a href=\"#创建我们自己的对象\" class=\"headerlink\" title=\"创建我们自己的对象\"></a>创建我们自己的对象</h3><p>有一件事特别使计算伯爵对对象象感到兴奋。<strong>我们可以创建更多对象，我们可以创建自己的对象。</strong></p>\n<p>在我们的思维模型中，我们讨论过的所有原始值——null, undefined, booleans, numbers和strings——塔门都“一直存在”。我们不能“制造”一个新字符串或一个新数字，我们只能“转换”那个值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sisters = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> musketeers = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/blog_imgs/just_javascript/05/primitive.png\" alt=\"\"></p>\n<p>使对象区别于其他的是我们可以创建更多的对象。每次使用{}对象文本时，我们都会创建一个全新的对象值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> shrek = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> donkey = &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/blog_imgs/just_javascript/05/obj.png\" alt=\"\"></p>\n<p>数组、日期和任何其他对象也是如此。例如，[]数组确实创建了一个新的数组值——以前从未存在过的值。</p>\n<h3 id=\"对象消失了吗？\"><a href=\"#对象消失了吗？\" class=\"headerlink\" title=\"对象消失了吗？\"></a>对象消失了吗？</h3><p>你可能会想：”对象会永远消失，还是永远在周围徘徊？JavaScript的设计方式是从我们的代码中我们不知道是怎么回事”。例如，我们不能销毁对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> junk = &#123;&#125;;</span><br><span class=\"line\">junk = <span class=\"literal\">null</span>; <span class=\"comment\">// Doesn't necessarily destroy an object</span></span><br></pre></td></tr></table></figure>\n\n<p>而且，JavaScript是一们拥有垃圾回收功能的语言。</p>\n<p>这意味着尽管我们不能销毁一个对象，如果无法通过代码中的导线跟踪它，它最终可能消失。</p>\n<p><img src=\"/blog_imgs/just_javascript/05/obj1.gif\" alt=\"\"></p>\n<p>JavaScript不能保证垃圾收集何时发生。</p>\n<p>除非你想弄清楚为什么一个应用程序使用了太多的内存，否则你不需要经常考虑垃圾收集。我在这里只提到它是为了让你知道我们可以创造对象，但我们不能销毁它们。</p>\n<p>在我的宇宙中，对象和函数漂浮在离我的代码最近的地方。这提醒我，我可以操纵他们，甚至更多地使用它们。</p>\n<h2 id=\"Functions\"><a href=\"#Functions\" class=\"headerlink\" title=\"Functions\"></a>Functions</h2><p><img src=\"/blog_imgs/just_javascript/05/fun.png\" alt=\"\"></p>\n<p>将函数看作与代码分离的值是特别奇怪的。毕竟，它们也是我写的代码。不是吗？</p>\n<h3 id=\"函数也是值\"><a href=\"#函数也是值\" class=\"headerlink\" title=\"函数也是值\"></a>函数也是值</h3><p>我们定义函数，以便以后调用它们并在其中运行代码。然而，要真正理解JavaScript中的函数，我们需要暂时忘记它们为什么有用。相反，我们将函数看作是另一种值：一个数字、一个对象、一个函数。</p>\n<p>为了理解函数，我们将它们与数字和对象进行比较。</p>\n<p>首先，考虑运行 <code>console.log(2)</code> 七次的循环： </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">7</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它给 <code>console.log()</code> 传递给多少不同的值。为了回答这个问题，让我们回忆一下当我们写下2时是什么意思。字面上它是一个数字，文字是一种表达式——这对我们宇宙来说是个问题。在我们宇宙中，每个数字只有一个值，所以它通过每次“调用”相同的值——数字2的来“回答”我们的问题。<strong>所以答案是一个值，</strong>我们将看到七次打印，但每次调用都传递相同的值。</p>\n<p>现在来简单的复习一下对象。</p>\n<p>下面是运行 <code>console.log({})</code> 七次的另一个for循环：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">7</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(&#123;&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在它传递给多少不同的值给 <code>console.log()？</code> 在这里， <code>{}</code> 也是一个文本——不同的是它是一个对象文本。正如我们刚刚了解到的，JavaScript宇宙不会通过调用任何东西来“回答”一个对象。相反，他会创建新的对象值——这是 <code>{}</code> 对象文本的结果。<strong>所以上面的代码创建并记录了七个完全不同的对象值。</strong></p>\n<p>先把它抛之脑后。</p>\n<p>现在让我们来看看函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">7</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>现在它传递给多少不同的值给 <code>console.log()</code> ？</strong></p>\n<p><img src=\"/blog_imgs/just_javascript//03/spoilers.jpg\" alt=\"\"></p>\n<p>在你决定答案之前不要再滚动。</p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p><code>...</code> </p>\n<p>答案是7。</p>\n<p><strong>每当我们执行一行包含函数表达式的代码时，一个全新的函数值就会出现在我们的宇宙中。</strong></p>\n<p><img src=\"/blog_imgs/just_javascript/05/fun1.gif\" alt=\"\"></p>\n<p><strong>这里， <code>function(){}</code> 也是一个表达式</strong>。与任何表达式一样，函数表达式向JavaScript宇宙提出一个“问题”——它通过每次我们提问时创建一个新的函数值来回答我们。这与 <code>{}</code> 在执行时创建新对象值的方式非常相似。函数就像对象！</p>\n<p>严格来说，函数是JavaScript中的对象。我们将继续将它们视为单独的基本类型，因为它们与常规对象相比具有独特的功能。但是，一般来说，如果你能对一个对象做些什么，你也可以对一个函数做。它们是非常特殊的对象。</p>\n<h3 id=\"调用函数\"><a href=\"#调用函数\" class=\"headerlink\" title=\"调用函数\"></a>调用函数</h3><p>下面的代码打印什么？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> countDwarves = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">7</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dwarves = countDwarves;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dwarves);</span><br></pre></td></tr></table></figure>\n\n<p>你可能认为它打印7，特别是如果你不仔细看的话。</p>\n<p>现在检查控制台中的这个片段！它打印的确切内容取决于浏览器，但您将看到函数本身，而不是那里的数字7。</p>\n<p>如果你遵循我们的思维模型，这种表现应该是有道理的：</p>\n<ol>\n<li>首先，我们用一个 <code>function(){}</code> 表达式创建了一个新的函数值，并将 <code>countdwaves</code> 变量指向这个值。</li>\n<li>接下来，我们将 <code>dwarves</code> 变量指向 <code>countDwarves</code> 所指向的值——这是相同的函数值</li>\n<li>最后，我们输出了 <code>dwarves</code> 当前指向的值。</li>\n</ol>\n<p>在任何时候，我们都没有调用函数！</p>\n<p>结果， <code>countDwarves</code> 和 <code>dwarves</code> 都指向同一个值，这恰好是一个函数。所以，函数是值，我们可以将变量指向它们，就像处理数字或对象一样。</p>\n<p><strong>当然，如果我们想调用函数，我们也可以这样做：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> countDwarves = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">7</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dwarves = countDwarves(); <span class=\"comment\">// () is a function call</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dwarves);</span><br></pre></td></tr></table></figure>\n\n<p>注意，let声明和=赋值都与函数调用无关。是 <code>()</code> 执行函数调用——而且是单独执行的！</p>\n<p>添加 <code>()</code> 改变了代码的含义：</p>\n<ul>\n<li><p>让 <code>dwarves=countDwarves</code> 意味着“将 <code>dwarves</code> 指向 <code>countDwarves</code> 所指向的值”</p>\n</li>\n<li><p>let <code>dwarves=countDwarves()</code> 表示“将 <code>dwarves</code> 指向 <code>countDwarves</code> 所指向的函数<strong>返回的值</strong>。”</p>\n</li>\n</ul>\n<p>实际上， <code>countDwarves()</code> 也是一个表达式。它被称为调用表达式。为了“应答”调用表达式，JavaScript在函数内部运行代码，并将返回的值作为结果（在本例中是7）。</p>\n<p>我们将在未来的模块中更详细地研究函数调用。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>那真是一段不同寻常的旅程！在最后两个模块中，我们看了JavaScript中的每个值类型。让我们结合计算伯爵来概括每种类型有多少个值，从不同的原始类型开始：</p>\n<p><img src=\"/blog_imgs/just_javascript/05/primitive-type.png\" alt=\"\"></p>\n<ul>\n<li><code>Undefined</code> ：仅仅只是个值，表示没有定义。</li>\n<li><code>Null</code> ：一个值，空。</li>\n<li><code>Booleans</code> ：两个值: true 和 false。</li>\n<li><code>Numbers</code> ： 数学中每个浮点数的值。</li>\n<li><code>BigInts</code> ：每一个可能的整数的值。</li>\n<li><code>Strings</code> ：每个可能的字符串的值。</li>\n<li><code>Symbols</code> ：我们暂时跳过了Symbols，但总有一天我们会讨论到它们的！</li>\n</ul>\n<p>以下类型是特殊的，因为它们让我们可以创造自己的价值：</p>\n<p><img src=\"/blog_imgs/just_javascript/05/special-type.png\" alt=\"\"></p>\n<ul>\n<li><code>Objects</code> ：表示执行的每个对象文本都的值。</li>\n<li><code>Function</code> ：执行的每个函数表达式的值。</li>\n</ul>\n<p>访问JavaScript的不同“天体”很有趣。现在我们已经计算了所有的值，我们也了解了是什么使它们彼此不同。例如，写2或“hello”总是“调用”相同的数字或字符串值。但是编写 <code>{}</code> 或 <code>function()</code> {}`总是会创建一个全新的、不同的值。这个概念对于理解JavaScript中的相等至关重要，这将是下一个模块的主题。</p>\n<h1 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h1><p>本单元也有练习题供你练习！</p>\n<p><a href=\"https://el2.convertkit-mail.com/c/r8up8kx6pxc9u0274lh2/mot7h6u0zplx4n/aHR0cHM6Ly9lZ2doZWFkaW8udHlwZWZvcm0uY29tL3RvL1NURWVNeT9lbWFpbD1ha2loaTk1QGdtYWlsLmNvbQ==\" target=\"_blank\" rel=\"noopener\">点击这里，通过一些简短的练习巩固这个思维模型。</a></p>\n<p><strong>不要跳过它们！</strong></p>\n<p>即使你可能熟悉不同类型的值，这些练习将帮助你巩固我们正在建立的思维模型。我们需要打好基础才能继续更复杂的话题。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck8gp7rxg0000kb9h6rln9esb","category_id":"ck8gofbcg000ahk9hgfijf3kt","_id":"ck8gp7rxt0004kb9h7azb8h7z"},{"post_id":"ck8gp7rxn0001kb9hge9hate0","category_id":"ck8gofbcq000shk9hh2m87u26","_id":"ck8gp7rxv0006kb9hdo4scsnd"},{"post_id":"ck8gp7rxp0002kb9hcd7j56f5","category_id":"ck8gofbck000fhk9h6uig4i6v","_id":"ck8gp7rxw0008kb9hgm4x41q7"},{"post_id":"ck8gp7rxs0003kb9hetw8dkcd","category_id":"ck8gofbcc0006hk9h9zrp5fmm","_id":"ck8gp7rxx000akb9h7e4d87mt"},{"post_id":"ck8gp7rxu0005kb9ha4dm5jot","category_id":"ck8gofbcc0006hk9h9zrp5fmm","_id":"ck8gp7rxy000ckb9h1vj31w0x"},{"post_id":"ck8gp7rxw0007kb9h8g2t7vb2","category_id":"ck8gofbcc0006hk9h9zrp5fmm","_id":"ck8gp7rxz000ekb9h3b1k0tbw"},{"post_id":"ck8gp7rxw0009kb9h9dxh393w","category_id":"ck8gofbck000ihk9hbp2l2j7a","_id":"ck8gp7rxz000gkb9hhtlnf73b"},{"post_id":"ck8gp7rxx000bkb9h6gpl08wf","category_id":"ck8gofbco000nhk9h1zi81res","_id":"ck8gp7ry2000ikb9hc3arbvb8"},{"post_id":"ck8gp7rxy000dkb9he6vg91nh","category_id":"ck8gofbco000nhk9h1zi81res","_id":"ck8gp7ry3000jkb9h9h3p04f3"},{"post_id":"ck8gp7rxz000fkb9h3zyq8a4f","category_id":"ck8gofbco000nhk9h1zi81res","_id":"ck8gp7ry3000lkb9h0037f2uq"},{"post_id":"ck8gp7rzg000mkb9h5hix24zf","category_id":"ck8gofbcu000yhk9h59v5bvzz","_id":"ck8gp7rzl000pkb9hcc4g0stq"},{"post_id":"ck8gp7rzk000okb9hg86ke2c6","category_id":"ck8gofbcc0006hk9h9zrp5fmm","_id":"ck8gp7rzo000qkb9hecl115x5"},{"post_id":"ckaz13gpf0000gq9he9kbgthq","category_id":"ck8gofbcc0006hk9h9zrp5fmm","_id":"ckaz13gpk0002gq9h3yzeh162"},{"post_id":"ckaz13gpk0003gq9h4a7z41jp","category_id":"ck8gofbcc0006hk9h9zrp5fmm","_id":"ckaz13gpm0004gq9h96ut1i2j"}],"PostTag":[{"post_id":"ckaz0p8zn0000s59h484eecox","tag_id":"ck8gn5gmy0002hk9h6noc6wok","_id":"ckaz0p8zs0001s59h584tgdvj"}],"Tag":[{"name":"JavaScript","_id":"ck8gn5gmy0002hk9h6noc6wok"}]}}