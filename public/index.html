<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>随便写写</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="随便写写">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="随便写写">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zxl">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="随便写写" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">随便写写</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-《Just-JavaScript》05.-计算数值2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/18/%E3%80%8AJust-JavaScript%E3%80%8B05.-%E8%AE%A1%E7%AE%97%E6%95%B0%E5%80%BC2/" class="article-date">
  <time datetime="2020-05-18T09:36:08.000Z" itemprop="datePublished">2020-05-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/18/%E3%80%8AJust-JavaScript%E3%80%8B05.-%E8%AE%A1%E7%AE%97%E6%95%B0%E5%80%BC2/">《Just JavaScript》05. 计算数值2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>事不宜迟，让我们继续我们的JavaScript之旅吧！</p>
<p><img src="/blog_imgs/just_javascript//05/type.png" alt=""></p>
<p>在前面的模块中，我们研究了undefined、null、boolean和number。我们现在将继续计算数值——从bigint开始。</p>
<h2 id="BigInts"><a href="#BigInts" class="headerlink" title="BigInts"></a>BigInts</h2><p><img src="/blog_imgs/just_javascript//05/bigints.png" alt=""></p>
<p>BigInts只是最近才添加到JavaScript中，所以你还不会看到它们被广泛使用。如果你使用版本较低的浏览器，它们将不起作用。常规数字不能精确地表示大整数，因此大整数填补了这一空白（字面上）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> alot = <span class="number">9007199254740991n</span>; <span class="comment">// Notice n at the end</span></span><br><span class="line"><span class="built_in">console</span>.log(alot + <span class="number">1n</span>); <span class="comment">// 9007199254740992n</span></span><br><span class="line"><span class="built_in">console</span>.log(alot + <span class="number">2n</span>); <span class="comment">// 9007199254740993n</span></span><br><span class="line"><span class="built_in">console</span>.log(alot + <span class="number">3n</span>); <span class="comment">// 9007199254740994n</span></span><br><span class="line"><span class="built_in">console</span>.log(alot + <span class="number">4n</span>); <span class="comment">// 9007199254740995n</span></span><br><span class="line"><span class="built_in">console</span>.log(alot + <span class="number">5n</span>); <span class="comment">// 9007199254740996n</span></span><br></pre></td></tr></table></figure>

<p>四舍五入可不是闹着玩的！这对于财务计算来说是非常重要的，因为精确性尤其重要。请记住，没有什么是免费的。真正数量庞大的操作可能需要时间和资源。</p>
<p>我们的宇宙中有多少个BigInts？明确地说它们有任意的精度。这意味着<strong>在我们的JavaScript世界中，有无限多个BigInts——数学中每个整数对应一个。</strong></p>
<p>是吗？</p>
<p>如果这听起来很奇怪，考虑一下你已经习惯了数学中存在无限整数的想法。（如果不是，请稍等片刻！）从“数学世界”到“JavaScript世界”并不是什么飞跃。</p>
<p>（从那里，我们可以直接进入百事世界。）</p>
<p>当然，在实践中，我们不可能把所有可能的高精度计算放进计算机内存。如果我们尝试，在某些时候，它会崩溃或冻结。但从概念上讲，计算伯爵(个人理解指计算机程序)可能永远忙着计算，从未停止过。</p>
<h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><p><img src="/blog_imgs/just_javascript//05/string.png" alt=""></p>
<p>在JavaScript用字符串表示文本。有三种方法可以可以写字符串（单引号、双引号和反引号），但结果是一样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="string">"こんにちは"</span>)); <span class="comment">// "string"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="string">'こんにちは'</span>)); <span class="comment">// "string"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>( <span class="string">`こんにちは`</span> )); <span class="comment">// "string"</span></span><br></pre></td></tr></table></figure>

<p>空字符串也是字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="string">''</span>)); <span class="comment">// "string"</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串不是对象"><a href="#字符串不是对象" class="headerlink" title="字符串不是对象"></a>字符串不是对象</h3><p>所有字符串都有一些内置属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = <span class="string">'Cheshire'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(cat.length); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">console</span>.log(cat[<span class="number">0</span>]); <span class="comment">// "C"</span></span><br><span class="line"><span class="built_in">console</span>.log(cat[<span class="number">1</span>]); <span class="comment">// "h"</span></span><br></pre></td></tr></table></figure>

<p>这并不意味着字符串就是对象！字符串属性是特殊的，其行为与对象属性不同。例如，不能将任何内容分配给cat[0]。字符串是原始值，所有原始值都是不可变的。</p>
<h3 id="每个可能的字符串的值"><a href="#每个可能的字符串的值" class="headerlink" title="每个可能的字符串的值"></a>每个可能的字符串的值</h3><p><strong>在我们的宇宙中，每个可能的字符串都有一个不同的值</strong>。是的，这包括你祖母的娘家姓，十年前你用化名发表的同人小说，和还没有写完的《黑客帝国5》的剧本。</p>
<p>当然，所有可能的字符串都不能完全放在计算机内存芯片中。但是每一个可能的字符串都可以放在你的脑子里。我们的JavaScript宇宙是人类的模型，而不是计算机的模型！</p>
<p>这可能会引发一个问题。此代码是否创建字符串？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Try it in your console</span></span><br><span class="line"><span class="keyword">let</span> answer = prompt(<span class="string">'Enter your name'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(answer); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>或者它只是召唤一个已经存在于我们宇宙中的字符串？</p>
<p>这个问题的答案取决于我们是“从外部”还是“从内部”学习JavaScript。</p>
<p>在我们的思维模型之外，答案取决于具体的实现。字符串是表示为单个内存块、多个块还是串在一起的相似的东西，取决于JavaScript引擎。</p>
<p>但在我们的思维模式中，这个问题并不意味着什么。我们不能建立一个实验来说明在我们的JavaScript宇宙中字符串是“被创建”还是“被调用”。</p>
<p>为了保持我们的思维模型简单，我们将<strong>所有可能的字符串值从一开始就保存了它们——每个不同的字符串都有一个值。</strong></p>
<h2 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h2><p>Symbols是最近才加到JavaScript中的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> alohomora = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(alohomora)); <span class="comment">// "symbol"</span></span><br></pre></td></tr></table></figure>

<p>如果不深入研究对象和属性，很难解释它们的目的和行为，所以现在我们将跳过它们。对不起，symbols！</p>
<p><img src="/blog_imgs/just_javascript//05/sym.png" alt=""></p>
<h2 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h2><p>最后，我们来说说对象。</p>
<p><img src="/blog_imgs/just_javascript//05/bracket.png" alt=""></p>
<p>对象包括arrays, dates, RegExps和其他非原始值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(&#123;&#125;)); <span class="comment">// "object"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>([])); <span class="comment">// "object"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="keyword">new</span> <span class="built_in">Date</span>())); <span class="comment">// "object"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="regexp">/\d+/</span>)); <span class="comment">// "object"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="built_in">Math</span>)); <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure>

<p>与之前的一切不同，对象不是原始值。这也意味着默认情况下，它们是可变的。我们可以通过.或者[]访问他们的属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rapper = &#123; <span class="attr">name</span>: <span class="string">'Malicious'</span> &#125;;</span><br><span class="line">rapper.name = <span class="string">'Malice'</span>; <span class="comment">// Dot notation</span></span><br><span class="line">rapper[<span class="string">'name'</span>] = <span class="string">'No Malice'</span>; <span class="comment">// Bracket notation</span></span><br></pre></td></tr></table></figure>

<p>我们还没有详细讨论属性，所以你对它们的思维模型可能是模糊的。我们将在未来的模块中讨论属性。</p>
<h3 id="创建我们自己的对象"><a href="#创建我们自己的对象" class="headerlink" title="创建我们自己的对象"></a>创建我们自己的对象</h3><p>有一件事特别使计算伯爵对对象象感到兴奋。<strong>我们可以创建更多对象，我们可以创建自己的对象。</strong></p>
<p>在我们的思维模型中，我们讨论过的所有原始值——null, undefined, booleans, numbers和strings——塔门都“一直存在”。我们不能“制造”一个新字符串或一个新数字，我们只能“转换”那个值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sisters = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> musketeers = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/blog_imgs/just_javascript//05/primitive.png" alt=""></p>
<p>使对象区别于其他的是我们可以创建更多的对象。每次使用{}对象文本时，我们都会创建一个全新的对象值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shrek = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> donkey = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/blog_imgs/just_javascript//05/obj.png" alt=""></p>
<p>数组、日期和任何其他对象也是如此。例如，[]数组确实创建了一个新的数组值——以前从未存在过的值。</p>
<h3 id="对象消失了吗？"><a href="#对象消失了吗？" class="headerlink" title="对象消失了吗？"></a>对象消失了吗？</h3><p>你可能会想：对象会永远消失，还是永远在周围徘徊？JavaScript的设计方式是从我们的代码中我们不知道是怎么回事。例如，我们不能销毁对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> junk = &#123;&#125;;</span><br><span class="line">junk = <span class="literal">null</span>; <span class="comment">// Doesn't necessarily destroy an object</span></span><br></pre></td></tr></table></figure>

<p>而且，JavaScript是一们拥有垃圾回收功能的语言。</p>
<p>这意味着尽管我们不能销毁一个对象，如果无法通过代码中的导线跟踪它，它最终可能消失。</p>
<p><img src="/blog_imgs/just_javascript//05/obj1.png" alt=""></p>
<p>JavaScript不能保证垃圾收集何时发生。</p>
<p>除非你想弄清楚为什么一个应用程序使用了太多的内存，否则你不需要经常考虑垃圾收集。我在这里只提到它是为了让你知道我们可以创造对象，但我们不能销毁它们。</p>
<p>在我的宇宙中，对象和函数漂浮在离我的代码最近的地方。这提醒我，我可以操纵他们，甚至更多地使用它们。</p>
<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><p>!<img src="/blog_imgs/just_javascript//05/fun.png" alt=""></p>
<p>将函数看作与代码分离的值是特别奇怪的。毕竟，它们也是我写的代码。不是吗？</p>
<h3 id="函数也是值"><a href="#函数也是值" class="headerlink" title="函数也是值"></a>函数也是值</h3><p>我们定义函数，以便以后调用它们并在其中运行代码。然而，要真正理解JavaScript中的函数，我们需要暂时忘记它们为什么有用。相反，我们将函数看作是另一种值：一个数字、一个对象、一个函数。</p>
<p>为了理解函数，我们将它们与数字和对象进行比较。</p>
<p>首先，考虑运行console.log（2）七次的循环：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>它给<code>console.log()</code>传递给多少不同的值。</strong>为了回答这个问题，让我们回忆一下当我们写下2时是什么意思。字面上它是一个数字，文字是一种表达式——这对我们宇宙来说是个问题。在我们宇宙中，每个数字只有一个值，所以它通过每次“调用”相同的值——数字2的来“回答”我们的问题。<strong>所以答案是一个值，</strong>我们将看到七次打印，但每次调用都传递相同的值。</p>
<p>现在来简单的复习一下对象。</p>
<p>下面是运行<code>console.log({})</code>七次的另一个for循环：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>现在它传递给多少不同的值给<code>console.log()</code>？</strong>在这里，<code>{}</code>也是一个文本——不同的是它是一个对象文本。正如我们刚刚了解到的，JavaScript宇宙不会通过调用任何东西来“回答”一个对象。相反，他会创建新的对象值——这是<code>{}</code>对象文本的结果。<strong>所以上面的代码创建并记录了七个完全不同的对象值。</strong></p>
<p>先把它抛之脑后。</p>
<p>现在让我们来看看函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>How many different values does this code pass to console.log?<br><strong>现在它传递给多少不同的值给<code>console.log()</code>？</strong></p>
<p><img src="/blog_imgs/just_javascript//03/spoilers.jpg" alt=""></p>
<p>在你决定答案之前不要再滚动。</p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p>答案是7。</p>
<p><strong>每当我们执行一行包含函数表达式的代码时，一个全新的函数值就会出现在我们的宇宙中。</strong></p>
<p><img src="/blog_imgs/just_javascript//05/fun1.gif" alt=""></p>
<p><strong>这里，<code>function(){}</code>也是一个表达式</strong>。与任何表达式一样，函数表达式向JavaScript宇宙提出一个“问题”——它通过每次我们提问时创建一个新的函数值来回答我们。这与<code>{}</code>在执行时创建新对象值的方式非常相似。函数就像对象！</p>
<p>严格来说，函数是JavaScript中的对象。我们将继续将它们视为单独的基本类型，因为它们与常规对象相比具有独特的功能。但是，一般来说，如果你能对一个对象做些什么，你也可以对一个函数做。它们是非常特殊的对象。</p>
<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>下面的代码打印什么？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> countDwarves = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">7</span>; &#125;;</span><br><span class="line"><span class="keyword">let</span> dwarves = countDwarves;</span><br><span class="line"><span class="built_in">console</span>.log(dwarves);</span><br></pre></td></tr></table></figure>

<p>你可能认为它打印7，特别是如果你不仔细看的话。</p>
<p>现在检查控制台中的这个片段！它打印的确切内容取决于浏览器，但您将看到函数本身，而不是那里的数字7。</p>
<p>如果你遵循我们的思维模型，这种表现应该是有道理的：</p>
<ol>
<li>首先，我们用一个<code>function(){}</code>表达式创建了一个新的函数值，并将<code>countdwaves</code>变量指向这个值。</li>
<li>接下来，我们将<code>dwarves</code>变量指向<code>countDwarves</code>所指向的值——这是相同的函数值</li>
<li>最后，我们输出了<code>dwarves</code>当前指向的值。</li>
</ol>
<p>在任何时候，我们都没有调用函数！</p>
<p>结果，<code>countDwarves</code>和<code>dwarves</code>都指向同一个值，这恰好是一个函数。所以，函数是值，我们可以将变量指向它们，就像处理数字或对象一样。</p>
<p><strong>当然，如果我们想调用函数，我们也可以这样做：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> countDwarves = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">7</span>; &#125;;</span><br><span class="line"><span class="keyword">let</span> dwarves = countDwarves(); <span class="comment">// () is a function call</span></span><br><span class="line"><span class="built_in">console</span>.log(dwarves);</span><br></pre></td></tr></table></figure>

<p>注意，let声明和=赋值都与函数调用无关。是<code>()</code>执行函数调用——而且是单独执行的！</p>
<p>添加<code>()</code>改变了代码的含义：</p>
<ul>
<li><p>让<code>dwarves=countDwarves</code>意味着“将<code>dwarves</code>指向<code>countDwarves</code>所指向的值”</p>
</li>
<li><p>let<code>dwarves=countDwarves()</code>表示“将<code>dwarves</code>指向<code>countDwarves</code>所指向的函数<strong>返回的值</strong>。”</p>
</li>
</ul>
<p>实际上，<code>countDwarves()</code>也是一个表达式。它被称为调用表达式。为了“应答”调用表达式，JavaScript在函数内部运行代码，并将返回的值作为结果（在本例中是7）。</p>
<p>我们将在未来的模块中更详细地研究函数调用。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>那真是一段不同寻常的旅程！在最后两个模块中，我们看了JavaScript中的每个值类型。让我们结合计算伯爵来概括每种类型有多少个值，从不同的原始类型开始：</p>
<p><img src="/blog_imgs/just_javascript//05/primitive-type.png" alt=""></p>
<ul>
<li><code>Undefined</code>：仅仅只是个值，表示没有定义。</li>
<li><code>Null</code>：一个值，空。</li>
<li><code>Booleans</code>：两个值: true 和 false。</li>
<li><code>Numbers</code>： 数学中每个浮点数的值。</li>
<li><code>BigInts</code>：每一个可能的整数的值。</li>
<li><code>Strings</code>：每个可能的字符串的值。</li>
<li><code>Symbols</code>：我们暂时跳过了Symbols，但总有一天我们会讨论到它们的！</li>
</ul>
<p>以下类型是特殊的，因为它们让我们可以创造自己的价值：</p>
<p><img src="/blog_imgs/just_javascript//05/special-type.png" alt=""></p>
<ul>
<li><code>Objects</code>：表示执行的每个对象文本都的值。</li>
<li><code>Function</code>：执行的每个函数表达式的值。</li>
</ul>
<p>访问JavaScript的不同“天体”很有趣。现在我们已经计算了所有的值，我们也了解了是什么使它们彼此不同。例如，写2或“hello”总是“调用”相同的数字或字符串值。但是编写<code>{}</code>或<code>function()</code>{}`总是会创建一个全新的、不同的值。这个概念对于理解JavaScript中的相等至关重要，这将是下一个模块的主题。</p>
<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>本单元也有练习题供你练习！</p>
<p><a href="https://el2.convertkit-mail.com/c/r8up8kx6pxc9u0274lh2/mot7h6u0zplx4n/aHR0cHM6Ly9lZ2doZWFkaW8udHlwZWZvcm0uY29tL3RvL1NURWVNeT9lbWFpbD1ha2loaTk1QGdtYWlsLmNvbQ==" target="_blank" rel="noopener">点击这里，通过一些简短的练习巩固这个思维模型。</a></p>
<p><strong>不要跳过它们！</strong></p>
<p>即使你可能熟悉不同类型的值，这些练习将帮助你巩固我们正在建立的思维模型。我们需要打好基础才能继续更复杂的话题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/18/%E3%80%8AJust-JavaScript%E3%80%8B05.-%E8%AE%A1%E7%AE%97%E6%95%B0%E5%80%BC2/" data-id="ckadd1l2u00016x9h7lax6and" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-《Just-JavaScript》04-计算数值" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/15/%E3%80%8AJust-JavaScript%E3%80%8B04-%E8%AE%A1%E7%AE%97%E6%95%B0%E5%80%BC/" class="article-date">
  <time datetime="2020-04-15T10:36:08.000Z" itemprop="datePublished">2020-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/15/%E3%80%8AJust-JavaScript%E3%80%8B04-%E8%AE%A1%E7%AE%97%E6%95%B0%E5%80%BC/">《Just JavaScript》04. 计算数值</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在本模块中，我们将更深入地了解JavaScript世界和其中的值。但在我们开始之前，我们需要先正视这个问题，JavaScript世界是真的吗？</p>
<h2 id="JavaScript模式"><a href="#JavaScript模式" class="headerlink" title="JavaScript模式"></a>JavaScript模式</h2><p>我住在JavaScript宇宙中的小行星上。</p>
<p>当我问JavaScript世界一个问题时，它用一个值来回答我。这所有的值当然不是我一个人提出来的。变量，导线，值——它们都居住在我的世界。我周围的JavaScript世界对我来说是绝对真实的，就像你生活的世界对你来说是真实的一样。</p>
<p>但有时，在下一行代码之前会有片刻的沉默。在下一个函数调用前的空闲时间，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reaction = <span class="string">'yikes'</span>;</span><br><span class="line">reaction[<span class="number">0</span>] = <span class="string">'l'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reaction);</span><br></pre></td></tr></table></figure>

<p>你希望它做什么？我们还没有讲到这个，所以如果你不确定的话没关系。<strong>试着用你目前的JavaScript知识来回答这个问题。</strong></p>
<p>现在我想让你花点时间，一步一步地为这段代码的每一行写下你确切的思考过程。注意你现有的思维模型中的任何欠缺或不确定性，并把它们也写下来。如果你对此有任何疑问，尽可能清楚地将它表达出来。</p>
<p><img src="/blog_imgs/just_javascript/03/spoilers.jpg" alt=""></p>
<p>在你写完之前你的思考前不要往下滚动。</p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p>答案是这样的。此代码将打印“yikes”或抛出错误，具体取决于你是否处于严格模式。它永远不会印“likes”。</p>
<h2 id="原始值是不可改变的"><a href="#原始值是不可改变的" class="headerlink" title="原始值是不可改变的"></a>原始值是不可改变的</h2><p>你答对了吗？这可能看起来像一个很小的问题，就像大家在JavaScript面试中问的那种问题，但在实际编码中并没有太多出现。即使如此，它也说明了关于原始值的一个重要特点。</p>
<p><strong>我不能改变原始值。</strong></p>
<p>我将使用一个很小的例子来解释这点。字符串（原始值）和数组（非原始值，对象）有一些表面上的相似之处。数组是项的序列，字符串是字符的序列。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">212</span>, <span class="number">8</span>, <span class="number">506</span>];</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'hello'</span>;</span><br></pre></td></tr></table></figure>

<p>你可以访问字符串的第一个字符就像访问数组项那样，几乎感觉字符串就是数组（但它们并不是！）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>]); <span class="comment">// 212</span></span><br><span class="line"><span class="built_in">console</span>.log(str[<span class="number">0</span>]); <span class="comment">// "h"</span></span><br></pre></td></tr></table></figure>

<p>你可以改变数组的第一项：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">0</span>] = <span class="number">420</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [420, 8, 506]</span></span><br></pre></td></tr></table></figure>

<p>所以凭直觉来说，很容易假设可以对字符串执行相同的操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str[<span class="number">0</span>] = <span class="string">'j'</span>; <span class="comment">// ???</span></span><br></pre></td></tr></table></figure>

<p><strong>但是你不能这样做。</strong></p>
<p>这有一点很重要，我们需要添加到我们的思维模型。字符串是原始值，这是十分重要的。</p>
<p><strong>所有的原始值都是不可改变的。</strong>“Immutable”是拉丁语中一种奇特的说法“unchangeable”。只读的，你根本不能改变原始值。</p>
<p>如果你尝试在一个原始值上设置属性，不管是字符串、数字还是其他什么，JavaScript不会允许你这样做。它是否会默默拒绝你的请求或报错取决于你的代码运行在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">哪个模式</a>！</p>
<p>但我向你保证，这永远行不通:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fifty = <span class="number">50</span>;</span><br><span class="line">fifty.shades = <span class="string">'gray'</span>; <span class="comment">// No!</span></span><br></pre></td></tr></table></figure>

<p>就像一些数组，50是一个原始值，你不能给它设置属性。</p>
<p>在我的JavaScript宇宙里面，所有的原始值存在于离我的代码很远的外圆中——就像遥远的恒星。这提醒我，即使我可以从代码中引用它们，也无法更改它们。他们保持原样。</p>
<p>我觉得这异常地令人安慰：</p>
<p><img src="/blog_imgs/just_javascript/03/unnamed.png" alt=""></p>
<h2 id="一个矛盾？"><a href="#一个矛盾？" class="headerlink" title="一个矛盾？"></a>一个矛盾？</h2><p>我刚刚演示了原始值是只读的，或者用我们这个时代的话说，是不可变的。这里有一个片段来测试你的思维模型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pet = <span class="string">'Narwhal'</span>;</span><br><span class="line">pet = <span class="string">'The Kraken'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(pet); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>像以前一样，用几句话写下你的思考过程。别急着往前走。一步一步地关注你对每一行的想法。字符串的不变性在这里起作用吗？它起什么作用？</p>
<p><img src="/blog_imgs/just_javascript/03/spoilers.jpg" alt=""></p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p>如果你认为我是在捣乱你的大脑，那你完全是对的！答案是“The Kraken”——字符串的不变性不起作用。</p>
<p>如果你错了，不要气馁！最后这两个例子看起来肯定是相互矛盾的。</p>
<p>这是一个很重要的领悟！</p>
<p>当你对一门语言不熟悉时，你可能会倾向于忽略矛盾。毕竟，如果你追逐每一个矛盾，你会深陷入一个兔子洞深而学不到任何东西。</p>
<p>但既然你决定建立思维模型，你就需要质疑矛盾，它们展示出了思维模型的缺口。</p>
<h2 id="变量是导线"><a href="#变量是导线" class="headerlink" title="变量是导线"></a>变量是导线</h2><p>再看看这些例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pet = <span class="string">'Narwhal'</span>;</span><br><span class="line">pet = <span class="string">'The Kraken'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(pet); <span class="comment">// "The Kraken"</span></span><br></pre></td></tr></table></figure>

<p>我们知道字符串不能改变因为它们是原始值。但是pet变量的确变成了“The Kraken”。发生了什么呢？</p>
<p>这似乎是一个矛盾，但事实并非如此。我们只说原始值不能改变。我们对于变量什么都没说！</p>
<p>当我们完善我们的思维模型时候，我们可能需要整理一下相关的概念。</p>
<p><strong>变量不是值。</strong></p>
<p>变量指向值。</p>
<p>在我的宇宙，一个变量代表一根导线。它有两端和方向：它从我代码中的一个名字开始，最后指向我宇宙中的某个值。</p>
<p>举个例子，我可以将pet变量指向“Narwhal”值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pet = <span class="string">'Narwhal'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/blog_imgs/just_javascript/03/unnamed.gif" alt=""></p>
<p>之后可以对变量执行两项操作：</p>
<h3 id="给变量赋值"><a href="#给变量赋值" class="headerlink" title="给变量赋值"></a>给变量赋值</h3><p>我可以做的一件事是给我的变量赋值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pet = <span class="string">'The Kraken'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/blog_imgs/just_javascript/03/unnamed1.gif" alt=""></p>
<p>我在这里所做的只是告知JavaScript将左侧的“wire”（我的pet变量）指向右侧的值（“The Kraken”）。它将一直指向那个值，除非我之后重新分配它。</p>
<p>注意，我不能在左边放任何东西：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'war'</span> = <span class="string">'peace'</span>; <span class="comment">// Nope.(Try it in the console.)</span></span><br></pre></td></tr></table></figure>

<p><strong>赋值的左侧必须是导线。</strong>目前，我们只知道变量是“导线”。但是还有另一种“导线”我们将在后面的模块中讨论。也许，你能猜出是什么？（提示：它包含方括号或点，我们已经见过几次了）。</p>
<p>还有另外一条规则。</p>
<p><strong>赋值的右侧必须是表达式。</strong>它可以是简单的值，比如2或“hello”，也可以是更复杂的表达式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pet = count + <span class="string">' Dalmatians'</span>;</span><br></pre></td></tr></table></figure>

<p>在这里，count+“Dalmatians”是一个表达式——对JavaScript来说是一个问题。JavaScript将用一个值（例如，“101 Dalmatians”）来回答这个问题。从现在起，pet“导线”将开始指向这个值。</p>
<p>如果右边必须是表达式，这是否意味着像2这样的数字或像用代码编写的’the Kraken’这样的字符串也是表达式？对！这样的表达式称为字面量——因为我们逐字记录它们的值。</p>
<h3 id="读取变量的值"><a href="#读取变量的值" class="headerlink" title="读取变量的值"></a>读取变量的值</h3><p>我还可以读取变量的值——例如，要记录它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">console.log(pet);</span><br></pre></td></tr></table></figure>

<p>这并不奇怪。</p>
<p>但是请注意，我们传递给console.log的不是pet变量。我们可以通俗地说，但是我们不能真的把变量传递给函数。我们传递的是pet变量的当前值。这是怎么工作的呢？</p>
<p>原来，像pet这样的变量名也可以用作表达式！当我们编写pet时，我们在问JavaScript一个问题：“pet的当前价值是什么？”为了回答我们的问题，JavaScript跟随pet的“导线”，并在“导线”的末尾返回值。</p>
<p>所以同一个表达式可以在不同的时间给我们不同的值！</p>
<h3 id="名词和动词"><a href="#名词和动词" class="headerlink" title="名词和动词"></a>名词和动词</h3><p>谁在乎你说的是“传递变量”还是“传递值”？深究这点差别不是过于卖弄学问吗？我当然不会打断你的同事来纠正他们，甚至是你自己。那将会浪费大家的时间。</p>
<p>但在你的头脑中，你需要清楚地知道你可以用每一个概念做什么。你不能骑自行车溜冰。你不能让鳄梨费气力啊。你不能像蚊子一样发嗖嗖声。而且你不能传递一个变量——至少在JavaScript中不能。</p>
<p>这里有一个小例子说明为什么这些细节很重要。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    x = x * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> money = <span class="number">10</span>;</span><br><span class="line">double(money);</span><br><span class="line"><span class="built_in">console</span>.log(money); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>如果我们认为double（money）传递了一个变量，那么我们可以预期x=x*2将使该变量加倍。但事情不是这样的。我们知道double（money）的意思是“计算出货币的价值，然后将其传递给double”。所以答案是10。真是个骗局！</p>
<p>你脑子里有哪些不同的JavaScript名词和动词？他们之间有什么关系？将你最常使用的列一个清单。</p>
<h3 id="把它放在一起"><a href="#把它放在一起" class="headerlink" title="把它放在一起"></a>把它放在一起</h3><p>现在让我们重温一下来自思维模型的第一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> y = x;</span><br><span class="line">x = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>我建议你拿一张纸或一个绘图应用程序，一步一步地画出x和y变量的“连线”的情况图。</p>
<p><strong>第一行的作用不大：</strong></p>
<p><img src="/blog_imgs/just_javascript/03/unnamed2.gif" alt=""></p>
<ul>
<li>声明一个x变量  <ul>
<li>为x变量生成导线</li>
</ul>
</li>
<li>给x赋值10<ul>
<li>让x的导线指向10</li>
</ul>
</li>
</ul>
<p><strong>第二行很短，但它做了很多事情：</strong></p>
<p><img src="/blog_imgs/just_javascript/03/unnamed3.gif" alt=""></p>
<ul>
<li><p>声明一个y变量</p>
<ul>
<li>为y变量生成导线</li>
</ul>
</li>
<li><p>把x的值赋给y</p>
<ul>
<li><p>计算表达式：x</p>
<ul>
<li>我们要回答的问题是“x”</li>
<li><strong>跟随x的导线——答案是值10</strong></li>
</ul>
</li>
<li><p>x表达式结果是值10</p>
</li>
<li><p>因此，将10的值赋给y</p>
</li>
<li><p>把y的导线指向值10</p>
</li>
</ul>
<p><strong>最后，我们进入第三行：</strong></p>
</li>
</ul>
<p><img src="/blog_imgs/just_javascript/03/unnamed4.gif" alt=""></p>
<ul>
<li>将0的值赋给x<ul>
<li>将x的导线指向值0</li>
</ul>
</li>
</ul>
<p>最后，x变量指向值0，y变量指向值10。注意y=x并不意味着将y指向“x”。我们不能把变量指向彼此！<strong>变量总是指向值</strong>。当我们看到一个赋值时，我们“询问”右边的值，并将左边的“线”指向它。</p>
<p>我在思维模型中提到，把变量看作盒子是相当常见的。我们要建造的宇宙根本就没有盒子。<strong>它只有导线！</strong>这看起来有点烦人。为什么我们不能“将0和10放入变量中，而是将变量指向它们？”</p>
<p>使用导线对于解释许多其他概念将是非常重要的，就像严格的等式，对象标识和变动。我们要坚持使用导线，所以你最好现在就开始习惯。</p>
<p>我的宇宙充满了导线。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p><strong>原始值是不可变的：</strong>在我们的代码中，我们无法做任何事情来影响它们或以任何方式更改它们。他们保持原样。例如，不能对字符串值设置属性，因为它是原始值。数组不是原始值，所以我们可以设置它们的属性。</p>
</li>
<li><p><strong>变量不是值：</strong>每个变量都指向一个特定的值。我们可以使用=赋值运算符来更改它指向的值。</p>
</li>
<li><p><strong>变量就像导线：</strong>“导线”并不是JavaScript的概念——但是它帮助我们理解变量如何指向值。还有一种不同的“电线”，不是变量，但我们还没有讨论过。</p>
</li>
<li><p><strong>留意矛盾：</strong>如果你学到的两件事似乎互相矛盾，不要灰心。通常这是一个迹象，表明下面隐藏着更深层次的真相。</p>
</li>
<li><p><strong>名词和动词很重要：</strong>我们正在建立一个思维模型，这样我们就能对宇宙中可能发生或不可能发生的事情充满信心。随便马虎的说话是可以的，但我们的思维需要精确。</p>
</li>
</ul>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>本单元也有练习题供你练习！</p>
<p><a href="https://el2.convertkit-mail.com/c/o8u6klng6ncwu4e40piv/6gtehou6oom6de/aHR0cHM6Ly9lZ2doZWFkaW8udHlwZWZvcm0uY29tL3RvL1JXSmczbT9lbWFpbD1ha2loaTk1QGdtYWlsLmNvbQ==" target="_blank" rel="noopener">点击这里，通过一些简短的练习巩固这个思维模型。</a></p>
<p><strong>不要跳过它们！</strong></p>
<p>即使你可能熟悉变量的概念，这些练习将帮助你巩固我们正在建立的思维模型。我们需要打好基础才能继续更复杂的话题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/15/%E3%80%8AJust-JavaScript%E3%80%8B04-%E8%AE%A1%E7%AE%97%E6%95%B0%E5%80%BC/" data-id="ckadd1l2o00006x9h6pyyb05e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-《Just-JavaScript》02-JavaScript宇宙" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/01/%E3%80%8AJust-JavaScript%E3%80%8B02-JavaScript%E5%AE%87%E5%AE%99/" class="article-date">
  <time datetime="2020-04-01T01:02:26.000Z" itemprop="datePublished">2020-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/01/%E3%80%8AJust-JavaScript%E3%80%8B02-JavaScript%E5%AE%87%E5%AE%99/">《Just JavaScript》02.JavaScript宇宙</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在JavaScript中，它的开始就是值。</p>
<p>什么是指？这很难解释。</p>
<p>这就好比问数学中的数字是什么，几何中的点是什么。值就是JavaScript中的类似这样的一个东西。</p>
<p>数字是值，但其他东西也是值，比如对象和函数。但是很多东西，比如if语句或变量声明都不是值。</p>
<h2 id="值和代码"><a href="#值和代码" class="headerlink" title="值和代码"></a>值和代码</h2><p>为了将我们的JavaScript程序中的所有值与其他值区别开来，我想象一下安东尼画的小王子：</p>
<p><img src="/blog_imgs/just_javascript/02/little_prince.jpg" alt=""></p>
<p>我站在一颗小行星上——这是我程序的代码。</p>
<p>从表面上看，我看到了if语句和变量声明、逗号、大括号以及可能从JavaScript代码中找到的所有其他东西。</p>
<p>我得代码包括“函数调用”或是“多次执行此操作”甚至“抛出错误”等指令。我一步一步地完成这些指令——在我的小行星上做着差事。</p>
<p>但偶尔我会抬头看看。</p>
<p>在一个晴朗的夜晚，我在JavaScript天空中到了不同的值：booleans、numbers、strings、symbols、functions、objects、null和undefined——天呐！我可以在代码中使用他们，但他们并不存在于代码中。</p>
<p>在我的JavaScript宇宙中，值飘荡在太空。</p>
<p><img src="/blog_imgs/just_javascript/02/universe.png" alt=""></p>
<p>“等等，”你可能会说，“我一直认为值存在于我的代码里！”。在这里，我请求你的认知发生飞跃性的变化。要想成功构建这样的思维模型，还需要几个模块。<a href="https://www.jianshu.com/p/9adb15be9ac2" target="_blank" rel="noopener">Give It Five Minutes</a></p>
<p>回到值上面。大体上，这有两种值。</p>
<h3 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h3><p><strong>原始值</strong>包括数字和字符串等。打开浏览器的控制台并使用 <code>console.log()</code> 打印以下原始值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure>

<p>所有的原始值都有一些共同点。<strong>我的代码中没有什么可以影响他们</strong>。这听起来有点模糊，所以我们将在下一个模块中具体探讨这是什么意思。现在，我要说的是，原始值就像星星一样——冰冷而遥远，但在我需要它们的时候总是在那里。</p>
<p>这是第一种值。</p>
<h3 id="对象和函数"><a href="#对象和函数" class="headerlink" title="对象和函数"></a>对象和函数</h3><p><strong>对象和函数</strong>也是值，但他们不是原始值。这使他们变得特别。继续在控制台打印一些这样的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log([])</span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>请注意，浏览器的控制台是如何以不同于原始值的方式显示它们的。有些浏览器可能会在他们前面显示一个箭头，或者单点击它们的时候执行一些特殊的操作。如果你安装了一些不同的浏览器（例如Chrome和Firefox），比较它们是如何可视化对象和函数的。</p>
<p>对象和函数是特殊的，因为我可以从代码中操作它们。举个例子，我可以将它们与其他值连接起来。这也是模糊的——所以我们将在后面的模块中完善这个想法。现在，我可以说，<br>如果原始值像遥远的恒星，那么对象和函数更像漂浮在代码附近的岩石。它们离得很近，我才能够操作它们。</p>
<p>这就是第二种值。</p>
<p>你可能有问题。很好。如果你问一个问题，JavaScript世界可能会回答它！当然前提是你知道怎么提问。</p>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>但也有很多问题JavaScript无法回答。如果你想知道是向你最好的朋友坦白你的真实感受，还是一直等到你俩变成骷髅，JavaScript不会有多大帮助。</p>
<p>但是JavaScript很乐意回答这样的一些问题。这些问题有一个特殊的名字——表达式。</p>
<p>如果我们“询问”表达式2+2，JavaScript将用4“回答”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> + <span class="number">2</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p><strong>表达式是JavaScript可以回答的问题。JavaScript使用它唯一知道的方式——值，回答表达式。</strong></p>
<p><img src="/blog_imgs/just_javascript/02/expression.gif" alt=""></p>
<p>如果“表达式”这个词让你感到困惑，请将其视为一段表示值的代码。你可能会听到人们说2+2“结果”或“得到”4。这些都是说同一件事的不同方式。</p>
<p>我们问JavaScript 2+2，它的答案是4。表达式总是得到一个值。现在我们对表达方式的了解已经足够危险了！</p>
<p>我之前说JavaScript有多种值：numbers、strings、objects等等。我们如何知道每次说的是哪种值呢？</p>
<p>这听起来是个问题。我们敢问吗？</p>
<h3 id="检查类型"><a href="#检查类型" class="headerlink" title="检查类型"></a>检查类型</h3><p>首先，JavaScript宇宙中的所有值可能看起来都一样——就像天空中的亮点。但是如果你仔细观察，你会发现只有不到十种不同类型的值。相同类型的值的行为方式类似。</p>
<p>如果我们想检查一个值的类型，我们可以用typeof运算符。JavaScript将用一个预先确定的字符串值来回答我们的问题，比如“number”、“string”或“object”。</p>
<p><img src="/blog_imgs/just_javascript/02/telescope.png" alt=""></p>
<p>下面是一些您可以在浏览器控制台中尝试的示例:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="number">2</span>)); <span class="comment">// "number"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="string">"hello"</span>)); <span class="comment">// "string"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="literal">undefined</span>)); <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure>

<p>这里， <code>typeof(2)</code> 是一个表达式，它得到“number”值。</p>
<p>严格的说，typeof不需要使用括号。例如， <code>typeof 2</code> 和 <code>typeof(2)</code> 的工作原理是相同的。然而，有时需要括号来避免歧义。如果我们在typeof后面省略了括号，下面的一个例子就会中断。试着猜猜是哪一个：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(&#123;&#125;)); <span class="comment">// "object"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>([])); <span class="comment">// "object"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>)); <span class="comment">// "function"</span></span><br></pre></td></tr></table></figure>

<p>你可以在浏览器控制台中验证你的猜测。</p>
<p><img src="/blog_imgs/just_javascript/02/typeof.gif" alt=""></p>
<p>现在再来看看最后三个例子——这次要密切关注它们的结果。你有没有发现这些结果令人惊讶？为什么？</p>
<h2 id="值的类型"><a href="#值的类型" class="headerlink" title="值的类型"></a>值的类型</h2><p>作为一个有抱负的天文学家，您可能想知道JavaScript宇宙中可以观察到的每一种类型的值。经过将近25年的JavaScript研究，科学家们只发现了9种类型。</p>
<h3 id="原始值-1"><a href="#原始值-1" class="headerlink" title="原始值"></a>原始值</h3><ul>
<li><strong>Undefined</strong>(undefined)，用于无意中丢失的值</li>
<li><strong>Null</strong>(null), 用于故意丢失的值</li>
<li><strong>Booleans</strong>(true or false)，用于逻辑操作</li>
<li><strong>Numbers</strong>(-100, 3.14… )，用于数学计算</li>
<li><strong>Strings</strong>(“hello”, “abracadabra”… )，用于文本</li>
<li><strong>Symbols</strong>(不常见)，用于隐藏实现的细节</li>
<li><strong>BigInts</strong>(不常见、新的)，用于计算大数</li>
</ul>
<h3 id="对象和函数-1"><a href="#对象和函数-1" class="headerlink" title="对象和函数"></a>对象和函数</h3><ul>
<li><strong>Objects</strong>({}… )，用于分组相关的数据和代码</li>
<li><strong>Functions</strong>( <code>x =&gt; x * 2</code> … )，用于引用代码</li>
</ul>
<h3 id="没有别的类型了"><a href="#没有别的类型了" class="headerlink" title="没有别的类型了"></a>没有别的类型了</h3><p>你可能会问：“那我使用的别的类型呢？比如数组？”</p>
<p><strong>在JavaScript中，除了我们刚刚列举的值类型之外，没有其他基本值类型了</strong>。剩下的都是对象！例如，甚至数组、日期和正则表达式基本上都是JavaScript中的对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>([])); <span class="comment">// "object"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="keyword">new</span> <span class="built_in">Date</span>())); <span class="comment">// "object"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="regexp">/(hello|goodbye)/</span>)); <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure>

<p>“我知道，”你可能会说，“这是因为一切都是对象！”。唉，这是一个流行的都市传说，但事实并非如此。尽管像 <code>&quot;hi&quot;.toUpperCase()</code> 这样的代码使 <code>&quot;hi&quot;</code> 看起来像一个对象，但这只是一个幻觉。JavaScript会在执行此操作时创建包装器对象，然后立即将其丢弃。</p>
<p>如果这个机制不太好明白也没事。<strong>现在，你只需要记住原始值（如数字和字符串）不是对象。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>让我们回顾一下我们目前所知道的：</p>
<ol>
<li><strong>除了值就是别的</strong>：我们可以将值视为JavaScript雨中中“飘荡”的不同事物。它们不存在于我们的代码中，但我们可以从代码中引用它们。</li>
<li><strong>有两种值</strong>：它们是原始值，然后是对象和函数。总共有九种不同类型的值，每种类型都有特定的用途，但有些很少使用。</li>
<li><strong>有些值很孤单</strong>：比如null是Null类型的唯一的值，undefined也是Undefined类型的唯一值。我们之后会学习它，这两个孤独的值在很大程度上就是麻烦制造者。</li>
<li><strong>我们可以使用表达式提问</strong>：JavaScript将会用值来回答我们。例如，表达式2+2的答案是4。</li>
</ol>
<p>5.<strong>我们可以通过typeof表达式来检测值的类型</strong>：比如， <code>typeof(4)</code> 得到字符串“number”。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>是时候学以致用了。</p>
<p>即使你已经有了相当丰富的JavaScript经验，也不要跳过练习题！就在几年前，我从其中学到了一些东西。</p>
<p><a href="https://eggheadio.typeform.com/to/PLyTKB?email=akihi95@gmail.com&ck_subscriber_id=767004595" target="_blank" rel="noopener">点击此处去做练习！</a></p>
<p>接下来我们将更详细地探讨原始值。我们看看这些不同的类型（比如数字和Null）有什么共同点，并学习相等在JavaScript中意味着什么。</p>
<p>我们还将继续完善我们的思维模型。这部分提供了一个粗略的草图——一个近似值。我们将把焦点放在图片的不同部分，并用更多的细节填充它们，如<a href="https://www.liquidweb.com/kb/what-is-a-progressive-jpeg/?ck_subscriber_id=767004595" target="_blank" rel="noopener">渐进式JPEG图像</a>。</p>
<p>这些看起来是很小的一步，但我们正在为未来的一切奠定基础。我们正在一起构建JavaScript宇宙。</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>1.<a href="https://2ality.com/2013/10/typeof-null.html" target="_blank" rel="noopener">The history of “typeof null”</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/01/%E3%80%8AJust-JavaScript%E3%80%8B02-JavaScript%E5%AE%87%E5%AE%99/" data-id="ck8gp7rzj000nkb9hg1oc6fap" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-《Just-JavaScript》01-思维模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/31/%E3%80%8AJust-JavaScript%E3%80%8B01-%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time datetime="2020-03-31T13:40:45.000Z" itemprop="datePublished">2020-03-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/31/%E3%80%8AJust-JavaScript%E3%80%8B01-%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B/">《Just JavaScript》01.思维模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>读以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">a = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>当他们运行后a和b的值是多少？在你往下阅读之前，先在你的脑子中想出答案。</p>
<p>如果你已经写了一段时间的JavaScript，你可能会想：“这比我每天写的代码简单多了，意义何在？”</p>
<p>这个练习的目标不是向你介绍变量，我们认为你已经对这些很熟悉了。相反的，它是为了让你注意并反思你的思维模型。</p>
<h2 id="什么是思维模型"><a href="#什么是思维模型" class="headerlink" title="什么是思维模型"></a>什么是思维模型</h2><p>再次阅读上面的代码，目的是真正确定结果是什么。（我们稍后看为什么这个目的很重要）</p>
<p>当你第二次读它的时候，一步步地注意你脑子里发生的事，你可能会有这样的独白：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.声明一个变量a,并给它赋值10</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 2.声明一个变量b,将a的值赋给它,a为10,所以b也为10</span></span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"><span class="comment">// 3.将0赋给a</span></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 4.所以最后的答案是a的值为0，b的值为10</span></span><br></pre></td></tr></table></figure>

<p>可能你脑中想的会有点不一样，可能你想的是给a设置值而不是赋值，或者你可能用不同的顺序读它。甚至你最后得出了不同的结果。注意一下具体哪里不同，即使是这段独白也无法真正捕捉到你脑海中发生的事情。你可能会说“把b设为a”，但是设置一个变量意味着什么呢？</p>
<p>你可能会发现，对每个熟悉的基本编程概念（比如变量）和操作（比如赋值），会有一套根深蒂固的类比与之相关。一些来自于现实的世界，其他的可能会从你最初学到的领域重新运用，比如数学中的数字。这些类比可能会部分重叠甚至矛盾，但是它们仍然帮助你理解在代码中发生了什么。</p>
<p>举个例子，很多人最初把变量当做盒子来学习，你可以往里面放东西。当你看到一个变量的时候，尽管你并没有真正地想象出一个盒子，但是在你的脑海里它们可能仍表现得像一个盒子。这些在你脑海中相似的运作方式被我们称做思维模型。思维模型对编程很久的你来说可能有难度，但是你要尝试注意和反思它们。它们可能是视觉的、空间的和机械的思维捷径的组合。</p>
<p>这些直觉（类似把变量比作盒子）在我们整个编程生涯中会影响我们如何读代码。但是有时候，我们的思维模型是错误的。可能我们早期读过的辅导课为了能简单的解释一些东西而牺牲了它的正确性。也许我们错误的从之前学过的另一种语言转移了关于特定语言特征的直觉。也许我们从某段代码推断出一种思维模型，但从未验证它是否准确。</p>
<p>识别和解决这些问题就是这本书《Just JavaScript》的全部内容。我们将逐步构建（或者，可能的话，重新构建）你关于JavaScript的思维模型，使之准确而有用。一个好的思维模型将会帮助你更快的定位和修复bug，更好的理解别人的代码，对你自己写的代码更自信。</p>
<p>（顺带一提，a的值为0，b的值为10是正确答案）。</p>
<h2 id="快慢编码"><a href="#快慢编码" class="headerlink" title="快慢编码"></a>快慢编码</h2><p>丹尼尔·卡尼曼的《思考，快与慢》是一本广受欢迎的非小说类书籍。它的中心论点是，人类在思考时使用两种不同的“系统”。</p>
<p>只要有可能，我们就依靠“快速”系统。我们与许多动物共享这个紫铜，这给我们惊人的力量，就像走路时不摔倒一样。这个“快速”系统擅长模式匹配（生存所必需！！）以及“内脏反应”。但是它并不擅长计划。</p>
<p>独特的是，由于额叶的发育，人类也有一个“慢”思维系统。这个“慢”思维系统负责复杂的逐步的推理。它让我们计划未来的事件，参与争论或遵循数学证明。</p>
<p>因为使用“慢”系统在精神上非常消耗，所以我们倾向于默认使用“快”系统，即使在处理诸如编码之类的智能任务时也是如此。</p>
<p>想象你正忙于大量的工作，并且你希望快速识别此函数的功能，快速浏览以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">duplicateSpreadsheet</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (original.hasPendingChanges) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'You need to save the file before you can duplicate it.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> copy = &#123;</span><br><span class="line">        created: <span class="built_in">Date</span>.now(),</span><br><span class="line">        author: original.author,</span><br><span class="line">        cells: original.cells,</span><br><span class="line">        metadata: original.metadata,</span><br><span class="line">    &#125;;</span><br><span class="line">    copy.metadata.title = <span class="string">'Copy of '</span> + original.metadata.title;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能会思考：</p>
<ul>
<li>这个函数复制一个电子表格</li>
<li>如果初始电子表格不存在它会抛出错误</li>
<li>它给新的电子表格标题前加了“Copy of”</li>
</ul>
<p>你可能没有注意到（如果你注意到了，那就太好了！）这个函数也意外地改变了原始电子表格的标题。</p>
<p>每个程序员每天都会遇到这样的错误。但是现在你知道bug存在了，你会换种方式读代码吗？如果你一直在使用“快”模式阅读代码，则很可能会切换到更费劲的“慢”模式来查找他。</p>
<p>在“快”模式下，我们通过名字、注释和它总体的结构猜测代码干了什么。而在“慢”模式下，我们逐步追溯代码做了什么。</p>
<p>这就是为什么正确的思维模式非常重要。在我们的脑海中模拟一台计算机已经够难了——而这种努力被错误的思维模式所浪费。</p>
<p>如果你根本找不到bug，别担心，这意味着你会从这门课中得到最大的收获！在接下来的模块中，我们将一起重塑JavaScript的思维模型，以便你一目了然地看到bug。</p>
<p>在下一个模块，我们将开始为一些最基本的JavaScript概念（值和变量）构建思维模型。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/31/%E3%80%8AJust-JavaScript%E3%80%8B01-%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B/" data-id="ck8gp7ry0000hkb9h5ztd1mk0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-《Just-JavaScript》03-值和变量" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/31/%E3%80%8AJust-JavaScript%E3%80%8B03-%E5%80%BC%E5%92%8C%E5%8F%98%E9%87%8F/" class="article-date">
  <time datetime="2020-03-31T09:36:08.000Z" itemprop="datePublished">2020-03-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/31/%E3%80%8AJust-JavaScript%E3%80%8B03-%E5%80%BC%E5%92%8C%E5%8F%98%E9%87%8F/">《Just JavaScript》03. 值和变量</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们将以一个小的代码片段开始这个模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reaction = <span class="string">'yikes'</span>;</span><br><span class="line">reaction[<span class="number">0</span>] = <span class="string">'l'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reaction);</span><br></pre></td></tr></table></figure>

<p>你希望它做什么？我们还没有讲到这个，所以如果你不确定的话没关系。<strong>试着用你目前的JavaScript知识来回答这个问题。</strong></p>
<p>现在我想让你花点时间，一步一步地为这段代码的每一行写下你确切的思考过程。注意你现有的思维模型中的任何欠缺或不确定性，并把它们也写下来。如果你对此有任何疑问，尽可能清楚地将它表达出来。</p>
<p><img src="/blog_imgs/just_javascript/03/spoilers.jpg" alt=""></p>
<p>在你写完之前你的思考前不要往下滚动。</p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p>答案是这样的。此代码将打印“yikes”或抛出错误，具体取决于你是否处于严格模式。它永远不会印“likes”。</p>
<h2 id="原始值是不可改变的"><a href="#原始值是不可改变的" class="headerlink" title="原始值是不可改变的"></a>原始值是不可改变的</h2><p>你答对了吗？这可能看起来像一个很小的问题，就像大家在JavaScript面试中问的那种问题，但在实际编码中并没有太多出现。即使如此，它也说明了关于原始值的一个重要特点。</p>
<p><strong>我不能改变原始值。</strong></p>
<p>我将使用一个很小的例子来解释这点。字符串（原始值）和数组（非原始值，对象）有一些表面上的相似之处。数组是项的序列，字符串是字符的序列。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">212</span>, <span class="number">8</span>, <span class="number">506</span>];</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'hello'</span>;</span><br></pre></td></tr></table></figure>

<p>你可以访问字符串的第一个字符就像访问数组项那样，几乎感觉字符串就是数组（但它们并不是！）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>]); <span class="comment">// 212</span></span><br><span class="line"><span class="built_in">console</span>.log(str[<span class="number">0</span>]); <span class="comment">// "h"</span></span><br></pre></td></tr></table></figure>

<p>你可以改变数组的第一项：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">0</span>] = <span class="number">420</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [420, 8, 506]</span></span><br></pre></td></tr></table></figure>

<p>所以凭直觉来说，很容易假设可以对字符串执行相同的操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str[<span class="number">0</span>] = <span class="string">'j'</span>; <span class="comment">// ???</span></span><br></pre></td></tr></table></figure>

<p><strong>但是你不能这样做。</strong></p>
<p>这有一点很重要，我们需要添加到我们的思维模型。字符串是原始值，这是十分重要的。</p>
<p><strong>所有的原始值都是不可改变的。</strong>“Immutable”是拉丁语中一种奇特的说法“unchangeable”。只读的，你根本不能改变原始值。</p>
<p>如果你尝试在一个原始值上设置属性，不管是字符串、数字还是其他什么，JavaScript不会允许你这样做。它是否会默默拒绝你的请求或报错取决于你的代码运行在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">哪个模式</a>！</p>
<p>但我向你保证，这永远行不通:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fifty = <span class="number">50</span>;</span><br><span class="line">fifty.shades = <span class="string">'gray'</span>; <span class="comment">// No!</span></span><br></pre></td></tr></table></figure>

<p>就像一些数组，50是一个原始值，你不能给它设置属性。</p>
<p>在我的JavaScript宇宙里面，所有的原始值存在于离我的代码很远的外圆中——就像遥远的恒星。这提醒我，即使我可以从代码中引用它们，也无法更改它们。他们保持原样。</p>
<p>我觉得这异常地令人安慰：</p>
<p><img src="/blog_imgs/just_javascript/03/unnamed.png" alt=""></p>
<h2 id="一个矛盾？"><a href="#一个矛盾？" class="headerlink" title="一个矛盾？"></a>一个矛盾？</h2><p>我刚刚演示了原始值是只读的，或者用我们这个时代的话说，是不可变的。这里有一个片段来测试你的思维模型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pet = <span class="string">'Narwhal'</span>;</span><br><span class="line">pet = <span class="string">'The Kraken'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(pet); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>像以前一样，用几句话写下你的思考过程。别急着往前走。一步一步地关注你对每一行的想法。字符串的不变性在这里起作用吗？它起什么作用？</p>
<p><img src="/blog_imgs/just_javascript/03/spoilers.jpg" alt=""></p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p><code>...</code> </p>
<p>如果你认为我是在捣乱你的大脑，那你完全是对的！答案是“The Kraken”——字符串的不变性不起作用。</p>
<p>如果你错了，不要气馁！最后这两个例子看起来肯定是相互矛盾的。</p>
<p>这是一个很重要的领悟！</p>
<p>当你对一门语言不熟悉时，你可能会倾向于忽略矛盾。毕竟，如果你追逐每一个矛盾，你会深陷入一个兔子洞深而学不到任何东西。</p>
<p>但既然你决定建立思维模型，你就需要质疑矛盾，它们展示出了思维模型的缺口。</p>
<h2 id="变量是导线"><a href="#变量是导线" class="headerlink" title="变量是导线"></a>变量是导线</h2><p>再看看这些例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pet = <span class="string">'Narwhal'</span>;</span><br><span class="line">pet = <span class="string">'The Kraken'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(pet); <span class="comment">// "The Kraken"</span></span><br></pre></td></tr></table></figure>

<p>我们知道字符串不能改变因为它们是原始值。但是pet变量的确变成了“The Kraken”。发生了什么呢？</p>
<p>这似乎是一个矛盾，但事实并非如此。我们只说原始值不能改变。我们对于变量什么都没说！</p>
<p>当我们完善我们的思维模型时候，我们可能需要整理一下相关的概念。</p>
<p><strong>变量不是值。</strong></p>
<p>变量指向值。</p>
<p>在我的宇宙，一个变量代表一根导线。它有两端和方向：它从我代码中的一个名字开始，最后指向我宇宙中的某个值。</p>
<p>举个例子，我可以将pet变量指向“Narwhal”值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pet = <span class="string">'Narwhal'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/blog_imgs/just_javascript/03/unnamed.gif" alt=""></p>
<p>之后可以对变量执行两项操作：</p>
<h3 id="给变量赋值"><a href="#给变量赋值" class="headerlink" title="给变量赋值"></a>给变量赋值</h3><p>我可以做的一件事是给我的变量赋值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pet = <span class="string">'The Kraken'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/blog_imgs/just_javascript/03/unnamed1.gif" alt=""></p>
<p>我在这里所做的只是告知JavaScript将左侧的“wire”（我的pet变量）指向右侧的值（“The Kraken”）。它将一直指向那个值，除非我之后重新分配它。</p>
<p>注意，我不能在左边放任何东西：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'war'</span> = <span class="string">'peace'</span>; <span class="comment">// Nope. (Try it in the console.)</span></span><br></pre></td></tr></table></figure>

<p><strong>赋值的左侧必须是导线。</strong>目前，我们只知道变量是“导线”。但是还有另一种“导线”我们将在后面的模块中讨论。也许，你能猜出是什么？（提示：它包含方括号或点，我们已经见过几次了）。</p>
<p>还有另外一条规则。</p>
<p><strong>赋值的右侧必须是表达式。</strong>它可以是简单的值，比如2或“hello”，也可以是更复杂的表达式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pet = count + <span class="string">' Dalmatians'</span>;</span><br></pre></td></tr></table></figure>

<p>在这里，count+“Dalmatians”是一个表达式——对JavaScript来说是一个问题。JavaScript将用一个值（例如，“101 Dalmatians”）来回答这个问题。从现在起，pet“导线”将开始指向这个值。</p>
<p>如果右边必须是表达式，这是否意味着像2这样的数字或像用代码编写的’the Kraken’这样的字符串也是表达式？对！这样的表达式称为字面量——因为我们逐字记录它们的值。</p>
<h3 id="读取变量的值"><a href="#读取变量的值" class="headerlink" title="读取变量的值"></a>读取变量的值</h3><p>我还可以读取变量的值——例如，要记录它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">console.log(pet);</span><br></pre></td></tr></table></figure>

<p>这并不奇怪。</p>
<p>但是请注意，我们传递给console.log的不是pet变量。我们可以通俗地说，但是我们不能真的把变量传递给函数。我们传递的是pet变量的当前值。这是怎么工作的呢？</p>
<p>原来，像pet这样的变量名也可以用作表达式！当我们编写pet时，我们在问JavaScript一个问题：“pet的当前价值是什么？”为了回答我们的问题，JavaScript跟随pet的“导线”，并在“导线”的末尾返回值。</p>
<p>所以同一个表达式可以在不同的时间给我们不同的值！</p>
<h3 id="名词和动词"><a href="#名词和动词" class="headerlink" title="名词和动词"></a>名词和动词</h3><p>谁在乎你说的是“传递变量”还是“传递值”？深究这点差别不是过于卖弄学问吗？我当然不会打断你的同事来纠正他们，甚至是你自己。那将会浪费大家的时间。</p>
<p>但在你的头脑中，你需要清楚地知道你可以用每一个概念做什么。你不能骑自行车溜冰。你不能让鳄梨费气力啊。你不能像蚊子一样发嗖嗖声。而且你不能传递一个变量——至少在JavaScript中不能。</p>
<p>这里有一个小例子说明为什么这些细节很重要。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    x = x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> money = <span class="number">10</span>;</span><br><span class="line">double(money);</span><br><span class="line"><span class="built_in">console</span>.log(money); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>如果我们认为double（money）传递了一个变量，那么我们可以预期x=x*2将使该变量加倍。但事情不是这样的。我们知道double（money）的意思是“计算出货币的价值，然后将其传递给double”。所以答案是10。真是个骗局！</p>
<p>你脑子里有哪些不同的JavaScript名词和动词？他们之间有什么关系？将你最常使用的列一个清单。</p>
<h3 id="把它放在一起"><a href="#把它放在一起" class="headerlink" title="把它放在一起"></a>把它放在一起</h3><p>现在让我们重温一下来自思维模型的第一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> y = x;</span><br><span class="line">x = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>我建议你拿一张纸或一个绘图应用程序，一步一步地画出x和y变量的“连线”的情况图。</p>
<p><strong>第一行的作用不大：</strong></p>
<p><img src="/blog_imgs/just_javascript/03/unnamed2.gif" alt=""></p>
<ul>
<li>声明一个x变量  <ul>
<li>为x变量生成导线</li>
</ul>
</li>
<li>给x赋值10<ul>
<li>让x的导线指向10</li>
</ul>
</li>
</ul>
<p><strong>第二行很短，但它做了很多事情：</strong></p>
<p><img src="/blog_imgs/just_javascript/03/unnamed3.gif" alt=""></p>
<ul>
<li><p>声明一个y变量</p>
<ul>
<li>为y变量生成导线</li>
</ul>
</li>
<li><p>把x的值赋给y</p>
<ul>
<li>计算表达式：x<ul>
<li>我们要回答的问题是“x”</li>
<li><strong>跟随x的导线——答案是值10</strong></li>
</ul>
</li>
<li>x表达式结果是值10</li>
<li>因此，将10的值赋给y</li>
<li>把y的导线指向值10</li>
</ul>
<p><strong>最后，我们进入第三行：</strong></p>
</li>
</ul>
<p><img src="/blog_imgs/just_javascript/03/unnamed4.gif" alt=""></p>
<ul>
<li>将0的值赋给x<ul>
<li>将x的导线指向值0</li>
</ul>
</li>
</ul>
<p>最后，x变量指向值0，y变量指向值10。注意y=x并不意味着将y指向“x”。我们不能把变量指向彼此！<strong>变量总是指向值</strong>。当我们看到一个赋值时，我们“询问”右边的值，并将左边的“线”指向它。</p>
<p>我在思维模型中提到，把变量看作盒子是相当常见的。我们要建造的宇宙根本就没有盒子。<strong>它只有导线！</strong>这看起来有点烦人。为什么我们不能“将0和10放入变量中，而是将变量指向它们？”</p>
<p>使用导线对于解释许多其他概念将是非常重要的，就像严格的等式，对象标识和变动。我们要坚持使用导线，所以你最好现在就开始习惯。</p>
<p>我的宇宙充满了导线。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p><strong>原始值是不可变的：</strong>在我们的代码中，我们无法做任何事情来影响它们或以任何方式更改它们。他们保持原样。例如，不能对字符串值设置属性，因为它是原始值。数组不是原始值，所以我们可以设置它们的属性。</p>
</li>
<li><p><strong>变量不是值：</strong>每个变量都指向一个特定的值。我们可以使用=赋值运算符来更改它指向的值。</p>
</li>
<li><p><strong>变量就像导线：</strong>“导线”并不是JavaScript的概念——但是它帮助我们理解变量如何指向值。还有一种不同的“电线”，不是变量，但我们还没有讨论过。</p>
</li>
<li><p><strong>留意矛盾：</strong>如果你学到的两件事似乎互相矛盾，不要灰心。通常这是一个迹象，表明下面隐藏着更深层次的真相。</p>
</li>
<li><p><strong>名词和动词很重要：</strong>我们正在建立一个思维模型，这样我们就能对宇宙中可能发生或不可能发生的事情充满信心。随便马虎的说话是可以的，但我们的思维需要精确。</p>
</li>
</ul>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>本单元也有练习题供你练习！</p>
<p><a href="https://el2.convertkit-mail.com/c/o8u6klng6ncwu4e40piv/6gtehou6oom6de/aHR0cHM6Ly9lZ2doZWFkaW8udHlwZWZvcm0uY29tL3RvL1JXSmczbT9lbWFpbD1ha2loaTk1QGdtYWlsLmNvbQ==" target="_blank" rel="noopener">点击这里，通过一些简短的练习巩固这个心理模型。</a></p>
<p><strong>不要跳过它们！</strong></p>
<p>即使你可能熟悉变量的概念，这些练习将帮助你巩固我们正在建立的心理模型。我们需要这个基础才能继续更复杂的话题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/31/%E3%80%8AJust-JavaScript%E3%80%8B03-%E5%80%BC%E5%92%8C%E5%8F%98%E9%87%8F/" data-id="ck96xik9l0000sljcbv41b6wf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-内存模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/31/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time datetime="2019-07-31T06:21:08.000Z" itemprop="datePublished">2019-07-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/31/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">内存模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="计算机所有信息的存储方式"><a href="#计算机所有信息的存储方式" class="headerlink" title="计算机所有信息的存储方式"></a>计算机所有信息的存储方式</h3><p>计算机中采用二进制表示各种信息，也就是0和1，字节是基本单位。</p>
<h4 id="一、计算机中数的表示"><a href="#一、计算机中数的表示" class="headerlink" title="一、计算机中数的表示"></a>一、计算机中数的表示</h4><h5 id="1-表示范围"><a href="#1-表示范围" class="headerlink" title="1.表示范围"></a>1.表示范围</h5><p>计算机数的表示范围跟字节有关：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>表示方式</th>
</tr>
</thead>
<tbody><tr>
<td>无符号数</td>
<td>0 ~ 2^n-1</td>
</tr>
<tr>
<td>有符号数</td>
<td>-2^(n-1)-1 ~ 2^(n-1)-1</td>
</tr>
</tbody></table>
<p>小数：符号位+整数位+指数位<br>非法数字：NaN<br>正无穷大，负无穷大：±∞</p>
<h5 id="2-原码、反码、补码"><a href="#2-原码、反码、补码" class="headerlink" title="2.原码、反码、补码"></a>2.原码、反码、补码</h5><ul>
<li>原码：正数的原码是将数的符号位用0表示，负数的原码是将数的符号位用1表示。  </li>
<li>反码：反码表示为符号位不变，其余位按位取反。</li>
<li>补码：原码除符号位外每位取反加1。  </li>
</ul>
<p>对于正数，原码=反码=补码；对于负数，它的符号位是1，反码就是除符号位每位取反，补码是它的反码加一。计算机对于数字是以补码的方式存储，因为不以补码的方式存储0会有两个存储方式，正数和负数相加结果不对。</p>
<h5 id="3-位运算"><a href="#3-位运算" class="headerlink" title="3.位运算"></a>3.位运算</h5><p>或运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 | 0 &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>与运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &amp; 0 &#x3D; 0;</span><br></pre></td></tr></table></figure>
<p>异或运算（同0异1）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 ^ 0 &#x3D; 1; 1 ^ 1 &#x3D; 0; 0 ^ 0 &#x3D; 0;</span><br></pre></td></tr></table></figure>
<p>取反</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~0 &#x3D; 1; ~1 &#x3D; 0;</span><br></pre></td></tr></table></figure>


<p>位移（左：低位补0，右移：高位补0）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;&lt; 2 &#x3D; 0000 0001 &lt;&lt; 2 &#x3D; 0000 0100 &#x3D; 4</span><br></pre></td></tr></table></figure>
<p>应用：</p>
<h6 id="求数字x的第y位为0还是1"><a href="#求数字x的第y位为0还是1" class="headerlink" title="求数字x的第y位为0还是1"></a>求数字x的第y位为0还是1</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int getFlag(int x,int y) &#123;</span><br><span class="line">    return (x &gt;&gt; (32 - y)) &amp; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="将数字x的第y位设为0或1"><a href="#将数字x的第y位设为0或1" class="headerlink" title="将数字x的第y位设为0或1"></a>将数字x的第y位设为0或1</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int setFlag(int x,int y,int v) &#123;</span><br><span class="line">    if(v &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return x &amp; 1 &lt;&lt; ~(32 - y)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return x | (1 &lt;&lt; (32 - y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二、编码"><a href="#二、编码" class="headerlink" title="二、编码"></a>二、编码</h4><p>对于不同国家的语言有不同的编码方式，同样的编码在不同地方会被解释成不同的语言符号。假如我们想要打开一个文件，比如知道它的编码方式是什么，用它的编码方式打开，否则用错误的编码方式打开文件，就会遇到乱码问题。</p>
<h5 id="1-ASCII码"><a href="#1-ASCII码" class="headerlink" title="1.ASCII码"></a>1.ASCII码</h5><p>ASCII码一共定义了128个字符的编码。</p>
<h5 id="2-Unicode"><a href="#2-Unicode" class="headerlink" title="2.Unicode"></a>2.Unicode</h5><p>英语使用128个符号编码就够了，但是用来表示其他国家的语言却不够。所有就产生了这样的需求：需要一种编码，将世界各个国家所有的语言符号都包括进去。那么每一个符号都有对应的编码，那么我们可以通过这种编码查看文件就不会产生乱码的问题。这就是Unicode，它的名字即表示这是一种独一无二的编码。</p>
<h5 id="3-UTF-8"><a href="#3-UTF-8" class="headerlink" title="3.UTF-8"></a>3.UTF-8</h5><p>UTF-8是Unicode的实现方式之一。</p>
<h5 id="4-gb2312"><a href="#4-gb2312" class="headerlink" title="4.gb2312"></a>4.gb2312</h5><p>gb2312是中文简体字编码。已经包括了我们生活中最常用的所有汉字与一些符号。</p>
<h5 id="5-gbk"><a href="#5-gbk" class="headerlink" title="5.gbk"></a>5.gbk</h5><p>由于中文汉字繁多，gb2312只包括了六千多个汉字，还不能够完全表示，所以gbk在gb2312的基础上兼容扩展了更多的汉字，还包括繁体字。</p>
<h4 id="三、内存分配"><a href="#三、内存分配" class="headerlink" title="三、内存分配"></a>三、内存分配</h4><h5 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1.基本类型"></a>1.基本类型</h5><p>基本类型在内存空间直接存储它们相应的值，比如数字，字符串。</p>
<h5 id="2-引用类型"><a href="#2-引用类型" class="headerlink" title="2.引用类型"></a>2.引用类型</h5><p>引用类型在内存空间不直接存储它们的值，而是存储这个数据的引用。比如数组、函数。</p>
<h5 id="3-堆栈"><a href="#3-堆栈" class="headerlink" title="3.堆栈"></a>3.堆栈</h5><p>基本类型和引用类型分别存储在内存的栈和堆中。基本类型是存储在栈中的简单数据，如果我们对他进行修改，是可以直接修改成功的，而引用类型值是存储在堆中的对象，如果有两个相同对象指向同一个引用，我们修改其中一个会导致另一个也跟着修改。</p>
<h4 id="五、内存回收"><a href="#五、内存回收" class="headerlink" title="五、内存回收"></a>五、内存回收</h4><p>这个问题等我哪天想明白了再更新。。。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/31/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" data-id="ck8gp7rzg000mkb9h5hix24zf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-闭包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/01/%E9%97%AD%E5%8C%85/" class="article-date">
  <time datetime="2019-04-01T14:21:08.000Z" itemprop="datePublished">2019-04-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/01/%E9%97%AD%E5%8C%85/">闭包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>&emsp;&emsp;和大多数现代编程语言一样，JavaScript也采用词法作用域，也就是说，函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定的。为了实现这这种词法作用域，JavaScript函数对象的内部状态不仅包含函数的逻辑代码，还必须引用当前的<code>作用域链</code>。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性被称为<code>&quot;闭包&quot;</code>。</p>
<blockquote>
<p>&emsp;&emsp;作用域链：每一段JavaScript代码(全局代码或函数)都有一个与之关联的作用域链(scope chain)。这个作用域链是一个对象列表或者链表，这组对象定义了这段代码”作用域中”的变量。当JavaScript需要查找变量x的值的时候(这个过程称做”变量解析”)，它会从链中的第一个对象开始查找，如果这个对象有一个名为x的属性，则会直接使用这个属性的值，如果第一个对象中不存在名为x的属性，JavaScript会继续查找链上的下一个对象。如果第二个对象依然没有名为x的属性，则会继续查找下一个对象，以此类对。如果作用域链上没有任何一个对象含有属性x，那么久人为这段代码的作用域链上不存在x，并最终抛出一个引用错误异常。<br>&emsp;&emsp;在JavaScript最顶层代码中(也就是不包含在任何函数定义内的代码)，作用域链由一个全局对象组成。在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域链上至少有三个对象。当定义一个函数时，它实际上保存一个作用域链。当调用这个函数时，它穿件一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的”链”。对于嵌套函数来讲，每次调用外部函数时，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都有微妙的差别——在每次调用外部函数时，内部函数的代码都是相同的，而且关联这段代码的作用域链也不相同。</p>
</blockquote>
<p>&emsp;&emsp;所有的JavaScript函数都是闭包；他们都是对象，他们都关联到作用域链。定义大多数函数时的作用域链在调用函数时依然有效，但这并不影响闭包。当调用函数时闭包所指向的作用域链和定义函数时的作用域链不是同一个作用域链时，就会有一些微妙的变化。当一个函数潜逃了另外一个函数，外部函数将嵌套的函数对象作为返回值返回的时候往往会发生这种事情。有很多强大的编程技术都利用到了这类嵌套的函数闭包，以至于这种编程模式在JavaScript中非常常见。<br>&emsp;&emsp;理解闭包首先要了解嵌套函数的此法作用域规则:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;  <span class="comment">// 全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;  <span class="comment">// 局部变量</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope;   <span class="comment">// 在作用域中返回这个值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope()  <span class="comment">// =&gt; "local scope"</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>checkscope()</code>函数声明了一个局部变量，并定义一个函数<code>f()</code>，函数<code>f()</code>返回了这个变量的值，最后将函数<code>f()</code>的执行结果返回。对上面的代码做一点改动：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;  <span class="comment">// 全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;  <span class="comment">// 局部变量</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope;   <span class="comment">// 在作用域中返回这个值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这段代码中，函数内的一对圆括号移动到了<code>checkscope()</code>之后。<code>checkscope()</code>现在仅仅返回函数内嵌套的一个函数对象，而不是直接返回结果。在定义函数的作用域外面，调用这个嵌套的函数（包含最后一行代码的最后一对括号），最后仍会返回<code>&quot;local scope&quot;</code>。<br>&emsp;&emsp;词法作用域的基本规则：JavaScript函数的执行用到了作用域链，这个作用域链是函数定义的时候创建的。嵌套的函数<code>f()</code>定义在这个作用域链里，其中的变量scope一定是局部变量，不管在何时何地执行函数<code>f()</code>，这种绑定在执行<code>f()</code>时依然有效，因此最后一行代码返回<code>&quot;local scope&quot;</code>，而不是<code>&quot;global scope&quot;</code>。简言之，闭包这个特性很强大：它们可以捕捉到局部变量（和参数），并一直保存下来，看起来像这些变量绑定到了再其中定义它们的外部函数。<br>例如，定义一个<code>uniqueInteger</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化函数对象的计数器属性</span></span><br><span class="line"><span class="comment">// 由于函数声明被提前，因此这里可以在函数声明前给它的成员赋值</span></span><br><span class="line">uniqueInteger.counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次调用这个函数都会返回一个不同的整数</span></span><br><span class="line"><span class="comment">// 它使用一个属性来记住下一次将要返回的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueInteger</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> uniqueInteger.counter++; <span class="comment">// 先返回计数器的值，然后计数器自增1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个函数使用自身的一个属性来保存每次返回的值，以便每次调用都能跟从上次的返回值。但这种做法有一个问题，就是恶意代码可能将计数器重置或者把一个非整数赋值给它，导致<code>uniqueInteger()</code>函数不一定能产生”唯一”的“整数”。而闭包可以捕捉到单个函数调用的局部变量，并将这些局部变量用作私有状态。利用闭包重写<code>uniqueInteger()</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uniqueInteger = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 定义函数并立即调用</span></span><br><span class="line">  <span class="keyword">var</span> counter = <span class="number">0</span>;  <span class="comment">// 函数的私有状态</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> counter++; &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;第一行代码看起来像将函数赋值给一个变量<code>uniqueInteger</code>，实际上，这段代码定义了一个立即调用函数（函数的开始带有左圆括号），因此是这个函数的返回值赋值给变量<code>uniqueInteger</code>。这个函数体返回另外一个函数，这是一个嵌套的函数，我们将它赋值给变量<code>uniqueInteger</code>，嵌套的函数是可以访问作用域内的变量的，而且可以访问外部函数中定义的<code>counter</code>变量。当外部函数返回值后，其他任何代码都无法访问<code>counter</code>变量，只有内部的函数才能访问到它。<br>&emsp;&emsp;像<code>counter</code>一样的私有变量不是只能用在一个单独的闭包内，在同一个外部函数内定义的多个嵌套函数也可以访问它，这多个嵌套函数都共享一个作用域链：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> n++; &#125;,</span><br><span class="line">    reset: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; n = <span class="number">0</span>; &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = counter(), d = counter(); <span class="comment">// 创建两个计数器</span></span><br><span class="line">c.count(); <span class="comment">// =&gt; 0</span></span><br><span class="line">d.count(); <span class="comment">// =&gt; 0:他们互不干扰</span></span><br><span class="line">c.reset(); <span class="comment">// reset()和count()方法共享状态</span></span><br><span class="line">c.count(); <span class="comment">// =&gt; 0:因为重置了c</span></span><br><span class="line">d.count(); <span class="comment">// =&gt; 1:没有重置d</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>counter()</code>函数返回了一个“计数器”对象，这个对象包含两个方法：<code>count()</code>返回下一个整数，<code>reset()</code>将计数器重置为内部状态。这两个方法都可以访问私有变量n。再者，每次调用counter()都会创建一个新的作用域链和一个新的私有变量。因此，如果调用<code>counter()</code>量词，则会得到两个计数器对象，而且彼此包含不同的私有变量，调用其中一个计数器对象的<code>count()</code>或<code>reset()</code>不会影响到另外一个对象。<br>&emsp;&emsp;其实可以将这个闭包合并为属性存取器方法<code>getter</code>和<code>setter</code>。如下，利用闭包实现<code>counter()</code>的私有状态：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params">n</span>) </span>&#123; <span class="comment">// 函数参数n是一个私有变量</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 属性getter方法返回并给私有计数器var递增1</span></span><br><span class="line">    <span class="keyword">get</span> count() &#123; <span class="keyword">return</span> n++; &#125;,</span><br><span class="line">    <span class="comment">// 属性setter不允许n递减</span></span><br><span class="line">    <span class="keyword">set</span> count(m) &#123;</span><br><span class="line">      <span class="keyword">if</span> (m&gt;=n) n = m;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"count can only be set to a larger value"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = counter(<span class="number">1000</span>);</span><br><span class="line">c.count   <span class="comment">// =&gt; 1000</span></span><br><span class="line">c.count   <span class="comment">// =&gt; 1000</span></span><br><span class="line">c.count = <span class="number">2000</span></span><br><span class="line">c.count   <span class="comment">// =&gt; 2000</span></span><br><span class="line">c.count = <span class="number">2000</span>  <span class="comment">// =&gt; Error!</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个<code>counter()</code>函数并为声明局部变量，而只是使用参数n来保存私有状态，属性存取器方法可以访问n。这样调用<code>counter()</code>的函数就可以指定私有变量的初始值了。<br>&emsp;&emsp;定义一个<code>addPrivatePropetry()</code>函数，这个函数定义一个私有变量，以及两个嵌套的函数用来获取和设置这个私有变量的值，它将这些嵌套函数添加为所指定对象的方法，利用闭包实现的私有属性存取器方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数给对象o增加了属性存取器方法</span></span><br><span class="line"><span class="comment">// 方法名称为get&lt;name&gt;和set&lt;name&gt;。如果提供了一个判定函数</span></span><br><span class="line"><span class="comment">// setter方法就会用它来检测参数的合法性，然后在存储它</span></span><br><span class="line"><span class="comment">// 如果判定函数返回false，setter方法抛出一个异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数不的getter和setter函数</span></span><br><span class="line"><span class="comment">// 所操作的属性值并没有存储在对象o中</span></span><br><span class="line"><span class="comment">// 相反，这个值仅仅是保存在函数中的局部变量中</span></span><br><span class="line"><span class="comment">// getter和setter方法同样是局部函数，因此可以访问这个局部变量</span></span><br><span class="line"><span class="comment">// 也就是说，对于两个存取器的方法来说这个变量是私有的</span></span><br><span class="line"><span class="comment">// 没有办法绕过存存取器来设置或修改这个值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addPrivatePropetry</span>(<span class="params">o, name, predicate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value; <span class="comment">// 这是一个属性值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// getter方法简单地将其返回</span></span><br><span class="line">  o[<span class="string">"get"</span> + name] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> value; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setter方法首先检查值是否合法，若不合法就抛出异常</span></span><br><span class="line">  <span class="comment">// 否则就将其存储</span></span><br><span class="line">  o[<span class="string">"set"</span> + name] = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (predicate &amp;&amp; !predicate(v)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"set"</span> + name + <span class="string">": invalid value"</span> + v);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      value = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// addPrivatePropetry()方法</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;; <span class="comment">// 设置一个空对象</span></span><br><span class="line"><span class="comment">// 增加属性存取器方法getName()和setName()</span></span><br><span class="line"><span class="comment">// 确保只允许字符串值</span></span><br><span class="line">addPrivatePropetry(o, <span class="string">"Name"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">typeof</span> x == <span class="string">"string"</span>; &#125;);</span><br><span class="line"></span><br><span class="line">o.setName(<span class="string">"Frank"</span>); <span class="comment">// 设置属性值</span></span><br><span class="line"><span class="built_in">console</span>.log(o.getName()); <span class="comment">// 得到属性值</span></span><br><span class="line">o.setName(o); <span class="comment">// 设置一个错误类型的值</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在同一个作用域中定义两个闭包，这两个闭包共享同样的私有变量或变量。这是很重要的一种方式，但要小心那些不希望共享的变量旺旺不经意间共享给了其他的闭包，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数返回一个总是返回v的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constfunc</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> v &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个数组用来存储常数函数</span></span><br><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  funcs[i] = constfunc(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第五个位置的元素所表示的函数值返回5</span></span><br><span class="line">funcs[<span class="number">5</span>]() <span class="comment">// =&gt; 5</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这段代码利用循环创建了很多歌闭包，当写类似这种代码的时候往往会犯一个错误：那就是师徒将循环代码移入定义这个闭包的函数之内，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个函数组成的数组，它们的返回值是0~9</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constfunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> funcs = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> i; &#125;; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> funcs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funcs = constfunc();</span><br><span class="line">funcs[<span class="number">5</span>]() <span class="comment">// ??</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面这段代码创建了10个闭包，并将它们存储到一个数组中。这些闭包都是在同一个函数调用中定义的，因此它们可以共享变量i。当<code>constfunc()</code>返回时，变量i的值是10，所有的闭包都共享这一个值，因此，数组中的函数的返回值都是同一个值，这不是想要的结果。关联到闭包的作用域链都是“活动的”。嵌套的函数不会将作用域链内的私有成员复制一份，也不会对所绑定的变量生成静态快照。<br>&emsp;&emsp;<code>this</code>是JavaScript的关键字，而不是变量。每个函数调用都包含一个<code>this</code>值， 如果闭包在外部函数里是无法访问<code>this</code>的，除非外部函数将<code>this</code>转为一个变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> self = <span class="keyword">this</span>; <span class="comment">// 将this保存至一个变量中，以便嵌套的函数能够访问它</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;绑定<code>arguments</code>的问题与之类似。<code>arguments</code>并不是一个关键字，但是在调用每个函数时都会自动声明它，由于闭包具有自己所绑定的<code>arguments</code>，因此闭包内无法直接访问外部函数的参数数组，除非外部函数将参数数组保存到另外一个变量中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outerArguments = <span class="built_in">arguments</span>; <span class="comment">// 保存起来以便嵌套的函数能使用它</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/01/%E9%97%AD%E5%8C%85/" data-id="ck8gp7rzk000okb9hg86ke2c6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ECMAScript5中的数组方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/30/ECMAScript5%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/" class="article-date">
  <time datetime="2019-03-30T01:21:08.000Z" itemprop="datePublished">2019-03-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/30/ECMAScript5%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/">JavaScript数组方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&#160; &#160; &#160; &#160;ECMAScript5定义了9个心得数组方法来遍历、映射、过滤、检测、简化和搜索数组。大多数方法的第一个参数接收一个函数，并且对数组的每个元素（或一些元素）调用一次该函数。如果是稀疏数组，对不存在的元素不调用传递的函数。在大多数情况下，调用提供的函数使用三个参数：数组元素、元素的索引和数组本身。通常，只需要第一个参数值，客户忽略后两个参数。大多数ECMAScript5数组方法的第一个参数是一个函数，第二个参数是可以选的。如果有第三个参数，则调用的函数被看做是第二个参数的方法。也就是说，在调用函数时传递进去的第二个参数作为它的this关键字的值来使用。被调用的函数的返回值非常重要，但是不同的方法处理返回值的方式也不一样。ECMAScript5中的数组方法都不会修改他们调用的原是数组。当然，传递给这些方法的函数是可以修改这些数组的。</p>
<h5 id="1-forEach"><a href="#1-forEach" class="headerlink" title="1. forEach()"></a>1. forEach()</h5><p>&#160; &#160; &#160; &#160;<code>forEach()</code>方法从头至尾遍历数组，为每个元素调用指定的函数。传递的函数作为<code>forEach()</code> 的第一个参数。然后<code>forEach()</code>使用三个参数调用该函数：数组元素、元素的索引和元素本身。如果只关心数组元素的值，可以编写只有一个参数的函数——额外的参数将忽略：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; <span class="comment">// 要求和的数组</span></span><br><span class="line"><span class="comment">// 计算数组元素的和值</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>; <span class="comment">// 初始值为0</span></span><br><span class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="comment">// 将每个值累加到sum上</span></span><br><span class="line">  sum += value;</span><br><span class="line">&#125;);</span><br><span class="line">sum;  <span class="comment">// 15</span></span><br><span class="line"><span class="comment">// 每个数组元素的值自加1</span></span><br><span class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v, i, a</span>) </span>&#123;</span><br><span class="line">  a[i] = v + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line">data; <span class="comment">// =&gt; [2,3,4,5,6]</span></span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;<code>forEach()</code> 方法无法再所有元素都传递给调用的函数之前终止遍历。也就是说，没有像for循环中使用的响应的break语句。如果要提前终止，必须把<code>forEach()</code>方法放在一个try块中，并能抛出一个异常。如果<code>forEach()</code> 方法调用的函数抛出<code>forEach.break</code>异常，循环会提前终止：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foreach</span>(<span class="params">a, f, t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    a.forEach(f, t);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e === foreach.break) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foreach.break = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"StopIteration"</span>);</span><br></pre></td></tr></table></figure>

<h5 id="2-map"><a href="#2-map" class="headerlink" title="2. map()"></a>2. map()</h5><p>&#160; &#160; &#160; &#160;<code>map()</code>方法将调用的数组的每个元素传递给指定的函数，并返回一个数组，它包含该函数的返回值。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">b = a.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;); <span class="comment">//b是[1, 4, 9]</span></span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;传递给<code>map()</code>的函数的调用方式和传递给<code>forEach()</code>的函数的调用方式一样。但传递给<code>map()</code>的函数应该有返回值。注意，<code>map()</code>返回的是新数组：它不修改调用的数组。如果是稀疏数组，返回的也是相同方式的稀疏数组：它具有相同的长度，相同的缺失元素。</p>
<h5 id="3-filter"><a href="#3-filter" class="headerlink" title="3. filter()"></a>3. filter()</h5><p>&#160; &#160; &#160; &#160;<code>filter()</code>方法返回的数组元素是调用的数组的一个子集。传递的函数是用来逻辑判定的：该函数返回<code>true</code>或<code>false</code>。调用判定函数就像调用<code>forEach()</code>和<code>map()</code>一样。如果返回值为<code>true</code>或者<code>false</code>，那么传递给判定函数的就是这个子集的成员，它将被添加到一个座位返回值的数组中。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">smallvalue = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &lt; <span class="number">3</span>;</span><br><span class="line">&#125;); <span class="comment">// [2 ,1]</span></span><br><span class="line">everyoher = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;); <span class="comment">// [5, 3, 1]</span></span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;<code>filter()</code>会跳过稀疏数组中缺少的元素，它的返回数组总是稠密的。为了压缩稀疏数组的空缺，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var dense &#x3D; sparse.filter(function () &#123; return true; &#125;);</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;甚至，压缩空缺并删除<code>undefined</code>和<code>null</code>元素，可以这样使用<code>filter()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; a.filter(function (x) &#123; return x !&#x3D; undefined &amp;&amp; x !&#x3D; null; &#125;);</span><br></pre></td></tr></table></figure>

<h5 id="4-every-和some"><a href="#4-every-和some" class="headerlink" title="4. every()和some()"></a>4. every()和some()</h5><p>&#160; &#160; &#160; &#160;<code>every()</code>和<code>some()</code>方法是数组的逻辑判定：它们对数组元素应用指定的函数进行判定，返回<code>true</code>或<code>false</code>。<br><code>every()</code>方法就像数学中的”针对所有”的量词∀：当且仅当数组中的所有元素调用判定函数都返回true，它才返回true：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">a.every(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x &lt; <span class="number">10</span>; &#125;); <span class="comment">// =&gt; true:所有的值&lt;10</span></span><br><span class="line">a.every(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span>; &#125;); <span class="comment">// =&gt; false: 不是所有的值都是偶数</span></span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;<code>some()</code>方法就像数学的”存在”量词∃：当数组中至少有一个元素调用判定函数返回true，它就返回true；并且当且仅当数值中的所有元素调用判定函数都返回false，它才返回false：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">a.some(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x %<span class="number">2</span> === <span class="number">0</span>; &#125;); <span class="comment">// =&gt; true:a包含有偶数</span></span><br><span class="line">a.some(<span class="built_in">isNaN</span>); <span class="comment">// =&gt; false: a不包含非数值元素</span></span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;一旦<code>every()</code>和<code>some()</code>确认该返回什么值他们就会停止遍历数组元素。<code>some()</code>在判定函数第一次返回true后就返回true，但如果判定函数一直返回false，它将会遍历整个数组。<code>every()</code>切好相反：他在判定函数第一次返回false就返回false，但如果判定函数一直返回true，它将会便利整个数组。注意，根据数学上的惯例，在空数组上调用时，<code>every()</code>返回true，<code>some()</code>返回false。</p>
<h5 id="5-reduce-和reduceRight"><a href="#5-reduce-和reduceRight" class="headerlink" title="5. reduce()和reduceRight()"></a>5. reduce()和reduceRight()</h5><p>&#160; &#160; &#160; &#160;<code>reduce()</code>和<code>reduceRight()</code>方法使用指定的函数将数组元素进行组合，生成单个值。这在函数式编程中是常见的操作们也可以称为”注入”和”折叠”：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = a.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>) </span>&#123; <span class="keyword">return</span> x+y &#125;, <span class="number">0</span>); <span class="comment">// =&gt; 数组求和</span></span><br><span class="line"><span class="keyword">var</span> product = a.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>) </span>&#123; <span class="keyword">return</span> x*y &#125;, <span class="number">1</span>); <span class="comment">// =&gt; 数组求积</span></span><br><span class="line"><span class="keyword">var</span> max = a.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>) </span>&#123; <span class="keyword">return</span> (x&gt;y)?x:y; &#125;); <span class="comment">// =&gt; 求最大值</span></span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;<code>reduce()</code>需要两个参数。第一个是执行化简操作的函数。化简函数的任务就是用某种方法把两个值组合或花间为一个值，并返回化简后的值。在上述例子中，函数通过加法、乘法或取最大值的方法组合两个值。第二个（可选）的参数是一个传递给函数的初始值。<br>&#160; &#160; &#160; &#160;<code>reduce()</code>使用的函数与<code>forEach()</code>和<code>map()</code>使用的函数不同。比较熟悉的是，数组元素、元素的索引和数组本身将作为第2~4个参数传递给函数。第一个参数是到目前为止的化简操作累积的结果。第一次调用函数式，第一个参数是一个初始值，它就是传递给<code>reduce()</code>的第二个参数。在接下来的调用中，这个值就是上一次化简函数的返回值。在示例的第一个例子中，第一次调用化简函数时的参数是0和1。将两者相加并返回1。再次调用时的参数是1和2，它返回3。然后它计算3+3=6、6+4=10，最后计算10+5=15。最后的值是15，<code>reduce()</code>返回这个值。<br>&#160; &#160; &#160; &#160;上面第三次调用<code>reduce()</code>时只有一个参数：没有指定初始值。当不指定初始值调用<code>reduce()</code>时，它将使用数组的第一个元素作为其初始值。这意味着第一次调用化简函数就使用了第一个和第二个数组元素作为其第一个和第二个参数。在上面求和和求积的例子里面，可以省略初始值参数。<br>在空数组上，不带初始值参数调用<code>reduce()</code>将导致类型错误异常。如果调用它的时候只有一个值——数组只有一个元素并且没有指定初始值，或者有一个空数组并指定一个初始值——<code>reduce()</code>只是简单地返回那个值而不会调用化简函数。<br>&#160; &#160; &#160; &#160;<code>reduceRight()</code>的工作原理和<code>reduce()</code>一样，不用的是它按照数组索引从高倒地（从右到左）处理数组，而不是从低到高。如果化简操作的优先顺序是从右到左，我们可以把它用在这些地方：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 计算2^(3^4)。乘方操作的优先顺序是从右到左</span></span><br><span class="line"><span class="keyword">var</span> big = a.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">accmulator, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.pow(value, accmulator);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;<code>reduce()</code>和<code>reduceRight()</code>都能接收一个可选参数，它指定了化简函数调用时的<code>this关键字</code>的值。可选的初始值参数仍然需要占一个位置。如果想让化简函数作为一个特殊对象的方法调用，可以想到<code>Function.bind()</code>方法.<br>&#160; &#160; &#160; &#160;上面说的<code>every()</code>和<code>some()</code>方法是一种类型的数组化操作。但是不同的是，它们会尽早终止遍历而不总是访问每一个数组元素。<br>&#160; &#160; &#160; &#160;数学计算不是<code>reduce()</code>和<code>reduceRight()</code>的唯一用途。比如，我们可以用它写一个<code>union()</code>函数：它计算两个对象的”并集”，并返回另一个新对象，新对象具有二者的属性。该函数期待两个对象并返回另一个对象，所以它的工作原理和一个化简函数一样，并且可以使用<code>reduce()</code>来把它一般化，计算任意数目的对象的”并集”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objects = [&#123; <span class="attr">x</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">y</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">z</span>: <span class="number">3</span> &#125;];</span><br><span class="line"><span class="keyword">var</span> merged = objects.reduce(union); <span class="comment">// =&gt; &#123;x:1,y:2,z:3&#125;</span></span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;当两个对象拥有同名的属性时，<code>union()</code>函数使用第一个参数的属性值。这样，<code>reduce()</code>和<code>reduceRight()</code>在使用<code>union()</code>时会给出不同的结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objects = [&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">z</span>: <span class="number">3</span>, <span class="attr">a</span>: <span class="number">3</span> &#125;];</span><br><span class="line"><span class="keyword">var</span> leftunion = objects.reduce(union); <span class="comment">// =&gt; &#123;x:1, y:2, z:3, a:1&#125;</span></span><br><span class="line"><span class="keyword">var</span> rightunion = objects.reduceRight(union); <span class="comment">// =&gt; &#123;x:1, y:2, z:3, a:3&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="6-indexOf-和lastIndexOf"><a href="#6-indexOf-和lastIndexOf" class="headerlink" title="6.indexOf()和lastIndexOf()"></a>6.indexOf()和lastIndexOf()</h5><p>&#160; &#160; &#160; &#160;<code>indexOf()</code>和<code>lastIndexOf()</code>搜索整个数组中具有给定值的元素，返回找到的第一个元素的索引或者如果没有找到就返回-1。<code>indexOf()</code>从头至尾搜索，而<code>lastIndexOf()</code>则反向搜索。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">0</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>];</span><br><span class="line">a.indexOf(<span class="number">1</span>); <span class="comment">// =&gt; 1:a[1]是1</span></span><br><span class="line">a.lastIndexOf(<span class="number">1</span>); <span class="comment">// =&gt; 3:a[3]是1</span></span><br><span class="line">a.indexOf(<span class="number">3</span>); <span class="comment">// =&gt; -1:没有值为3的元素</span></span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;不同于其他方法，<code>indexOf()</code>和<code>lastIndexOf()</code>方法不接受一个函数作为其参数。第一个参数是需要搜索的值，第二个参数是可选的：它指定数组中的一个索引，从那里开始搜索，如果省略该参数，<code>indexOf()</code>从头开始搜索，而<code>lastIndexOf()</code>从末尾开始搜索。第二个参数也可以是负数，它代表对数组末尾的偏移量，对于<code>splice()</code>方法：例如，-1指定数组的最后一个元素。<br>如下函数在一个数组中搜索指定的值并返回包含所有匹配的数组索引的一个数组。它展示了如何运用<code>indexOf()</code>的第二个参数来查找除了第一个意外匹配的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在数组中查找所有出现的x，并返回一个包含匹配索引的数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findall</span>(<span class="params">a, x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> results = [], <span class="comment">// 将会返回的数组</span></span><br><span class="line">    len = a.length, <span class="comment">// 待搜索数组的长度</span></span><br><span class="line">    pos = <span class="number">0</span>; <span class="comment">// 开始搜索的位置</span></span><br><span class="line">  <span class="keyword">while</span> (pos &lt; len) &#123;</span><br><span class="line">    <span class="comment">// 循环搜索多个元素...</span></span><br><span class="line">    pos = a.indexOf(x, pos); <span class="comment">// 搜索</span></span><br><span class="line">    <span class="keyword">if</span> (pos === <span class="number">-1</span>) &#123; <span class="comment">// 未找到，就完成搜索</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    results.push(pos); <span class="comment">// 否则，在数组中存储索引</span></span><br><span class="line">    pos = pos + <span class="number">1</span>; <span class="comment">// 并从下一个位置开始搜索</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results; <span class="comment">// 返回包含索引的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;字符串也有<code>indexOf()</code>和<code>lastIndexOf()</code>方法，它们和数组方法的功能类似。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/30/ECMAScript5%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/" data-id="ck8gp7rxu0005kb9ha4dm5jot" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript数组方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/23/JavaScript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/" class="article-date">
  <time datetime="2019-03-23T01:21:08.000Z" itemprop="datePublished">2019-03-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/23/JavaScript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/">JavaScript数组方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><p>&#160; &#160; &#160; &#160;ECMAScript在Array.prototype中定义了一些很有用的操作数组的函数，这意味着这些函数作为任何数组的方法都是可用的。</p>
<h5 id="1-join"><a href="#1-join" class="headerlink" title="1. join()"></a>1. join()</h5><p><code>Array.join()</code>方法将数组中所有元素都专户为字符串并连接在一起，返回最后生成的字符串。可以指定一个可选的字符串在生在的字符串中来分隔数组的各个元素。如果不指定分隔符，默认使用逗号。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1, 2, 3];     &#x2F;&#x2F; 创建一个包含三个元素的数组</span><br><span class="line">a.join();              &#x2F;&#x2F; &#x3D;&gt; &quot;1,2,3&quot;</span><br><span class="line">a.join(&quot; &quot;);           &#x2F;&#x2F; &#x3D;&gt; &quot;1 2 3&quot;</span><br><span class="line">a.join(&quot;&quot;);            &#x2F;&#x2F; &#x3D;&gt; &quot;123&quot;</span><br></pre></td></tr></table></figure>
<p><code>Array.join()</code> 方法是String.split()方法的逆向操作，后者是将字符串分割成若干块来创建一个数组。</p>
<h5 id="2-reverse"><a href="#2-reverse" class="headerlink" title="2. reverse()"></a>2. reverse()</h5><p><code>Array.reverse()</code>方法将数组中的元素颠倒顺序，返回逆向的数组。它采取了替换；换句话说，它不通过重新排列的元素创建新的数组，而是在原先的数组中重新排列他们。例如，下面的代码使用<code>reverse()</code>和<code>join()</code>方法生成字符串“3，2，1”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1,2,3];</span><br><span class="line">a.reverse().join();   &#x2F;&#x2F; &#x3D;&gt; &quot;3,2,1&quot;,并且现在的a是[3,2,1]</span><br></pre></td></tr></table></figure>

<h5 id="3-sort"><a href="#3-sort" class="headerlink" title="3. sort()"></a>3. sort()</h5><p><code>Array.sort()</code>方法将数组中的元素排序并返回排序后的数组。当不带参数调用<code>sort()</code>时，数组元素以字母表顺序排列（如有必要将临时转化为字符串进行比较）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; new Array(&quot;banana&quot;, &quot;cherry&quot;, &quot;apple&quot;);</span><br><span class="line">a.sort();</span><br><span class="line">var s &#x3D; a.join(&quot;， ”)；  &#x2F;&#x2F;  s &#x3D; &quot;apple, banana, cherry&quot;</span><br></pre></td></tr></table></figure>
<p>如果参数包含undefined元素，它们会被排到数组的尾部。<br>为了按照其他方式而非字母表顺序进行排序，必须给<code>sort()</code>方法传递一个比较函数。该函数决定了它的两个参数在排好序的数组中的先后顺序。假设第一个参数应该在前，比较函数应该返回一个小鱼0的数值。反之，假设第一个参数应该在后，函数应该返回一个大于0的数值。并且，假设两个值相等（也就是说，他们的顺序无关紧要），函数应该返回0。因此，例如，用数值大小而非字母表顺序进行数组排序，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [33, 4, 1111, 222];</span><br><span class="line">a.sort();                &#x2F;&#x2F; 字母表顺序: 1111, 222, 33, 4</span><br><span class="line">a.sort(function (a, b) &#123; &#x2F;&#x2F; 数值顺序: 4, 33, 222, 1111</span><br><span class="line">  return a - b;          &#x2F;&#x2F; 根据顺序，返回负数、0、正数</span><br><span class="line">&#125;)</span><br><span class="line">a.sort(function (a, b) &#123; &#x2F;&#x2F; 数值大小相反顺序</span><br><span class="line">  return b - a;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>另外一个数组元素排序的例子，也许需要对一个字符串数组执行不区分大小写的字母表排序，比较函数首先将参数都转化为小写字符串（使用<code>toLowerCase()</code>方法），再开始比较：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; [&#39;ant&#39;, &#39;Bug&#39;, &#39;cat&#39;, &#39;Dog&#39;]</span><br><span class="line">a.sort();                &#x2F;&#x2F; 区分大小写的排序: [&#39;Bug&#39;,&#39;Dog&#39;,&#39;ant&#39;,&#39;cat&#39;]</span><br><span class="line">a.sort(function (s, t) &#123; &#x2F;&#x2F; 不区分大小写的排序</span><br><span class="line">  var a &#x3D; s.toLowerCase();</span><br><span class="line">  var b &#x3D; t.toLowerCase();</span><br><span class="line">  if (a &lt; b) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  if (a &gt; b) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;);                     &#x2F;&#x2F; &#x3D;&gt; [&#39;ant&#39;,&#39;Bug&#39;,&#39;cat&#39;,&#39;Dog&#39;]</span><br></pre></td></tr></table></figure>

<h5 id="4-concat"><a href="#4-concat" class="headerlink" title="4. concat()"></a>4. concat()</h5><p><code>Array.concat()</code>方法创建并返回一个新数组，它的元素包括调用<code>concat()</code>的元时数组的元素和<code>concat()</code>的每个参数。如果这些参数中的任何一个自身是数组，则连接的是数组的元素，而非数组本身。但要注意，<code>concat()</code>不会递归扁平化数组的数组。<code>concat()</code>也不会修改调用的数组。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1, 2, 3];</span><br><span class="line">a.concat(4, 5);        &#x2F;&#x2F; 返回[1, 2, 3, 4, 5]</span><br><span class="line">a.concat([4, 5]);       &#x2F;&#x2F; 返回[1, 2, 3, 4, 5]</span><br><span class="line">a.concat([4, 5], [6, 7]); &#x2F;&#x2F; 返回[1, 2, 3, 4, 5, 6, 7]</span><br><span class="line">a.concat(4, [5, [6, 7]]); &#x2F;&#x2F; 返回[1, 2, 3, 4, 5, [6, 7]]</span><br></pre></td></tr></table></figure>

<h5 id="5-slice"><a href="#5-slice" class="headerlink" title="5. slice()"></a>5. slice()</h5><p><code>Array.slice()</code>方法返回指定数组的一个片段或子数组。它的两个参数分别指定了片段的开始和结束的位置。返回的数组包含第一个参数指定的位置和所有到但不包含第二参数指定的位置的所有数组元素。如果只指定一个参数，返回的数组将包含从开始位置到数组结尾的所有元素。如果参数中出现了负数，它表示相对数组中最后一个元素的位置。例如，参数-1指定了最后一个元素，而-3指定了倒数第三个元素。但是<code>slice()</code>不会修改调用的数组。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">a.slice(0, 3);   &#x2F;&#x2F; 返回[1, 2, 3]</span><br><span class="line">a.slice(3);      &#x2F;&#x2F; 返回[4, 5]</span><br><span class="line">a.slice(1, -1);  &#x2F;&#x2F; 返回[2, 3, 4]</span><br><span class="line">a.slice(-3, -2); &#x2F;&#x2F; 返回[3]</span><br></pre></td></tr></table></figure>

<h5 id="6-splice"><a href="#6-splice" class="headerlink" title="6.splice()"></a>6.splice()</h5><p><code>Array.splice()</code>方法是在数组中插入或删除元素的通用方法。不同于<code>slice()</code>和<code>concat()</code>，<code>splice()</code>会修改调用的数组。但是，<code>splice()</code>和<code>slice()</code>拥有非常相似的名字，但它们的功能却有本质的区别。<br><code>splice()</code>能够从数组中删除元素、插入元素到数组中或者同时完成这两种操作。在插入或删除点之后的数组元素会根据需要增加或减小它们的索引值，因此数组的其他部分仍然保持连续的。<code>splice()</code>的第一个参数指定了插入和（或）删除的起始位置。第二个参数指定了应该从数组中删除的元素个数。如果省略第二个参数，从起始点开始到数组结尾的所有元素都将被删除。<code>splice()</code>返回一个由删除元素组成的数组，或者如果没有删除元素就返回一个空数组。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1, 2, 3, 4, 5, 6, 7, 8];</span><br><span class="line">a.splice(4);    &#x2F;&#x2F; 返回[5, 6, 7, 8];a是[1,2,3,4]</span><br><span class="line">a.splice(1, 2); &#x2F;&#x2F; 返回[2, 3];a是[1,4]</span><br><span class="line">a.splice(1, 1); &#x2F;&#x2F; 返回[4];a是[1]</span><br></pre></td></tr></table></figure>
<p><code>splice()</code>的前两个参数指定了需要删除的数组元素。紧随其后的任意个数的参数指定了需要插入到数组中的元素，从第一个参数指定的位置开始插入。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">a.splice(2, 0, &#39;a&#39;, &#39;b&#39;);  &#x2F;&#x2F; 返回[],a是[1, 2, &quot;a&quot;, &quot;b&quot;, 3, 4, 5]</span><br><span class="line">a.splice(2, 2, [1, 2], 3); &#x2F;&#x2F; 返回[&quot;a&quot;, &quot;b&quot;],a是[1, 2, [1, 2], 3, 3, 4, 5]</span><br></pre></td></tr></table></figure>
<p>区别于<code>concat()</code>，<code>splice()</code>会插入数组本身而非数组的元素。</p>
<h5 id="7-push-和pop"><a href="#7-push-和pop" class="headerlink" title="7. push()和pop()"></a>7. push()和pop()</h5><p><code>push()</code>和<code>pop()</code>方法允许将数组当做栈来调用。<code>push()</code> 方法在数组的尾部添加一个或多个元素，并返回数组新的长度。<code>pop()</code> 方法则相反：它删除数组的最后一个元素，减小数组长度并返回它删除的值。两个方法都修改并替换原始数组而非生成一个修改版的新数组。组合使用<code>push()</code> 和<code>pop()</code> 能够用JavaScript数组实现现金后出的栈。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var stack &#x3D; [];     &#x2F;&#x2F; stack: []</span><br><span class="line">stack.push(1, 2);   &#x2F;&#x2F; stack: [1, 2]</span><br><span class="line">stack.pop();        &#x2F;&#x2F; stack: [1]</span><br><span class="line">stack.push(3);      &#x2F;&#x2F; stack: [1, 3]</span><br><span class="line">stack.pop();        &#x2F;&#x2F; stack: [1]</span><br><span class="line">stack.push([4, 5]); &#x2F;&#x2F; stack: [1, [4, 5]]</span><br><span class="line">stack.pop();        &#x2F;&#x2F; stack: [1]</span><br><span class="line">stack.pop();        &#x2F;&#x2F; stack: []</span><br></pre></td></tr></table></figure>

<h5 id="8-unshift-和shift"><a href="#8-unshift-和shift" class="headerlink" title="8. unshift()和shift()"></a>8. unshift()和shift()</h5><p><code>unshift()</code>和<code>shift()</code>方法的行为非常类似于<code>push()</code> 和<code>pop()</code>，不一样的是前者是在数组的头部而非尾部进行元素的插入和删除操作。 <code>unshift()</code> 在数组的头部添加一个或多个元素，并将已存在的元素移动到更高索引的位置来获得足够的空间，最后返回数组新的长度。<code>shift()</code>删除数组的第一个元素并将其返回，然后把所有随后的元素下移一个位置来填补数组头部的空缺。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [];            &#x2F;&#x2F; a:[]</span><br><span class="line">a.unshift(1);          &#x2F;&#x2F; a:[1] 返回:1</span><br><span class="line">a.unshift(22);         &#x2F;&#x2F; a:[22, 1] 返回:2</span><br><span class="line">a.shift();             &#x2F;&#x2F; a:[1] 返回:22</span><br><span class="line">a.unshift(3, [4, 5]);  &#x2F;&#x2F; a:[3, [4, 5], 1] 返回:3</span><br><span class="line">a.shift();             &#x2F;&#x2F; a:[[4, 5], 1] 返回:3</span><br><span class="line">a.shift();             &#x2F;&#x2F; a:[1] 返回:[4, 5]</span><br><span class="line">a.shift();             &#x2F;&#x2F; a:[] 返回:1</span><br></pre></td></tr></table></figure>
<p>当使用多个参数调用 <code>unshift()</code>时它的行为很奇怪。参数是一次性插入的（就像<code>splice()</code>方法）而非一次一个地插入。这意味着最终的数组中插入的元素的顺序和它们在参数列表中的顺序一致。而假如元素是一次一个地插入，它们的顺序应该是反过来的。</p>
<h5 id="8-toString-和toLocaleString"><a href="#8-toString-和toLocaleString" class="headerlink" title="8. toString()和toLocaleString()"></a>8. toString()和toLocaleString()</h5><p>数组和其他JavaScript对象一样拥有<code>toString()</code>方法。针对数组，该方法将其每个元素转化为字符串（如有必要将调用元素的<code>toString()</code>方法）并且输出用逗号分隔的字符串列表。但是要注意输出不包括方括号或其他任何形式的包裹数组值的分隔符。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].toString();       &#x2F;&#x2F; 生成&quot;1,2,3&quot;</span><br><span class="line">[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].toString(); &#x2F;&#x2F; 生成&quot;a,b,c&quot;</span><br><span class="line">[1, [2, &#39;c&#39;]].toString();   &#x2F;&#x2F; 生成&quot;1,2,c&quot;</span><br></pre></td></tr></table></figure>
<p>这里于不适用任何参调用<code>join()</code>方法返回的字符串是一样的。<br><code>toLocaleString()</code>是<code>toString()</code>方法的本地化版本。它调用元素的<code>toLocaleString()</code>方法将每个数组元素转化为字符串，并且使用本地化（和自定义实现的）分隔符将这些字符串连接起来生成最终的字符串。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/23/JavaScript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/" data-id="ck8gp7rxw0007kb9h8g2t7vb2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS中的严格模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/18/JS%E4%B8%AD%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2019-03-18T06:21:08.000Z" itemprop="datePublished">2019-03-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/18/JS%E4%B8%AD%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/">JS中的严格模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="“use-strict”"><a href="#“use-strict”" class="headerlink" title="“use strict”"></a>“use strict”</h2><p>&#160; &#160; &#160; &#160;<code>&quot;use strict&quot;</code>是<code>ECMAScript</code>引入的一条指令。指令不是语句（但非常接近于语句）。</p>
<h5 id="1-与普通语句的区别"><a href="#1-与普通语句的区别" class="headerlink" title="1. 与普通语句的区别"></a>1. 与普通语句的区别</h5><p>&#160; &#160; &#160; &#160;<code>&quot;use strict&quot;</code>指令和普通的语句之间有两个重要的<code>区别</code>：</p>
<ul>
<li>它不包含任何语言的<code>关键字</code>，指令仅仅是一个包含一个特殊字符串直接量的表达式（可以是使用单引号也可以使用双引号），对于那些没有实现<code>ECMAScript5</code>的JavaScript的解释器来说，它只是一条没有副作用的表达式语句，它什么也没做。将来的ECMAScript标准希望将use用做关键字，这样就可以省略引号了。</li>
<li>它只能出现在脚本代码的开始或者函数体的开始，任何实体语句之前。但它不必一定出现在脚本的首行或函数体内的首行，因为<code>&quot;use strict&quot;</code>指令之后或之前都可以能有其它字符串直接量表达式语句，并且JavaScript的具体实现可能将它们解析为解释器自有的指令。在脚本或者函数体内第一条常规语句之后字符串直接量表达式语句只当做普通的表达式语句对待；它们不会当做指令解析，它们也没有任何副作用。</li>
</ul>
<h5 id="2-指令的目的"><a href="#2-指令的目的" class="headerlink" title="2. 指令的目的"></a>2. 指令的目的</h5><p>&#160; &#160; &#160; &#160;使用<code>&quot;use strict&quot;</code>指令的目的是说明（脚本或函数中）后续的代码将会解析为严格代码<code>(strict code)</code>.如果顶层（不在任何函数内的）代码使用了<code>&quot;use strict&quot;</code>指令，那么它们就是严格代码。如果函数体内定义所处的代码是严格代码或者函数体使用了<code>&quot;use strict&quot;</code>指令，那么函数体的代码也是严格代码。如果<code>eval()</code>调用时所处的代码是严格代码或者<code>eval()</code>要执行的字符串中使用了<code>&quot;use strict&quot;</code>指令，则<code>eval()</code>内的代码是严格代码。</p>
<h5 id="3-与非严格模式的区别"><a href="#3-与非严格模式的区别" class="headerlink" title="3. 与非严格模式的区别"></a>3. 与非严格模式的区别</h5><p>&#160; &#160; &#160; &#160;严格代码以严格模式执行。<code>ECMAScript5</code>中的严格模式是该语言的一个受限制的子集，它修正了语言的重要缺陷，并提供健壮的查错功能和增强的安全机制。严格模式和非严格模式之间的区别如下（前三条十分重要）。</p>
<ul>
<li>在严格模式中禁止使用<code>with</code>语句。</li>
<li>在严格模式中，<code>所有的变量</code>都要首先声明，如果给一个未声明的变量、函数、函数参数、catch从句参数或全局对象的属性赋值，将会抛出一个引用错误异常（在非严格模式中，这种隐式声明的全局变量的方法是给全局对象新添加一个新属性）。</li>
<li>在严格模式中，调用的函数（不是方法）中的一个<code>this</code>值是<code>undefined</code>。（在非严格模式中，调用的函数中的this值总是全局对象）。可以利用这种特殊来判断JavaScript实现是否支持严格模式。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var hasStrictMode &#x3D; (function()&#123; &quot;use strict&quot;; return this&#x3D;&#x3D;&#x3D;undefined&#125;());</span><br></pre></td></tr></table></figure></li>
<li>同样，在严格模式中，当通过<code>call()</code>或者<code>apply()</code>来调用函数时，其中的this值就是通过<code>call()</code>或者<code>apply()</code>传入的第一个参数（在非严格模式中，null和undefined值被全局对象和转换为对象的非对象值所代替）。</li>
<li>在严格模式中，给只读属性赋值和给不可扩展的对象穿件新成员都将抛出一个类型错误异常（在非严格模式中，这些操作知识简单地操作失败，不会报错）。</li>
<li>在严格模式中，传入<code>eval()</code>的代码不能再调用程序所在的上下文中声明变量或定义函数，而在费严格模式中是可以这样做得。相反，变量和函数的定义都是在<code>eval()</code>创建的新作用域中，这个作用域在<code>eval()</code>返回时就弃用了。</li>
<li>在严格模式中，函数里的<code>arguments</code>对象拥有传入函数值的静态副本。在非严格模式中，<code>arguments</code>对象具有<code>“魔术般”</code>的行为，<code>arguments</code>里的数组元素和函数参数都是指向同一个值的引用。</li>
<li>在严格模式中，当<code>delete</code>运算符后跟随非法的标识符（比如变量、函数、函数参数）时，将会抛出一个语法错误异常（在非严格模式中，这种<code>delete</code>表达式什么也没做，并返回false）。</li>
<li>在严格模式中，试图删除一个不可配置的属性将会抛出一个类型错误异常（在非严格模式中，<code>delete</code>表达式操作失败，并返回false）。</li>
<li>在严格模式中，在一个对象直接量中定义两个或多个同名属性将产生一个语法错误（在非严格模式中不会报错）。</li>
<li>在严格模式中，函数声明中个存在两个或多个同名的参数将产生一个语法错误（在非严格模式中不会报错）。</li>
<li>在严格模式中是不允许使用八进制整数直接量（以0为前缀，而不是以0x为前缀）的（在非严格模式中某些实现是允许八进制整数直接量的）。</li>
<li>在严格模式中，标识符<code>eval</code>和<code>arguments</code>当做关键字，他们的值是不能更改的。不能给这些标识符赋值，也不能把它们声明为变量、用做函数名、用做函数参数或用做<code>catch</code>块的标识符。</li>
<li>在严格模式中限制了对调用栈的检测能力，在严格模式的函数中，<code>arguments</code>、<code>caller</code>和<code>argument.callee</code>都会抛出一个类型错误异常。严格模式的函数同样据用<code>caller</code>和<code>arguments</code>属性，当访问这两个属性时将抛出类型错误异常（有一些JavaScript的实现在非严格模式里定义了这些非标准的属性）。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/18/JS%E4%B8%AD%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/" data-id="ck8gp7rxs0003kb9hetw8dkcd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ajax/">ajax</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/fetch/">fetch</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/gulp/">gulp</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/node/">node</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/">webpack</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/05/18/%E3%80%8AJust-JavaScript%E3%80%8B05.-%E8%AE%A1%E7%AE%97%E6%95%B0%E5%80%BC2/">《Just JavaScript》05. 计算数值2</a>
          </li>
        
          <li>
            <a href="/2020/04/15/%E3%80%8AJust-JavaScript%E3%80%8B04-%E8%AE%A1%E7%AE%97%E6%95%B0%E5%80%BC/">《Just JavaScript》04. 计算数值</a>
          </li>
        
          <li>
            <a href="/2020/04/01/%E3%80%8AJust-JavaScript%E3%80%8B02-JavaScript%E5%AE%87%E5%AE%99/">《Just JavaScript》02.JavaScript宇宙</a>
          </li>
        
          <li>
            <a href="/2020/03/31/%E3%80%8AJust-JavaScript%E3%80%8B01-%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B/">《Just JavaScript》01.思维模型</a>
          </li>
        
          <li>
            <a href="/2020/03/31/%E3%80%8AJust-JavaScript%E3%80%8B03-%E5%80%BC%E5%92%8C%E5%8F%98%E9%87%8F/">《Just JavaScript》03. 值和变量</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 zxl<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>