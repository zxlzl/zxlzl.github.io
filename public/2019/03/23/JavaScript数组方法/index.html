<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <link rel="shortcut icon" href="/favicon.svg"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
  <title>JavaScript数组方法 [ Lemon Ray ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/iLiKE.css">
    
  
  
  
  <script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
    <script id="leancloud">
      AV.init({
          appId: "6E5zTbTljdUbVW2WkXPsXGJk-gzGzoHsz",
          appKey: "0vsyDKfNpeSECAI70J794ugv"
      });
    </script>

<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Lemon Ray" type="application/atom+xml">
</head>
<body>
    <div class="header">
        <div class="container">
    <div class="menu">
      <div class="menu-left">
        <a href="/">
          <img src="/favicon.svg"></img>
        </a>
      </div>
      <div class="menu-right">
        
          
          
          
          
          
          
          <a href="/">首页</a>
        
          
          
          
          
          
          
          <a href="/archives">归档</a>
        
      </div>
    </div>
</div>
    </div>
    <div class="container">
        <h1 class="post-title">JavaScript数组方法</h1>
<article class="post markdown-style">
  <h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><p>&#160; &#160; &#160; &#160;ECMAScript在Array.prototype中定义了一些很有用的操作数组的函数，这意味着这些函数作为任何数组的方法都是可用的。</p>
<h5 id="1-join"><a href="#1-join" class="headerlink" title="1. join()"></a>1. join()</h5><p><code>Array.join()</code>方法将数组中所有元素都专户为字符串并连接在一起，返回最后生成的字符串。可以指定一个可选的字符串在生在的字符串中来分隔数组的各个元素。如果不指定分隔符，默认使用逗号。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1, 2, 3];     &#x2F;&#x2F; 创建一个包含三个元素的数组</span><br><span class="line">a.join();              &#x2F;&#x2F; &#x3D;&gt; &quot;1,2,3&quot;</span><br><span class="line">a.join(&quot; &quot;);           &#x2F;&#x2F; &#x3D;&gt; &quot;1 2 3&quot;</span><br><span class="line">a.join(&quot;&quot;);            &#x2F;&#x2F; &#x3D;&gt; &quot;123&quot;</span><br></pre></td></tr></table></figure>
<p><code>Array.join()</code> 方法是String.split()方法的逆向操作，后者是将字符串分割成若干块来创建一个数组。</p>
<h5 id="2-reverse"><a href="#2-reverse" class="headerlink" title="2. reverse()"></a>2. reverse()</h5><p><code>Array.reverse()</code>方法将数组中的元素颠倒顺序，返回逆向的数组。它采取了替换；换句话说，它不通过重新排列的元素创建新的数组，而是在原先的数组中重新排列他们。例如，下面的代码使用<code>reverse()</code>和<code>join()</code>方法生成字符串“3，2，1”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1,2,3];</span><br><span class="line">a.reverse().join();   &#x2F;&#x2F; &#x3D;&gt; &quot;3,2,1&quot;,并且现在的a是[3,2,1]</span><br></pre></td></tr></table></figure>

<h5 id="3-sort"><a href="#3-sort" class="headerlink" title="3. sort()"></a>3. sort()</h5><p><code>Array.sort()</code>方法将数组中的元素排序并返回排序后的数组。当不带参数调用<code>sort()</code>时，数组元素以字母表顺序排列（如有必要将临时转化为字符串进行比较）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; new Array(&quot;banana&quot;, &quot;cherry&quot;, &quot;apple&quot;);</span><br><span class="line">a.sort();</span><br><span class="line">var s &#x3D; a.join(&quot;， ”)；  &#x2F;&#x2F;  s &#x3D; &quot;apple, banana, cherry&quot;</span><br></pre></td></tr></table></figure>
<p>如果参数包含undefined元素，它们会被排到数组的尾部。<br>为了按照其他方式而非字母表顺序进行排序，必须给<code>sort()</code>方法传递一个比较函数。该函数决定了它的两个参数在排好序的数组中的先后顺序。假设第一个参数应该在前，比较函数应该返回一个小鱼0的数值。反之，假设第一个参数应该在后，函数应该返回一个大于0的数值。并且，假设两个值相等（也就是说，他们的顺序无关紧要），函数应该返回0。因此，例如，用数值大小而非字母表顺序进行数组排序，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [33, 4, 1111, 222];</span><br><span class="line">a.sort();                &#x2F;&#x2F; 字母表顺序: 1111, 222, 33, 4</span><br><span class="line">a.sort(function (a, b) &#123; &#x2F;&#x2F; 数值顺序: 4, 33, 222, 1111</span><br><span class="line">  return a - b;          &#x2F;&#x2F; 根据顺序，返回负数、0、正数</span><br><span class="line">&#125;)</span><br><span class="line">a.sort(function (a, b) &#123; &#x2F;&#x2F; 数值大小相反顺序</span><br><span class="line">  return b - a;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>另外一个数组元素排序的例子，也许需要对一个字符串数组执行不区分大小写的字母表排序，比较函数首先将参数都转化为小写字符串（使用<code>toLowerCase()</code>方法），再开始比较：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; [&#39;ant&#39;, &#39;Bug&#39;, &#39;cat&#39;, &#39;Dog&#39;]</span><br><span class="line">a.sort();                &#x2F;&#x2F; 区分大小写的排序: [&#39;Bug&#39;,&#39;Dog&#39;,&#39;ant&#39;,&#39;cat&#39;]</span><br><span class="line">a.sort(function (s, t) &#123; &#x2F;&#x2F; 不区分大小写的排序</span><br><span class="line">  var a &#x3D; s.toLowerCase();</span><br><span class="line">  var b &#x3D; t.toLowerCase();</span><br><span class="line">  if (a &lt; b) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  if (a &gt; b) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;);                     &#x2F;&#x2F; &#x3D;&gt; [&#39;ant&#39;,&#39;Bug&#39;,&#39;cat&#39;,&#39;Dog&#39;]</span><br></pre></td></tr></table></figure>

<h5 id="4-concat"><a href="#4-concat" class="headerlink" title="4. concat()"></a>4. concat()</h5><p><code>Array.concat()</code>方法创建并返回一个新数组，它的元素包括调用<code>concat()</code>的元时数组的元素和<code>concat()</code>的每个参数。如果这些参数中的任何一个自身是数组，则连接的是数组的元素，而非数组本身。但要注意，<code>concat()</code>不会递归扁平化数组的数组。<code>concat()</code>也不会修改调用的数组。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1, 2, 3];</span><br><span class="line">a.concat(4, 5);        &#x2F;&#x2F; 返回[1, 2, 3, 4, 5]</span><br><span class="line">a.concat([4, 5]);       &#x2F;&#x2F; 返回[1, 2, 3, 4, 5]</span><br><span class="line">a.concat([4, 5], [6, 7]); &#x2F;&#x2F; 返回[1, 2, 3, 4, 5, 6, 7]</span><br><span class="line">a.concat(4, [5, [6, 7]]); &#x2F;&#x2F; 返回[1, 2, 3, 4, 5, [6, 7]]</span><br></pre></td></tr></table></figure>

<h5 id="5-slice"><a href="#5-slice" class="headerlink" title="5. slice()"></a>5. slice()</h5><p><code>Array.slice()</code>方法返回指定数组的一个片段或子数组。它的两个参数分别指定了片段的开始和结束的位置。返回的数组包含第一个参数指定的位置和所有到但不包含第二参数指定的位置的所有数组元素。如果只指定一个参数，返回的数组将包含从开始位置到数组结尾的所有元素。如果参数中出现了负数，它表示相对数组中最后一个元素的位置。例如，参数-1指定了最后一个元素，而-3指定了倒数第三个元素。但是<code>slice()</code>不会修改调用的数组。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">a.slice(0, 3);   &#x2F;&#x2F; 返回[1, 2, 3]</span><br><span class="line">a.slice(3);      &#x2F;&#x2F; 返回[4, 5]</span><br><span class="line">a.slice(1, -1);  &#x2F;&#x2F; 返回[2, 3, 4]</span><br><span class="line">a.slice(-3, -2); &#x2F;&#x2F; 返回[3]</span><br></pre></td></tr></table></figure>

<h5 id="6-splice"><a href="#6-splice" class="headerlink" title="6.splice()"></a>6.splice()</h5><p><code>Array.splice()</code>方法是在数组中插入或删除元素的通用方法。不同于<code>slice()</code>和<code>concat()</code>，<code>splice()</code>会修改调用的数组。但是，<code>splice()</code>和<code>slice()</code>拥有非常相似的名字，但它们的功能却有本质的区别。<br><code>splice()</code>能够从数组中删除元素、插入元素到数组中或者同时完成这两种操作。在插入或删除点之后的数组元素会根据需要增加或减小它们的索引值，因此数组的其他部分仍然保持连续的。<code>splice()</code>的第一个参数指定了插入和（或）删除的起始位置。第二个参数指定了应该从数组中删除的元素个数。如果省略第二个参数，从起始点开始到数组结尾的所有元素都将被删除。<code>splice()</code>返回一个由删除元素组成的数组，或者如果没有删除元素就返回一个空数组。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1, 2, 3, 4, 5, 6, 7, 8];</span><br><span class="line">a.splice(4);    &#x2F;&#x2F; 返回[5, 6, 7, 8];a是[1,2,3,4]</span><br><span class="line">a.splice(1, 2); &#x2F;&#x2F; 返回[2, 3];a是[1,4]</span><br><span class="line">a.splice(1, 1); &#x2F;&#x2F; 返回[4];a是[1]</span><br></pre></td></tr></table></figure>
<p><code>splice()</code>的前两个参数指定了需要删除的数组元素。紧随其后的任意个数的参数指定了需要插入到数组中的元素，从第一个参数指定的位置开始插入。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">a.splice(2, 0, &#39;a&#39;, &#39;b&#39;);  &#x2F;&#x2F; 返回[],a是[1, 2, &quot;a&quot;, &quot;b&quot;, 3, 4, 5]</span><br><span class="line">a.splice(2, 2, [1, 2], 3); &#x2F;&#x2F; 返回[&quot;a&quot;, &quot;b&quot;],a是[1, 2, [1, 2], 3, 3, 4, 5]</span><br></pre></td></tr></table></figure>
<p>区别于<code>concat()</code>，<code>splice()</code>会插入数组本身而非数组的元素。</p>
<h5 id="7-push-和pop"><a href="#7-push-和pop" class="headerlink" title="7. push()和pop()"></a>7. push()和pop()</h5><p><code>push()</code>和<code>pop()</code>方法允许将数组当做栈来调用。<code>push()</code> 方法在数组的尾部添加一个或多个元素，并返回数组新的长度。<code>pop()</code> 方法则相反：它删除数组的最后一个元素，减小数组长度并返回它删除的值。两个方法都修改并替换原始数组而非生成一个修改版的新数组。组合使用<code>push()</code> 和<code>pop()</code> 能够用JavaScript数组实现现金后出的栈。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var stack &#x3D; [];     &#x2F;&#x2F; stack: []</span><br><span class="line">stack.push(1, 2);   &#x2F;&#x2F; stack: [1, 2]</span><br><span class="line">stack.pop();        &#x2F;&#x2F; stack: [1]</span><br><span class="line">stack.push(3);      &#x2F;&#x2F; stack: [1, 3]</span><br><span class="line">stack.pop();        &#x2F;&#x2F; stack: [1]</span><br><span class="line">stack.push([4, 5]); &#x2F;&#x2F; stack: [1, [4, 5]]</span><br><span class="line">stack.pop();        &#x2F;&#x2F; stack: [1]</span><br><span class="line">stack.pop();        &#x2F;&#x2F; stack: []</span><br></pre></td></tr></table></figure>

<h5 id="8-unshift-和shift"><a href="#8-unshift-和shift" class="headerlink" title="8. unshift()和shift()"></a>8. unshift()和shift()</h5><p><code>unshift()</code>和<code>shift()</code>方法的行为非常类似于<code>push()</code> 和<code>pop()</code>，不一样的是前者是在数组的头部而非尾部进行元素的插入和删除操作。 <code>unshift()</code> 在数组的头部添加一个或多个元素，并将已存在的元素移动到更高索引的位置来获得足够的空间，最后返回数组新的长度。<code>shift()</code>删除数组的第一个元素并将其返回，然后把所有随后的元素下移一个位置来填补数组头部的空缺。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [];            &#x2F;&#x2F; a:[]</span><br><span class="line">a.unshift(1);          &#x2F;&#x2F; a:[1] 返回:1</span><br><span class="line">a.unshift(22);         &#x2F;&#x2F; a:[22, 1] 返回:2</span><br><span class="line">a.shift();             &#x2F;&#x2F; a:[1] 返回:22</span><br><span class="line">a.unshift(3, [4, 5]);  &#x2F;&#x2F; a:[3, [4, 5], 1] 返回:3</span><br><span class="line">a.shift();             &#x2F;&#x2F; a:[[4, 5], 1] 返回:3</span><br><span class="line">a.shift();             &#x2F;&#x2F; a:[1] 返回:[4, 5]</span><br><span class="line">a.shift();             &#x2F;&#x2F; a:[] 返回:1</span><br></pre></td></tr></table></figure>
<p>当使用多个参数调用 <code>unshift()</code>时它的行为很奇怪。参数是一次性插入的（就像<code>splice()</code>方法）而非一次一个地插入。这意味着最终的数组中插入的元素的顺序和它们在参数列表中的顺序一致。而假如元素是一次一个地插入，它们的顺序应该是反过来的。</p>
<h5 id="8-toString-和toLocaleString"><a href="#8-toString-和toLocaleString" class="headerlink" title="8. toString()和toLocaleString()"></a>8. toString()和toLocaleString()</h5><p>数组和其他JavaScript对象一样拥有<code>toString()</code>方法。针对数组，该方法将其每个元素转化为字符串（如有必要将调用元素的<code>toString()</code>方法）并且输出用逗号分隔的字符串列表。但是要注意输出不包括方括号或其他任何形式的包裹数组值的分隔符。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].toString();       &#x2F;&#x2F; 生成&quot;1,2,3&quot;</span><br><span class="line">[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].toString(); &#x2F;&#x2F; 生成&quot;a,b,c&quot;</span><br><span class="line">[1, [2, &#39;c&#39;]].toString();   &#x2F;&#x2F; 生成&quot;1,2,c&quot;</span><br></pre></td></tr></table></figure>
<p>这里于不适用任何参调用<code>join()</code>方法返回的字符串是一样的。<br><code>toLocaleString()</code>是<code>toString()</code>方法的本地化版本。它调用元素的<code>toLocaleString()</code>方法将每个数组元素转化为字符串，并且使用本地化（和自定义实现的）分隔符将这些字符串连接起来生成最终的字符串。</p>

</article>

    <div class="pagenator post-pagenator">
    
    
        <a class="extend prev post-prev" href="/2019/03/30/ECMAScript5%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/">上一篇</a>
    

    
    <p>上次更新 2020-04-01</p>
    
    
        <a class="extend next post-next" href="/2019/03/18/JS%E4%B8%AD%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/">下一篇</a>
    
    </div>

    </div>
    <div class="footer">
        <div class="container">
    <!-- <div class="social">
	<ul class="social-list">
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
	</ul>
</div> -->
    <div class="copyright">
        <span>
            
            
            
                © zxl 2017 - 2020
            
        </span>
    </div>
    <!-- <div class="power">
        <span>
            Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> & <a href="https://github.com/CaiChenghan/iLiKE" target="_blank" rel="noopener">iLiKE Theme</a>
        </span>
    </div> -->
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
    <!--page counter part-->
<script>
function addCount (Counter) {
    url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query = new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find({
        success: function(results) {
            if (results.length>0) {
                var counter=results[0];
                counter.fetchWhenSave(true); //get recent result
                counter.increment("time");
                counter.save();
            } else {
                var newcounter=new Counter();
                newcounter.set("title",title);
                newcounter.set("url",url);
                newcounter.set("time",1);
                newcounter.save(null,{
                    success: function(newcounter) {
                        //alert('New object created');
                    }, error: function(newcounter,error) {
                        alert('Failed to create');
                    }
                })
            }
        },
        error: function(error) {
            //find null is not a error
            alert('Error:'+error.code+" "+error.message);
        }
    });
}
$(function() {
    var Counter=AV.Object.extend("Counter");
    //only increse visit counting when intering a page
    if ($('.article-title').length == 1) {
       addCount(Counter);
    }
    var query=new AV.Query(Counter);
    query.descending("time");
    // the sum of popular posts
    query.limit(10); 
    query.find({
        success: function(results) {
                for(var i=0;i<results.length;i++) {
                    var counter=results[i];
                    title=counter.get("title");
                    url=counter.get("url");
                    time=counter.get("time");
                    // add to the popularlist widget
                    showcontent=title+" ("+time+")";
                    //notice the "" in href
                    $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                }
            },
        error: function(error) {
            alert("Error:"+error.code+" "+error.message);
        }
    });
});
</script>
</div>
    </div>
    <div class="backtop">
        <div class="container">
  <a href="#" class="backtop"></a>
</div>
    </div>
</body>
</html>
